{"payload":{"allShortcutsEnabled":true,"fileTree":{"C++":{"items":[{"name":"stlbookcode","path":"C++/stlbookcode","contentType":"directory"},{"name":"tass-sgi-stl-2.91.57-source","path":"C++/tass-sgi-stl-2.91.57-source","contentType":"directory"},{"name":"C++Primer.md","path":"C++/C++Primer.md","contentType":"file"},{"name":"C++对象模型.md","path":"C++/C++对象模型.md","contentType":"file"},{"name":"EffectiveC++.md","path":"C++/EffectiveC++.md","contentType":"file"},{"name":"STL源码剖析.md","path":"C++/STL源码剖析.md","contentType":"file"}],"totalCount":6},"":{"items":[{"name":"C++","path":"C++","contentType":"directory"},{"name":"Docker","path":"Docker","contentType":"directory"},{"name":"Linux","path":"Linux","contentType":"directory"},{"name":"interview","path":"interview","contentType":"directory"},{"name":"pic","path":"pic","contentType":"directory"},{"name":"操作系统","path":"操作系统","contentType":"directory"},{"name":"数据库","path":"数据库","contentType":"directory"},{"name":"数据结构与算法","path":"数据结构与算法","contentType":"directory"},{"name":"计算机网络","path":"计算机网络","contentType":"directory"},{"name":"README.md","path":"README.md","contentType":"file"}],"totalCount":10}},"fileTreeProcessingTime":4.272342999999999,"foldersToFetch":[],"reducedMotionEnabled":"system","repo":{"id":122694826,"defaultBranch":"master","name":"note","ownerLogin":"arkingc","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2018-02-24T10:28:11.000+08:00","ownerAvatar":"https://avatars.githubusercontent.com/u/22427361?v=4","public":true,"private":false,"isOrgOwned":false},"symbolsExpanded":true,"treeExpanded":true,"refInfo":{"name":"master","listCacheKey":"v0:1547540620.0","canEdit":true,"refType":"branch","currentOid":"9a785e68a4791f6b57b0aad43a51569f25eec9e0"},"path":"C++/STL源码剖析.md","currentUser":{"id":28808277,"login":"Eggze2","userEmail":"3088371460@qq.com"},"blob":{"rawLines":null,"stylingDirectives":null,"csv":null,"csvError":null,"dependabotInfo":{"showConfigurationBanner":false,"configFilePath":null,"networkDependabotPath":"/arkingc/note/network/updates","dismissConfigurationNoticePath":"/settings/dismiss-notice/dependabot_configuration_notice","configurationNoticeDismissed":false,"repoAlertsPath":"/arkingc/note/security/dependabot","repoSecurityAndAnalysisPath":"/arkingc/note/settings/security_analysis","repoOwnerIsOrg":false,"currentUserCanAdminRepo":false},"displayName":"STL源码剖析.md","displayUrl":"https://github.com/arkingc/note/blob/master/C++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md?raw=true","headerInfo":{"blobSize":"131 KB","deleteInfo":{"deleteTooltip":"Fork this repository and delete the file"},"editInfo":{"editTooltip":"Fork this repository and edit the file"},"ghDesktopPath":"x-github-client://openRepo/https://github.com/arkingc/note?branch=master&filepath=C%2B%2B%2FSTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md","gitLfsPath":null,"onBranch":true,"shortPath":"3a379f5","siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Farkingc%2Fnote%2Fblob%2Fmaster%2FC%252B%252B%2FSTL%25E6%25BA%2590%25E7%25A0%2581%25E5%2589%2596%25E6%259E%2590.md","isCSV":false,"isRichtext":true,"toc":[{"level":1,"text":"一.简介","anchor":"一简介","htmlText":"一.简介"},{"level":2,"text":"1.GNU源代码开放精神","anchor":"1gnu源代码开放精神","htmlText":"1.GNU源代码开放精神"},{"level":2,"text":"2.STL版本","anchor":"2stl版本","htmlText":"2.STL版本"},{"level":2,"text":"3.SGI STL头文件分布","anchor":"3sgi-stl头文件分布","htmlText":"3.SGI STL头文件分布"},{"level":2,"text":"4.STL六大部件","anchor":"4stl六大部件","htmlText":"4.STL六大部件"},{"level":1,"text":"二.空间分配器","anchor":"二空间分配器","htmlText":"二.空间分配器"},{"level":2,"text":"1.空间分配器的标准接口","anchor":"1空间分配器的标准接口","htmlText":"1.空间分配器的标准接口"},{"level":2,"text":"2.SGI标准的空间分配器std::allocator","anchor":"2sgi标准的空间分配器stdallocator","htmlText":"2.SGI标准的空间分配器std::allocator"},{"level":2,"text":"3.SGI特殊的空间分配器std::alloc","anchor":"3sgi特殊的空间分配器stdalloc","htmlText":"3.SGI特殊的空间分配器std::alloc"},{"level":3,"text":"3.1 对象构造与析构","anchor":"31-对象构造与析构","htmlText":"3.1 对象构造与析构"},{"level":3,"text":"3.2 内存分配与释放","anchor":"32-内存分配与释放","htmlText":"3.2 内存分配与释放"},{"level":4,"text":"1）两级分配器","anchor":"1两级分配器","htmlText":"1）两级分配器"},{"level":4,"text":"2）第一级分配器__malloc_alloc_template","anchor":"2第一级分配器__malloc_alloc_template","htmlText":"2）第一级分配器__malloc_alloc_template"},{"level":4,"text":"3）第二级分配器__default_alloc_template","anchor":"3第二级分配器__default_alloc_template","htmlText":"3）第二级分配器__default_alloc_template"},{"level":3,"text":"3.3 内存基本处理工具","anchor":"33-内存基本处理工具","htmlText":"3.3 内存基本处理工具"},{"level":1,"text":"三.迭代器与traits编程技法","anchor":"三迭代器与traits编程技法","htmlText":"三.迭代器与traits编程技法"},{"level":2,"text":"1.迭代器相应类型","anchor":"1迭代器相应类型","htmlText":"1.迭代器相应类型"},{"level":2,"text":"2.traits编程技法","anchor":"2traits编程技法","htmlText":"2.traits编程技法"},{"level":3,"text":"2.1 迭代器类型","anchor":"21-迭代器类型","htmlText":"2.1 迭代器类型"},{"level":2,"text":"3.std::iterator的保证","anchor":"3stditerator的保证","htmlText":"3.std::iterator的保证"},{"level":2,"text":"4.SGI STL的__type_traits","anchor":"4sgi-stl的__type_traits","htmlText":"4.SGI STL的__type_traits"},{"level":1,"text":"四.顺序容器","anchor":"四顺序容器","htmlText":"四.顺序容器"},{"level":2,"text":"1.vector","anchor":"1vector","htmlText":"1.vector"},{"level":3,"text":"1.1 迭代器","anchor":"11-迭代器","htmlText":"1.1 迭代器"},{"level":3,"text":"1.2 分配器","anchor":"12-分配器","htmlText":"1.2 分配器"},{"level":3,"text":"1.3 vector操作的实现","anchor":"13-vector操作的实现","htmlText":"1.3 vector操作的实现"},{"level":2,"text":"2.list","anchor":"2list","htmlText":"2.list"},{"level":3,"text":"2.1 节点","anchor":"21-节点","htmlText":"2.1 节点"},{"level":3,"text":"2.2 迭代器","anchor":"22-迭代器","htmlText":"2.2 迭代器"},{"level":3,"text":"2.3 list的数据结构","anchor":"23-list的数据结构","htmlText":"2.3 list的数据结构"},{"level":3,"text":"2.4 分配器","anchor":"24-分配器","htmlText":"2.4 分配器"},{"level":3,"text":"2.5 list操作的实现","anchor":"25-list操作的实现","htmlText":"2.5 list操作的实现"},{"level":2,"text":"3.deque","anchor":"3deque","htmlText":"3.deque"},{"level":3,"text":"3.1 迭代器","anchor":"31-迭代器","htmlText":"3.1 迭代器"},{"level":3,"text":"3.3 deque的数据结构","anchor":"33-deque的数据结构","htmlText":"3.3 deque的数据结构"},{"level":3,"text":"3.4 分配器","anchor":"34-分配器","htmlText":"3.4 分配器"},{"level":3,"text":"3.5 deque操作的实现","anchor":"35-deque操作的实现","htmlText":"3.5 deque操作的实现"},{"level":2,"text":"4.stack","anchor":"4stack","htmlText":"4.stack"},{"level":2,"text":"5.queue","anchor":"5queue","htmlText":"5.queue"},{"level":2,"text":"6.heap","anchor":"6heap","htmlText":"6.heap"},{"level":2,"text":"7.priority_queue","anchor":"7priority_queue","htmlText":"7.priority_queue"},{"level":2,"text":"8.slist","anchor":"8slist","htmlText":"8.slist"},{"level":3,"text":"8.1 slist的节点","anchor":"81-slist的节点","htmlText":"8.1 slist的节点"},{"level":3,"text":"8.2 slist的迭代器","anchor":"82-slist的迭代器","htmlText":"8.2 slist的迭代器"},{"level":1,"text":"五.关联容器","anchor":"五关联容器","htmlText":"五.关联容器"},{"level":2,"text":"1.RB-tree","anchor":"1rb-tree","htmlText":"1.RB-tree"},{"level":3,"text":"1.1 RB-tree的节点","anchor":"11-rb-tree的节点","htmlText":"1.1 RB-tree的节点"},{"level":3,"text":"1.2 RB-tree的迭代器","anchor":"12-rb-tree的迭代器","htmlText":"1.2 RB-tree的迭代器"},{"level":3,"text":"1.3 RB-tree操作的实现","anchor":"13-rb-tree操作的实现","htmlText":"1.3 RB-tree操作的实现"},{"level":2,"text":"2.set","anchor":"2set","htmlText":"2.set"},{"level":2,"text":"3.map","anchor":"3map","htmlText":"3.map"},{"level":2,"text":"4.multiset","anchor":"4multiset","htmlText":"4.multiset"},{"level":2,"text":"5.multimap","anchor":"5multimap","htmlText":"5.multimap"},{"level":2,"text":"6.hashtable","anchor":"6hashtable","htmlText":"6.hashtable"},{"level":3,"text":"6.1 hashtable的迭代器","anchor":"61-hashtable的迭代器","htmlText":"6.1 hashtable的迭代器"},{"level":3,"text":"6.2 hashtable的实现","anchor":"62-hashtable的实现","htmlText":"6.2 hashtable的实现"},{"level":3,"text":"6.3 hashtable操作的实现","anchor":"63-hashtable操作的实现","htmlText":"6.3 hashtable操作的实现"},{"level":3,"text":"6.4 hash functions","anchor":"64-hash-functions","htmlText":"6.4 hash functions"},{"level":2,"text":"7.hash_set","anchor":"7hash_set","htmlText":"7.hash_set"},{"level":2,"text":"8.hash_map","anchor":"8hash_map","htmlText":"8.hash_map"},{"level":2,"text":"9.hash_multiset","anchor":"9hash_multiset","htmlText":"9.hash_multiset"},{"level":2,"text":"10.hash_multimap","anchor":"10hash_multimap","htmlText":"10.hash_multimap"},{"level":1,"text":"六.算法","anchor":"六算法","htmlText":"六.算法"},{"level":2,"text":"1.区间拷贝","anchor":"1区间拷贝","htmlText":"1.区间拷贝"},{"level":3,"text":"1.1 copy","anchor":"11-copy","htmlText":"1.1 copy"},{"level":3,"text":"1.2 copy_backward","anchor":"12-copy_backward","htmlText":"1.2 copy_backward"},{"level":2,"text":"2.set相关算法","anchor":"2set相关算法","htmlText":"2.set相关算法"},{"level":3,"text":"2.1 set_union","anchor":"21-set_union","htmlText":"2.1 set_union"},{"level":3,"text":"2.2 set_intersection","anchor":"22-set_intersection","htmlText":"2.2 set_intersection"},{"level":3,"text":"2.3 set_difference","anchor":"23-set_difference","htmlText":"2.3 set_difference"},{"level":3,"text":"2.4 set_symmetric_difference","anchor":"24-set_symmetric_difference","htmlText":"2.4 set_symmetric_difference"},{"level":2,"text":"3.排序sort","anchor":"3排序sort","htmlText":"3.排序sort"},{"level":2,"text":"4.其它算法","anchor":"4其它算法","htmlText":"4.其它算法"},{"level":1,"text":"七.仿函数","anchor":"七仿函数","htmlText":"七.仿函数"},{"level":2,"text":"1.仿函数的相应类型","anchor":"1仿函数的相应类型","htmlText":"1.仿函数的相应类型"},{"level":3,"text":"1.1 unary_function","anchor":"11-unary_function","htmlText":"1.1 unary_function"},{"level":3,"text":"1.2 binary_function","anchor":"12-binary_function","htmlText":"1.2 binary_function"},{"level":2,"text":"2.算术类仿函数","anchor":"2算术类仿函数","htmlText":"2.算术类仿函数"},{"level":2,"text":"3.关系运算类仿函数","anchor":"3关系运算类仿函数","htmlText":"3.关系运算类仿函数"},{"level":2,"text":"4.逻辑运算类仿函数","anchor":"4逻辑运算类仿函数","htmlText":"4.逻辑运算类仿函数"},{"level":2,"text":"5.证同，选择与投射","anchor":"5证同选择与投射","htmlText":"5.证同，选择与投射"},{"level":1,"text":"八.适配器","anchor":"八适配器","htmlText":"八.适配器"},{"level":2,"text":"1.容器适配器","anchor":"1容器适配器","htmlText":"1.容器适配器"},{"level":2,"text":"2.迭代器适配器","anchor":"2迭代器适配器","htmlText":"2.迭代器适配器"},{"level":3,"text":"2.1 insert iterators","anchor":"21-insert-iterators","htmlText":"2.1 insert iterators"},{"level":4,"text":"1）back_insert_iterator","anchor":"1back_insert_iterator","htmlText":"1）back_insert_iterator"},{"level":4,"text":"2）front_insert_iterator","anchor":"2front_insert_iterator","htmlText":"2）front_insert_iterator"},{"level":4,"text":"3）insert_iterator","anchor":"3insert_iterator","htmlText":"3）insert_iterator"},{"level":3,"text":"2.2 reverse iterators","anchor":"22-reverse-iterators","htmlText":"2.2 reverse iterators"},{"level":3,"text":"2.3 iostream iterators","anchor":"23-iostream-iterators","htmlText":"2.3 iostream iterators"},{"level":4,"text":"1）istream_iterator","anchor":"1istream_iterator","htmlText":"1）istream_iterator"},{"level":4,"text":"2）ostream_iterator","anchor":"2ostream_iterator","htmlText":"2）ostream_iterator"},{"level":2,"text":"3.函数适配器","anchor":"3函数适配器","htmlText":"3.函数适配器"},{"level":3,"text":"3.1 not1和not2","anchor":"31-not1和not2","htmlText":"3.1 not1和not2"},{"level":4,"text":"1）not1","anchor":"1not1","htmlText":"1）not1"},{"level":4,"text":"2）not2","anchor":"2not2","htmlText":"2）not2"},{"level":3,"text":"3.2 bind1st和bind2st","anchor":"32-bind1st和bind2st","htmlText":"3.2 bind1st和bind2st"},{"level":4,"text":"1）bind1st","anchor":"1bind1st","htmlText":"1）bind1st"},{"level":4,"text":"2）bind2st","anchor":"2bind2st","htmlText":"2）bind2st"},{"level":3,"text":"3.3 compose1和compose2","anchor":"33-compose1和compose2","htmlText":"3.3 compose1和compose2"},{"level":4,"text":"1）compose1","anchor":"1compose1","htmlText":"1）compose1"},{"level":4,"text":"2）compose2","anchor":"2compose2","htmlText":"2）compose2"},{"level":3,"text":"3.4 用于函数指针的ptr_fun","anchor":"34-用于函数指针的ptr_fun","htmlText":"3.4 用于函数指针的ptr_fun"},{"level":3,"text":"3.5 用于成员函数指针的mem_fun和mem_fun_ref","anchor":"35-用于成员函数指针的mem_fun和mem_fun_ref","htmlText":"3.5 用于成员函数指针的mem_fun和mem_fun_ref"}],"lineInfo":{"truncatedLoc":"3131","truncatedSloc":"2490"},"mode":"file"},"image":false,"isCodeownersFile":null,"isPlain":false,"isValidLegacyIssueTemplate":false,"issueTemplateHelpUrl":"https://docs.github.com/articles/about-issue-and-pull-request-templates","issueTemplate":null,"discussionTemplate":null,"language":"Markdown","languageID":222,"large":false,"loggedIn":true,"newDiscussionPath":"/arkingc/note/discussions/new","newIssuePath":"/arkingc/note/issues/new","planSupportInfo":{"repoIsFork":null,"repoOwnedByCurrentUser":null,"requestFullPath":"/arkingc/note/blob/master/C%2B%2B/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md","showFreeOrgGatedFeatureMessage":null,"showPlanSupportBanner":null,"upgradeDataAttributes":null,"upgradePath":null},"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_dockerfile","dismissStackNoticePath":"/settings/dismiss-notice/publish_stack_from_file","releasePath":"/arkingc/note/releases/new?marketplace=true","showPublishActionBanner":false,"showPublishStackBanner":false},"rawBlobUrl":"https://github.com/arkingc/note/raw/master/C++/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md","renderImageOrRaw":false,"richText":"<article class=\"markdown-body entry-content container-lg\" itemprop=\"text\"><ul dir=\"auto\">\n<li><a href=\"#%E4%B8%80%E7%AE%80%E4%BB%8B\">一.简介</a>\n<ul dir=\"auto\">\n<li><a href=\"#1gnu%E6%BA%90%E4%BB%A3%E7%A0%81%E5%BC%80%E6%94%BE%E7%B2%BE%E7%A5%9E\">1.GNU源代码开发精神</a></li>\n<li><a href=\"#2stl%E7%89%88%E6%9C%AC\">2.STL版本</a></li>\n<li><a href=\"#3sgi-stl%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83\">3.SGI STL头文件分布</a></li>\n<li><a href=\"#4stl%E5%85%AD%E5%A4%A7%E9%83%A8%E4%BB%B6\">4.STL六大部件</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8C%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8\">二.空间分配器</a>\n<ul dir=\"auto\">\n<li><a href=\"#1%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3\">1.空间分配器的标准接口</a></li>\n<li><a href=\"#2sgi%E6%A0%87%E5%87%86%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8stdallocator\">2.SGI标准的空间分配器std::allocator</a></li>\n<li><a href=\"#3sgi%E7%89%B9%E6%AE%8A%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8stdalloc\">3.SGI特殊的空间分配器std::alloc</a>\n<ul dir=\"auto\">\n<li><a href=\"#31-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84\">3.1 对象构造与析构</a></li>\n<li><a href=\"#32-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE\">3.2 内存分配与释放</a>\n<ul dir=\"auto\">\n<li><a href=\"#1%E4%B8%A4%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8\">1）两级分配器</a></li>\n<li><a href=\"#2%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8__malloc_alloc_template\">2）第一级分配器__malloc_alloc_template</a></li>\n<li><a href=\"#3%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E9%85%8D%E5%99%A8__default_alloc_template\">3）第二级分配器__default_alloc_template</a></li>\n</ul>\n</li>\n<li><a href=\"#33-%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7\">3.3 内存基本处理工具</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Etraits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95\">三.迭代器与traits编程技法</a>\n<ul dir=\"auto\">\n<li><a href=\"#1%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9B%B8%E5%BA%94%E7%B1%BB%E5%9E%8B\">1.迭代器相应类型</a></li>\n<li><a href=\"#2traits%E7%BC%96%E7%A8%8B%E6%8A%80%E6%B3%95\">2.traits编程技法</a></li>\n<li><a href=\"#3stditerator%E7%9A%84%E4%BF%9D%E8%AF%81\">3.std::iterator的保证</a></li>\n<li><a href=\"#4sgi-stl%E7%9A%84__type_traits\">4.SGI STL的__type_traits</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9B%9B%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8\">四.顺序容器</a>\n<ul dir=\"auto\">\n<li><a href=\"#1vector\">1.vector</a></li>\n<li><a href=\"#2list\">2.list</a></li>\n<li><a href=\"#3deque\">3.deque</a></li>\n<li><a href=\"#4stack\">4.stack</a></li>\n<li><a href=\"#5queue\">5.queue</a></li>\n<li><a href=\"#6heap\">6.heap</a></li>\n<li><a href=\"#7priority_queue\">7.priority_queue</a></li>\n<li><a href=\"#8slist\">8.slist</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%94%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8\">五.关联容器</a>\n<ul dir=\"auto\">\n<li><a href=\"#1rb-tree\">1.RB-tree</a></li>\n<li><a href=\"#2set\">2.set</a></li>\n<li><a href=\"#3map\">3.map</a></li>\n<li><a href=\"#4multiset\">4.multiset</a></li>\n<li><a href=\"#5multimap\">5.multimap</a></li>\n<li><a href=\"#6hashtable\">6.hashtable</a></li>\n<li><a href=\"#7hash_set\">7.hash_set</a></li>\n<li><a href=\"#8hash_map\">8.hash_map</a></li>\n<li><a href=\"#9hash_multiset\">9.hash_multiset</a></li>\n<li><a href=\"#10hash_multimap\">10.hash_multimap</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%AD%E7%AE%97%E6%B3%95\">六.算法</a>\n<ul dir=\"auto\">\n<li><a href=\"#1%E5%8C%BA%E9%97%B4%E6%8B%B7%E8%B4%9D\">1.区间拷贝</a></li>\n<li><a href=\"#2set%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95\">2.set相关算法</a></li>\n<li><a href=\"#3%E6%8E%92%E5%BA%8Fsort\">3.排序sort</a></li>\n<li><a href=\"#4%E5%85%B6%E5%AE%83%E7%AE%97%E6%B3%95\">4.其它算法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%83%E4%BB%BF%E5%87%BD%E6%95%B0\">七.仿函数</a>\n<ul dir=\"auto\">\n<li><a href=\"#1%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E5%BA%94%E7%B1%BB%E5%9E%8B\">1.仿函数的相应类型</a></li>\n<li><a href=\"#2%E7%AE%97%E6%9C%AF%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0\">2.算术类仿函数</a></li>\n<li><a href=\"#3%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0\">3.关系运算类仿函数</a></li>\n<li><a href=\"#4%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%B1%BB%E4%BB%BF%E5%87%BD%E6%95%B0\">4.逻辑运算类仿函数</a></li>\n<li><a href=\"#5%E8%AF%81%E5%90%8C%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8A%95%E5%B0%84\">5.证同，选择与投射</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%AB%E9%80%82%E9%85%8D%E5%99%A8\">八.适配器</a>\n<ul dir=\"auto\">\n<li><a href=\"#1%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8\">1.容器适配器</a></li>\n<li><a href=\"#2%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8\">2.迭代器适配器</a>\n<ul dir=\"auto\">\n<li><a href=\"#21-insert-iterators\">2.1 insert iterators</a></li>\n<li><a href=\"#22-reverse-iterators\">2.2 reverse iterators</a></li>\n<li><a href=\"#23-iostream-iterators\">2.3 iostream iterators</a></li>\n</ul>\n</li>\n<li><a href=\"#3%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8\">3.函数适配器</a>\n<ul dir=\"auto\">\n<li><a href=\"#31-not1%E5%92%8Cnot2\">3.1 not1和not2</a></li>\n<li><a href=\"#32-bind1st%E5%92%8Cbind2st\">3.2 bind1st和bind2st</a></li>\n<li><a href=\"#33-compose1%E5%92%8Ccompose2\">3.3 compose1和compose2</a></li>\n<li><a href=\"#34-%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84ptr_fun\">3.4 用于函数指针的ptr_fun</a></li>\n<li><a href=\"#35-%E7%94%A8%E4%BA%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84mem_fun%E5%92%8Cmem_fun_ref\">3.5 用于成员函数指针的mem_fun和mem_fun_ref</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<br>\n<h1 tabindex=\"-1\" id=\"user-content-一简介\" dir=\"auto\"><a class=\"heading-link\" href=\"#一简介\">一.简介<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h1>\n<h2 tabindex=\"-1\" id=\"user-content-1gnu源代码开放精神\" dir=\"auto\"><a class=\"heading-link\" href=\"#1gnu源代码开放精神\">1.GNU源代码开放精神<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">全世界所有的STL实现版本，都源于Alexander Stepanov和Meng Lee完成的原始版本，这份原始版本有Hewlett-Packard Compant(惠普公司)拥有。每一个头文件都有一份声明，允许任何人任意运用、拷贝、修改、传播、贩卖这些代码，无需付费，唯一的条件是必须将声明置于使用者新开发的文件内</p>\n<p dir=\"auto\">这份开放源代码的精神，一般统称为<strong>open source</strong></p>\n<p dir=\"auto\"><strong>GNU</strong>(音译为“革奴”)，代码<strong>G</strong>UN is <strong>N</strong>ot <strong>U</strong>nix。当时Unix是计算机界主流操作系统，由AT&amp;T Bell实验室的Ken Thompson和Dennis Ritchie创造。原本只是学术上的一个练习产品，AT&amp;T将它分享给许多研究人员。但是当所有研究与分享使这个产品越来越美好时，AT&amp;T开始思考是否应该追加投资，从中获利。于是开始要求大学校园内的相关研究人员签约，要求他们不得公开或透露UNIX源代码，并赞助Berkeley大学继续强化UNIX，导致后来发展出BSD(Berkeley Software Distribution)版本，以及更后来的FreeBSD、OpenBSD、NetBSD...，<strong>Stallman将AT&amp;T的这种行为视为思想禁锢，以及一种伟大传统的沦丧，于是进行了他的反奴役计划，称之为GNU:GUN is Not Unix</strong>，<strong>GNU计划中，早期最著名的软件包括Emacs和GCC，晚期最著名的是Linux操作系统</strong></p>\n<p dir=\"auto\"><strong>GNU以所谓的GPL(General Public License，广泛开放授权)来保护(或说控制)其成员</strong>：使用者可以自由阅读与修改GPL软件的源码，但如果使用者要传播借助GPL软件而完成的软件，必须也同意GPL规范。这种精神主要是强迫人们分享并回馈他们对GPL软件的改善。得之于人，舍于人</p>\n<p dir=\"auto\"><strong>Cygnus是一家商业公司</strong>，包装并出售自由软件基金会所构造的软件工具，并贩卖各种服务。他们协助芯片厂商调整GCC，在GPL的精神和规范下将GCC源代码的修正公布于世；他们提供GCC运作信息，提升其运行效率，并因此成为GCC技术领域的最佳咨询对象。Cygnus公司之于GCC，地位就像Red Hat公司之于Linux</p>\n<h2 tabindex=\"-1\" id=\"user-content-2stl版本\" dir=\"auto\"><a class=\"heading-link\" href=\"#2stl版本\">2.STL版本<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<ul dir=\"auto\">\n<li><strong>HP实现版本</strong>(HP STL)\n<ul dir=\"auto\">\n<li><strong>所有STL实现版本的始祖</strong></li>\n<li>运行任何人免费使用、拷贝、修改、传播、贩卖这份软件及其说明文件</li>\n<li>唯一需要遵守的是：必须在所有文件中加上HP的版本声明和运用权限声明</li>\n<li>这种授权不属于GNU GPL范畴，但属于open source范畴</li>\n</ul>\n</li>\n<li><strong>P.J. Plauger实现版本</strong>(PJ STL)\n<ul dir=\"auto\">\n<li>继承自HP版本，所有每一个头文件都有HP的版本说明</li>\n<li>此外还加上P.J. Plauger的个人版权声明</li>\n<li>不属于GNU GPL范畴，也不属于open source范畴</li>\n<li><strong>被Visual C++采用</strong></li>\n<li>符号命名不讲究、可读性较低</li>\n</ul>\n</li>\n<li><strong>Rouge Wave实现版本</strong>(RW STL)\n<ul dir=\"auto\">\n<li>继承自HP版本，所以每一个头文件都有HP的版本说明</li>\n<li>此外还加上Rouge Wave的公司版权声明</li>\n<li>不属于GNU GPL范畴，也不属于open source范畴</li>\n<li><strong>被C++Builder采用</strong>（C++Builder对C++语言特性支持不错，连带给予了RW版本正面的影响）</li>\n<li>可读性不错</li>\n</ul>\n</li>\n<li><strong>STLport实现版本</strong>\n<ul dir=\"auto\">\n<li>以SGI STL为蓝本的高度可移植性实现版本</li>\n</ul>\n</li>\n<li><strong>SGI STL实现版本</strong>\n<ul dir=\"auto\">\n<li>继承自HP版本，所以每一个头文件都有HP的版本说明</li>\n<li>此外还加上SGI的公司版权声明</li>\n<li>不属于GNU GPL范畴，但属于open source范畴</li>\n<li><strong>被GCC采用</strong>（GCC对C++语言特性支持很好，连带给予了SGI STL正面影响）</li>\n<li>可读性很高</li>\n<li>为了具有高度移植性，考虑了不同编译器的不同编译能力</li>\n</ul>\n</li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-3sgi-stl头文件分布\" dir=\"auto\"><a class=\"heading-link\" href=\"#3sgi-stl头文件分布\">3.SGI STL头文件分布<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<ol dir=\"auto\">\n<li><strong>C++标准规范下的C头文件</strong>：cstdio，csyflib，cstring，...</li>\n<li><strong>C++标准程序库中不属于STL范畴者</strong>：stream，string，...</li>\n<li><strong>STL标准头文件(无扩展名)</strong>：vector，deque，list，map，...</li>\n<li><strong>C++标准定案前，HP所规范的STL头文件</strong>：vector.h，deque.h，list.h，...</li>\n<li><strong>SGI STL内部文件</strong>(<strong>STL真正实现与此</strong>)：stl_vector.h，stl_deque.h，stl_algo.h，...</li>\n</ol>\n<p dir=\"auto\">不同的编译器<strong>对C++语言的支持程度</strong>不尽相同。作为一个希望具备广泛移植能力的程序库，SGI STL准备了一个<strong>环境组态文件</strong><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_config.h\">&lt;stl_config.h&gt;</a>，其中定义了许多常量，标示某些组态的成立与否，所有STL头文件都会直接或间接包含这个组态文件，并以条件式写法，让预处理器根据各个常量决定取舍哪一段程序代码，例如：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-1-2.png\"><img src=\"/arkingc/note/raw/master/pic/stl-1-2.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\"><strong>组态测试程序</strong>：</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config.cpp\">编译器对组态的支持</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config3.cpp\">组态3：__STL_STATIC_TEMPLATE_MEMBER_BUG</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config5.cpp\">组态5：__STL_CLASS_PARTIAL_SPECIALIZATION</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config6.cpp\">组态6：__STL_FUNCTION_TMPL_PARTIAL_ORDER</a></li>\n<li>组态7：__STL_EXPLICIT_FUNCTION_TMPL_ARGS（整个SGI STL内都没有用到这一常量定义）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config8.cpp\">组态8：__STL_MEMBER_TEMPLATES</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config10.cpp\">组态10：__STL_LIMITED_DEFAULT_TEMPLATES</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config11.cpp\">组态11：__STL_NON_TYPE_TMPL_PARAM_BUG</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config-null-template-arguments.cpp\">组态：__STL_EXPLICIT_FUNCTION_TMPL_ARGS</a>（<strong>bound friend templates</strong>）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c1/1config-template-exp-special.cpp\">组态：__STL_TEMPLATE_NULL</a>（<strong>class template explicit specialization</strong>）</li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-4stl六大部件\" dir=\"auto\"><a class=\"heading-link\" href=\"#4stl六大部件\">4.STL六大部件<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-1-1.png\"><img src=\"/arkingc/note/raw/master/pic/stl-1-1.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">最重要的2个是<strong>容器</strong>与<strong>算法</strong></p>\n<ul dir=\"auto\">\n<li><strong>容器</strong>(container)</li>\n<li><strong>分配器</strong>(Allocator)</li>\n<li><strong>算法</strong>(Algorithms)</li>\n<li><strong>迭代器</strong>(Iterrators)</li>\n<li><strong>适配器</strong>(Adaptors)</li>\n<li><strong>仿函数</strong>(Functors)</li>\n</ul>\n<br>\n<h1 tabindex=\"-1\" id=\"user-content-二空间分配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#二空间分配器\">二.空间分配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h1>\n<p dir=\"auto\">在运用层面，不需要关注空间分配器。但是在容器背后，空间分配器负责容器中元素空间的分配</p>\n<p dir=\"auto\">不称作”内存分配器“，是因为分配的空间不一定是内存，可以是磁盘或其它辅助存储介质。可以实现一个获取磁盘空间的allocator。不过这里介绍的空间分配器获取的空间是内存</p>\n<h2 tabindex=\"-1\" id=\"user-content-1空间分配器的标准接口\" dir=\"auto\"><a class=\"heading-link\" href=\"#1空间分配器的标准接口\">1.空间分配器的标准接口<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">通常，C++内存分配和释放的操作如下：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Foo {...};\nFoo *pf = new Foo;\ndelete pf;\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">Foo</span> {...};\nFoo *pf = <span class=\"pl-k\">new</span> Foo;\n<span class=\"pl-k\">delete</span> pf;</pre></div>\n<ul dir=\"auto\">\n<li><strong>new内含2阶段操作</strong>：\n<ul dir=\"auto\">\n<li>调用::operator new分配内存</li>\n<li>调用构造函数构造对象</li>\n</ul>\n</li>\n<li><strong>delete也含2阶段操作</strong>：\n<ul dir=\"auto\">\n<li>调用析构函数析构对象</li>\n<li>调用::operator delete释放内存</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">STL allocator将new和delete的2阶段操作进行了分离：</p>\n<ul dir=\"auto\">\n<li>内存分配：由alloc::allocate()负责</li>\n<li>内存释放：由alloc::deallocate()负责</li>\n<li>对象构造：由alloc::construct()负责</li>\n<li>对象析构：由alloc::destroy负责</li>\n</ul>\n<p dir=\"auto\">根据<strong>STL的规范</strong>，以下是allocator的必要接口：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"allocator::value_type\nallocator::pointer\nallocator::const_pointer\nallocator::reference\nallocator::const_reference\nallocator::size_type\nallocator::difference_type\n\n//一个嵌套的class template，class rebind&lt;U&gt; 拥有唯一成员other,是一个typedef，代表allocator&lt;U&gt; \nallocator::rebind\n\n//构造函数\nallocator::allocator()\n//拷贝构造函数\nallocator::allocator(const allocator&amp;)  \ntemplate &lt;class U&gt; allocator::allocator(const allocator&lt;U&gt;&amp;)\n//析构函数\nallocator::~allocator\n\n//返回某个对象的地址，等同于&amp;x\npointer allocator::address(reference x) const   \nconst_pointer allocator::address(const_reference x) const\n\n//分配空间，足以容纳n个元素\npointer allocator::allocate(size_type n,const void* = 0)\n//归还之前分配的空间\nvoid allocator::deallocate(pointer p,size_type n)\n//可分配的最大空间\nsize_type allocator::max_size() const\n\n//通过x，在p指向的地址构造一个对象。相当于new((void*)p) T(x)\nvoid allocator::construct(pointer p,const T&amp; x)\n//析构地址p的对象\nvoid allocator::destroy(pointer p)\"><pre>allocator::value_type\nallocator::pointer\nallocator::const_pointer\nallocator::reference\nallocator::const_reference\nallocator::size_type\nallocator::difference_type\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>一个嵌套的class template，class rebind&lt;U&gt; 拥有唯一成员other,是一个typedef，代表allocator&lt;U&gt; </span>\nallocator::rebind\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n<span class=\"pl-en\">allocator::allocator</span>()\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>拷贝构造函数</span>\nallocator::allocator(<span class=\"pl-k\">const</span> allocator&amp;)  \ntemplate &lt;class U&gt; allocator::allocator(<span class=\"pl-k\">const</span> allocator&lt;U&gt;&amp;)\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>析构函数</span>\nallocator::~allocator\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>返回某个对象的地址，等同于&amp;x</span>\npointer allocator::address(reference x) <span class=\"pl-k\">const</span>   \nconst_pointer allocator::address(const_reference x) <span class=\"pl-k\">const</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>分配空间，足以容纳n个元素</span>\npointer allocator::allocate(size_type n,<span class=\"pl-k\">const</span> <span class=\"pl-k\">void</span>* = <span class=\"pl-c1\">0</span>)\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>归还之前分配的空间</span>\nvoid allocator::deallocate(pointer p,size_type n)\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>可分配的最大空间</span>\nsize_type allocator::max_size() <span class=\"pl-k\">const</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>通过x，在p指向的地址构造一个对象。相当于new((void*)p) T(x)</span>\nvoid allocator::construct(pointer p,<span class=\"pl-k\">const</span> T&amp; x)\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>析构地址p的对象</span>\nvoid allocator::destroy(pointer p)</pre></div>\n<ul dir=\"auto\">\n<li><strong>只能有限度搭配PJ STL</strong>，因为PJ STL未完全遵循STL规格，其所供应的许多容器都需要一个非标准的空间分配器接口</li>\n<li><strong>只能有限度地搭配RW STL</strong>，因为RW STL在很多容器身上运用了缓冲区，情况复杂很多</li>\n<li><strong>完全无法应用于SGI STL</strong>，因为SGI STL在这个项目上根本就脱离了STL标准规格，使用一个专属的、拥有次层配置能力的、效率优越的特殊分配器。但提供了一个对其进行了封装的名为simple_alloc的分配器，符合部分标准</li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-2sgi标准的空间分配器stdallocator\" dir=\"auto\"><a class=\"heading-link\" href=\"#2sgi标准的空间分配器stdallocator\">2.SGI标准的空间分配器std::allocator<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">虽然SGI也定义有一个<strong>符合”部分“标准</strong>、名为<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/defalloc.h\">allocator</a>的分配器，但SGI自己从未用过它，也<strong>不建议我们使用</strong>。<strong>主要原因是效率不佳</strong>，只把C++的::operator new和::operator delete做一层薄薄的包装而已</p>\n<h2 tabindex=\"-1\" id=\"user-content-3sgi特殊的空间分配器stdalloc\" dir=\"auto\"><a class=\"heading-link\" href=\"#3sgi特殊的空间分配器stdalloc\">3.SGI特殊的空间分配器std::alloc<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">STL标准规定分配器定义于<code>&lt;memory&gt;</code>中，SGI<code>&lt;memory&gt;</code>内含两个文件，负责分离的2阶段操作</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-1.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-1.png\" style=\"max-width: 100%;\"></a> </div>\n<blockquote>\n<p dir=\"auto\">真正在SGI STL中大显身手的分配器（即SGI特殊的空间分配器std::alloc）或为第一级分配器，或为第二级分配器</p>\n</blockquote>\n<h3 tabindex=\"-1\" id=\"user-content-31-对象构造与析构\" dir=\"auto\"><a class=\"heading-link\" href=\"#31-对象构造与析构\">3.1 对象构造与析构<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_construct.h\">&lt;stl_construct.h&gt;</a></p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-2.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-2.png\" style=\"max-width: 100%;\"></a> </div>\n<blockquote>\n<p dir=\"auto\">STL规定分配器必须拥有名为construct()和destroy()的两个成员函数，然而SGI特殊的空间分配器std::alloc并未遵守这一规则，所以实际上这部分属于STL allocator，但不属于std::alloc。换句话说，SGI特殊的空间分配器std::alloc不包含”3.1 对象构造与析构“，只包含”3.2 内存分配与释放“</p>\n</blockquote>\n<h3 tabindex=\"-1\" id=\"user-content-32-内存分配与释放\" dir=\"auto\"><a class=\"heading-link\" href=\"#32-内存分配与释放\">3.2 内存分配与释放<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">SGI对内存分配与释放的设计哲学如下：</p>\n<ul dir=\"auto\">\n<li>向system heap申请空间</li>\n<li>考虑多线程状态</li>\n<li>考虑内存不足时的应变措施</li>\n<li>考虑过多“小型区块”可能造成的内存碎片问题（<strong>SGI设计了双层级分配器</strong>）</li>\n</ul>\n<p dir=\"auto\"><strong>C++的内存分配基本操作是::operator new(),内存释放基本操作是::operator delete()。这两个全局函数相当于C的malloc()和free()函数。SGI正是以malloc和free()完成内存的分配与释放</strong></p>\n<h4 tabindex=\"-1\" id=\"user-content-1两级分配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#1两级分配器\">1）两级分配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">考虑到小型区块所可能造成的内存碎片问题，SGI设计了双层级分配器：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-3.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-3.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>第一级分配器\n<ul dir=\"auto\">\n<li>直接使用malloc()和free()</li>\n</ul>\n</li>\n<li>第二级分配器\n<ul dir=\"auto\">\n<li>当分配区块超过128bytes时，视为“足够大”，调用第一级分配器</li>\n<li>当分配区块小于128bytes时，视为“过小”，为了降低额外负担，采用复杂的memory pool整理方式，不再求助于第一级分配器</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">无论alloc被定义为第一级或第二级分配器，SGI还为它再包装一个接口，使分配器的接口能够符合STL规格：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template&lt;class T, class Alloc&gt;\nclass simple_alloc {\n\npublic:\n    static T *allocate(size_t n)\n                { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); }\n    static T *allocate(void)\n                { return (T*) Alloc::allocate(sizeof (T)); }\n    static void deallocate(T *p, size_t n)\n                { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); }\n    static void deallocate(T *p)\n                { Alloc::deallocate(p, sizeof (T)); }\n};\"><pre><span class=\"pl-k\">template</span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">simple_alloc</span> {\n\n<span class=\"pl-k\">public:</span>\n    <span class=\"pl-k\">static</span> T *<span class=\"pl-en\">allocate</span>(<span class=\"pl-c1\">size_t</span> n)\n                { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">0</span> == n? <span class=\"pl-c1\">0</span> : (T*) <span class=\"pl-c1\">Alloc::allocate</span>(n * <span class=\"pl-k\">sizeof</span> (T)); }\n    <span class=\"pl-k\">static</span> T *<span class=\"pl-en\">allocate</span>(<span class=\"pl-k\">void</span>)\n                { <span class=\"pl-k\">return</span> (T*) <span class=\"pl-c1\">Alloc::allocate</span>(<span class=\"pl-k\">sizeof</span> (T)); }\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">deallocate</span>(T *p, <span class=\"pl-c1\">size_t</span> n)\n                { <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">0</span> != n) <span class=\"pl-c1\">Alloc::deallocate</span>(p, n * <span class=\"pl-k\">sizeof</span> (T)); }\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">deallocate</span>(T *p)\n                { <span class=\"pl-c1\">Alloc::deallocate</span>(p, <span class=\"pl-k\">sizeof</span> (T)); }\n};</pre></div>\n<p dir=\"auto\">内部4个函数都是转调用分配器的成员函数。<strong>这个接口使分配器的分配单位从bytes转为个别元素的大小</strong></p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-4.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-4.png\" style=\"max-width: 100%;\"></a> </div>\n<blockquote>\n<p dir=\"auto\">上图中Alloc=alloc中的缺省alloc可以是第一级分配器，也可以是第二级分配器。SGI STL已经把它设为第二级分配器</p>\n</blockquote>\n<p dir=\"auto\">两级分配器都定义在头文件<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_alloc.h\">&lt;stl_alloc.h&gt;</a>中</p>\n<h4 tabindex=\"-1\" id=\"user-content-2第一级分配器__malloc_alloc_template\" dir=\"auto\"><a class=\"heading-link\" href=\"#2第一级分配器__malloc_alloc_template\">2）第一级分配器__malloc_alloc_template<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//一般而言是线程安全，并且对于空间的运用比较高效\n//无“template型别参数”，至于”非型别参数“inst，则完全没派上用场\ntemplate &lt;int inst&gt;\nclass __malloc_alloc_template {\n\nprivate:\n//oom：out of memory ，用来处理内存不足的情况\nstatic void *oom_malloc(size_t);\n\nstatic void *oom_realloc(void *, size_t);\n\n#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n    static void (* __malloc_alloc_oom_handler)();\n#endif\n\npublic:\n\nstatic void * allocate(size_t n)\n{\n    void *result = malloc(n);//第一级分配器直接使用malloc()\n    //以下无法满足需求时，改用oom_malloc()\n    if (0 == result) result = oom_malloc(n);\n    return result;\n}\n\nstatic void deallocate(void *p, size_t /* n */)\n{\n    free(p);//第一级分配器直接使用free()\n}\n\nstatic void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)\n{\n    void * result = realloc(p, new_sz);//第一级分配器直接使用realloc()\n    //以下无法满足需求时，改用oom_realloc()\n    if (0 == result) result = oom_realloc(p, new_sz);\n    return result;\n}\n\n//以下仿真C++的set_new_handler()。可以通过它指定自己的\n//out-of-memory handler\n//不能直接运用C++ new-handler机制，因为它并非使用::operator new来分配内存\nstatic void (* set_malloc_handler(void (*f)()))()\n{\n    void (* old)() = __malloc_alloc_oom_handler;\n    __malloc_alloc_oom_handler = f;\n    return(old);\n}\n\n};\n\n// malloc_alloc out-of-memory handling\n\n#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG\n//初值为0，有待客户设定\ntemplate &lt;int inst&gt;\nvoid (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = 0;\n#endif\n\ntemplate &lt;int inst&gt;\nvoid * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)\n{\n    void (* my_malloc_handler)();\n    void *result;\n\n    for (;;) {//不断尝试释放、分配、再释放、再分配...\n        my_malloc_handler = __malloc_alloc_oom_handler;\n        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }\n        (*my_malloc_handler)(); //调用处理例程，企图释放内存\n        result = malloc(n);     //再次尝试分配内存\n        if (result) return(result);\n    }\n}\n\ntemplate &lt;int inst&gt;\nvoid * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n)\n{\n    void (* my_malloc_handler)();\n    void *result;\n\n    for (;;) {//不断尝试释放、分配、再释放、再分配...\n        my_malloc_handler = __malloc_alloc_oom_handler;\n        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }\n        (*my_malloc_handler)(); //调用处理例程，企图释放内存\n        result = realloc(p, n); //再次尝试分配内存\n        if (result) return(result);\n    }\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>一般而言是线程安全，并且对于空间的运用比较高效</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>无“template型别参数”，至于”非型别参数“inst，则完全没派上用场</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">int</span> inst&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">__malloc_alloc_template</span> {\n\n<span class=\"pl-k\">private:</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>oom：out of memory ，用来处理内存不足的情况</span>\n<span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> *<span class=\"pl-en\">oom_malloc</span>(<span class=\"pl-c1\">size_t</span>);\n\n<span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> *<span class=\"pl-en\">oom_realloc</span>(<span class=\"pl-k\">void</span> *, <span class=\"pl-c1\">size_t</span>);\n\n#<span class=\"pl-k\">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG\n    <span class=\"pl-k\">static</span> <span class=\"pl-en\">void</span> (* __malloc_alloc_oom_handler)();\n#<span class=\"pl-k\">endif</span>\n\n<span class=\"pl-k\">public:</span>\n\n<span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> * <span class=\"pl-en\">allocate</span>(<span class=\"pl-c1\">size_t</span> n)\n{\n    <span class=\"pl-k\">void</span> *result = <span class=\"pl-c1\">malloc</span>(n);<span class=\"pl-c\"><span class=\"pl-c\">//</span>第一级分配器直接使用malloc()</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下无法满足需求时，改用oom_malloc()</span>\n    <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">0</span> == result) result = <span class=\"pl-c1\">oom_malloc</span>(n);\n    <span class=\"pl-k\">return</span> result;\n}\n\n<span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">deallocate</span>(<span class=\"pl-k\">void</span> *p, <span class=\"pl-c1\">size_t</span> <span class=\"pl-c\"><span class=\"pl-c\">/*</span> n <span class=\"pl-c\">*/</span></span>)\n{\n    <span class=\"pl-c1\">free</span>(p);<span class=\"pl-c\"><span class=\"pl-c\">//</span>第一级分配器直接使用free()</span>\n}\n\n<span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> * <span class=\"pl-en\">reallocate</span>(<span class=\"pl-k\">void</span> *p, <span class=\"pl-c1\">size_t</span> <span class=\"pl-c\"><span class=\"pl-c\">/*</span> old_sz <span class=\"pl-c\">*/</span></span>, <span class=\"pl-c1\">size_t</span> new_sz)\n{\n    <span class=\"pl-k\">void</span> * result = <span class=\"pl-c1\">realloc</span>(p, new_sz);<span class=\"pl-c\"><span class=\"pl-c\">//</span>第一级分配器直接使用realloc()</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下无法满足需求时，改用oom_realloc()</span>\n    <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">0</span> == result) result = <span class=\"pl-c1\">oom_realloc</span>(p, new_sz);\n    <span class=\"pl-k\">return</span> result;\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>以下仿真C++的set_new_handler()。可以通过它指定自己的</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>out-of-memory handler</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>不能直接运用C++ new-handler机制，因为它并非使用::operator new来分配内存</span>\n<span class=\"pl-k\">static</span> <span class=\"pl-en\">void</span> (* <span class=\"pl-en\">set_malloc_handler</span>(<span class=\"pl-k\">void</span> (*f)()))()\n{\n    <span class=\"pl-c1\">void</span> (* old)() = __malloc_alloc_oom_handler;\n    __malloc_alloc_oom_handler = f;\n    <span class=\"pl-k\">return</span>(old);\n}\n\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> malloc_alloc out-of-memory handling</span>\n\n#<span class=\"pl-k\">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>初值为0，有待客户设定</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">int</span> inst&gt;\n<span class=\"pl-k\">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class=\"pl-c1\">0</span>;\n#<span class=\"pl-k\">endif</span>\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">int</span> inst&gt;\n<span class=\"pl-k\">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_malloc(<span class=\"pl-c1\">size_t</span> n)\n{\n    <span class=\"pl-c1\">void</span> (* my_malloc_handler)();\n    <span class=\"pl-k\">void</span> *result;\n\n    <span class=\"pl-k\">for</span> (;;) {<span class=\"pl-c\"><span class=\"pl-c\">//</span>不断尝试释放、分配、再释放、再分配...</span>\n        my_malloc_handler = __malloc_alloc_oom_handler;\n        <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">0</span> == my_malloc_handler) { __THROW_BAD_ALLOC; }\n        (*my_malloc_handler)(); <span class=\"pl-c\"><span class=\"pl-c\">//</span>调用处理例程，企图释放内存</span>\n        result = <span class=\"pl-c1\">malloc</span>(n);     <span class=\"pl-c\"><span class=\"pl-c\">//</span>再次尝试分配内存</span>\n        <span class=\"pl-k\">if</span> (result) <span class=\"pl-k\">return</span>(result);\n    }\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">int</span> inst&gt;\n<span class=\"pl-k\">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class=\"pl-k\">void</span> *p, <span class=\"pl-c1\">size_t</span> n)\n{\n    <span class=\"pl-c1\">void</span> (* my_malloc_handler)();\n    <span class=\"pl-k\">void</span> *result;\n\n    <span class=\"pl-k\">for</span> (;;) {<span class=\"pl-c\"><span class=\"pl-c\">//</span>不断尝试释放、分配、再释放、再分配...</span>\n        my_malloc_handler = __malloc_alloc_oom_handler;\n        <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">0</span> == my_malloc_handler) { __THROW_BAD_ALLOC; }\n        (*my_malloc_handler)(); <span class=\"pl-c\"><span class=\"pl-c\">//</span>调用处理例程，企图释放内存</span>\n        result = <span class=\"pl-c1\">realloc</span>(p, n); <span class=\"pl-c\"><span class=\"pl-c\">//</span>再次尝试分配内存</span>\n        <span class=\"pl-k\">if</span> (result) <span class=\"pl-k\">return</span>(result);\n    }\n}</pre></div>\n<ul dir=\"auto\">\n<li>以malloc()、free()、realloc()等C函数执行实际的内存分配、释放、重分配操作</li>\n<li>实现出类似C++ new-handler的机制（<strong>C++ new-handler机制是，可以要求系统在内存分配需求无法被满足时，调用一个你所指定的函数。换句话说，一旦::operator new无法完成任务，在丢出std::bad_alloc异常状态之前，会先调用由客户指定的处理例程，该处理例程通常即被称为new-handler</strong>），不能直接运用C++ new-handler机制，因为它并非使用::operator new来分配内存（<a href=\"/arkingc/note/blob/master/C%2B%2B/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.md#3operator-new%E5%92%8Coperator-delete%E7%9A%84%E5%AE%9E%E7%8E%B0\">operator new的实现</a>）</li>\n</ul>\n<h4 tabindex=\"-1\" id=\"user-content-3第二级分配器__default_alloc_template\" dir=\"auto\"><a class=\"heading-link\" href=\"#3第二级分配器__default_alloc_template\">3）第二级分配器__default_alloc_template<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">第二级分配器多了一些机制，避免太多小额区块造成内存的碎片，小额区块存在下列问题：</p>\n<ul dir=\"auto\">\n<li>产生内存碎片</li>\n<li>额外负担。额外负担是一些区块信息，用以管理内存。区块越小，额外负担所占的比例就越大，越显浪费</li>\n</ul>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-5.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-5.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>当区块大于128bytes时，视为大区块\n<ul dir=\"auto\">\n<li>转交第一级分配器处理</li>\n</ul>\n</li>\n<li>当区块小于128bytes时，视为小额区块\n<ul dir=\"auto\">\n<li>以<strong>内存池管理(也称为次层分配)</strong>：每次分配一大块内存，并维护对应的自由链表(free-list)，下次若载有相同大小的内存需求，就直接从free-list中拨出。如果客户释放小额区块，就由分配器回收到free-list中。<strong>维护有16个free-list</strong>，各自管理大小分别为8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128bytes的小额区块</li>\n<li>SGI第二级分配器会主动将任何小额区块的内存需求量上调至8的倍数</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">free-list使用如下结构表示：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//使用union解决free-list带来的额外负担：维护链表所必须的指针而造成内存的另一种浪费\nunion obj{\n    union obj * free_list_link; //系统视角\n    char client_data[1];        //用户视角\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>使用union解决free-list带来的额外负担：维护链表所必须的指针而造成内存的另一种浪费</span>\n<span class=\"pl-k\">union</span> obj{\n    <span class=\"pl-k\">union</span> obj * free_list_link; <span class=\"pl-c\"><span class=\"pl-c\">//</span>系统视角</span>\n    <span class=\"pl-k\">char</span> client_data[<span class=\"pl-c1\">1</span>];        <span class=\"pl-c\"><span class=\"pl-c\">//</span>用户视角</span>\n}</pre></div>\n<p dir=\"auto\">下图是free-list的实现技巧：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-6.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-6.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">第二级分配器__default_alloc_template也定义在头文件<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_alloc.h\">&lt;stl_alloc.h&gt;</a>中，以下为部分实现：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"#ifdef __SUNPRO_CC\n// breaks if we make these template class members:\n  enum {__ALIGN = 8};                           //小型区块的上调边界\n  enum {__MAX_BYTES = 128};                     //小型区块的上限\n  enum {__NFREELISTS = __MAX_BYTES/__ALIGN};    //free-list的个数\n#endif\n\n//第二级分配器的定义\n//无”template型别参数“，第一个参数用于多线程环境，第二参数完全没派上用场\ntemplate &lt;bool threads, int inst&gt;\nclass __default_alloc_template {\n\nprivate:\n    //将bytes上调至8的倍数\n    static size_t ROUND_UP(size_t bytes) {\n        return (((bytes) + __ALIGN-1) &amp; ~(__ALIGN - 1));\n    }\nprivate:\n    //free-list\n    union obj {\n        union obj * free_list_link;\n        char client_data[1];    /* The client sees this.        */\n    };\nprivate:\n    //16个free-list\n    static obj * volatile free_list[__NFREELISTS]; \n    //根据区块大小，决定使用第n号free-list。n从0算起\n    static  size_t FREELIST_INDEX(size_t bytes) {\n        return (((bytes) + __ALIGN-1)/__ALIGN - 1);\n    }\n\n    //返回一个大小为n的对象，并可能加入大小为n的其它区块到free-list\n    static void *refill(size_t n);\n    //分配一大块空间，可容纳nobjs个大小为”size“的区块\n    //如果分配nobjs个区块有所不便，nobjs可能会降低\n    static char *chunk_alloc(size_t size, int &amp;nobjs);\n\n    // Chunk allocation state.\n    static char *start_free;  //内存池起始位置。只在chunk_alloc()中变化\n    static char *end_free;    //内存池结束位置。只在chunk_alloc()中变化\n    static size_t heap_size;\n\npublic:\n    static void * allocate(size_t n){ /*详述于后*/ }\n    static void deallocate(void *p, size_t n){ /*详述于后*/ }\n    static void * reallocate(void *p, size_t old_sz, size_t new_sz);\n};\n\n/*以下是static data member的定义与初始值*/\n\ntemplate &lt;bool threads, int inst&gt;\nchar *__default_alloc_template&lt;threads, inst&gt;::start_free = 0;\n\ntemplate &lt;bool threads, int inst&gt;\nchar *__default_alloc_template&lt;threads, inst&gt;::end_free = 0;\n\ntemplate &lt;bool threads, int inst&gt;\nsize_t __default_alloc_template&lt;threads, inst&gt;::heap_size = 0;\n\ntemplate &lt;bool threads, int inst&gt;\n__default_alloc_template&lt;threads, inst&gt;::obj * volatile\n__default_alloc_template&lt;threads, inst&gt; ::free_list[__NFREELISTS] = \n    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\"><pre>#<span class=\"pl-k\">ifdef</span> __SUNPRO_CC\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> breaks if we make these template class members:</span>\n  <span class=\"pl-k\">enum</span> {__ALIGN = <span class=\"pl-c1\">8</span>};                           <span class=\"pl-c\"><span class=\"pl-c\">//</span>小型区块的上调边界</span>\n  <span class=\"pl-k\">enum</span> {__MAX_BYTES = <span class=\"pl-c1\">128</span>};                     <span class=\"pl-c\"><span class=\"pl-c\">//</span>小型区块的上限</span>\n  <span class=\"pl-k\">enum</span> {__NFREELISTS = __MAX_BYTES/__ALIGN};    <span class=\"pl-c\"><span class=\"pl-c\">//</span>free-list的个数</span>\n#<span class=\"pl-k\">endif</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>第二级分配器的定义</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>无”template型别参数“，第一个参数用于多线程环境，第二参数完全没派上用场</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">bool</span> threads, <span class=\"pl-k\">int</span> inst&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">__default_alloc_template</span> {\n\n<span class=\"pl-k\">private:</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>将bytes上调至8的倍数</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">ROUND_UP</span>(<span class=\"pl-c1\">size_t</span> bytes) {\n        <span class=\"pl-k\">return</span> (((bytes) + __ALIGN-<span class=\"pl-c1\">1</span>) &amp; ~(__ALIGN - <span class=\"pl-c1\">1</span>));\n    }\n<span class=\"pl-k\">private:</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>free-list</span>\n    <span class=\"pl-k\">union</span> obj {\n        <span class=\"pl-k\">union</span> obj * free_list_link;\n        <span class=\"pl-k\">char</span> client_data[<span class=\"pl-c1\">1</span>];    <span class=\"pl-c\"><span class=\"pl-c\">/*</span> The client sees this.        <span class=\"pl-c\">*/</span></span>\n    };\n<span class=\"pl-k\">private:</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>16个free-list</span>\n    <span class=\"pl-k\">static</span> obj * <span class=\"pl-k\">volatile</span> free_list[__NFREELISTS]; \n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>根据区块大小，决定使用第n号free-list。n从0算起</span>\n    <span class=\"pl-k\">static</span>  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">FREELIST_INDEX</span>(<span class=\"pl-c1\">size_t</span> bytes) {\n        <span class=\"pl-k\">return</span> (((bytes) + __ALIGN-<span class=\"pl-c1\">1</span>)/__ALIGN - <span class=\"pl-c1\">1</span>);\n    }\n\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>返回一个大小为n的对象，并可能加入大小为n的其它区块到free-list</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> *<span class=\"pl-en\">refill</span>(<span class=\"pl-c1\">size_t</span> n);\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>分配一大块空间，可容纳nobjs个大小为”size“的区块</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>如果分配nobjs个区块有所不便，nobjs可能会降低</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">char</span> *<span class=\"pl-en\">chunk_alloc</span>(<span class=\"pl-c1\">size_t</span> size, <span class=\"pl-k\">int</span> &amp;nobjs);\n\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Chunk allocation state.</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">char</span> *start_free;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>内存池起始位置。只在chunk_alloc()中变化</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">char</span> *end_free;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>内存池结束位置。只在chunk_alloc()中变化</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-c1\">size_t</span> heap_size;\n\n<span class=\"pl-k\">public:</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> * <span class=\"pl-en\">allocate</span>(<span class=\"pl-c1\">size_t</span> n){ <span class=\"pl-c\"><span class=\"pl-c\">/*</span>详述于后<span class=\"pl-c\">*/</span></span> }\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">deallocate</span>(<span class=\"pl-k\">void</span> *p, <span class=\"pl-c1\">size_t</span> n){ <span class=\"pl-c\"><span class=\"pl-c\">/*</span>详述于后<span class=\"pl-c\">*/</span></span> }\n    <span class=\"pl-k\">static</span> <span class=\"pl-k\">void</span> * <span class=\"pl-en\">reallocate</span>(<span class=\"pl-k\">void</span> *p, <span class=\"pl-c1\">size_t</span> old_sz, <span class=\"pl-c1\">size_t</span> new_sz);\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span>以下是static data member的定义与初始值<span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">bool</span> threads, <span class=\"pl-k\">int</span> inst&gt;\n<span class=\"pl-k\">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class=\"pl-c1\">0</span>;\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">bool</span> threads, <span class=\"pl-k\">int</span> inst&gt;\n<span class=\"pl-k\">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class=\"pl-c1\">0</span>;\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">bool</span> threads, <span class=\"pl-k\">int</span> inst&gt;\n<span class=\"pl-c1\">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class=\"pl-c1\">0</span>;\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">bool</span> threads, <span class=\"pl-k\">int</span> inst&gt;\n__default_alloc_template&lt;threads, inst&gt;::obj * <span class=\"pl-k\">volatile</span>\n__default_alloc_template&lt;threads, inst&gt; ::free_list[__NFREELISTS] = \n    {<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, };</pre></div>\n<ul dir=\"auto\">\n<li>空间分配函数<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_alloc.h#L403\">allocate()</a>\n<ul dir=\"auto\">\n<li>若区块大于128bytes，就调用第一级分配器</li>\n<li>若区块小于128bytes，检查对应的free-list\n<ul dir=\"auto\">\n<li>若free-list之内有可用的区块，则直接使用</li>\n<li>若free-list之内没有可用区块，将区块大小调至8倍数边界，调用refill()，准备为free-list重新填充空间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-7.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-7.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>空间释放函数<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_alloc.h#L433\">deallocate()</a>\n<ul dir=\"auto\">\n<li>若区块大于128bytes，就调用第一级分配器</li>\n<li>若区块小于128bytes，找出对应的free-list，将区块回收</li>\n</ul>\n</li>\n</ul>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-8.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-8.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">重新填充free-list的函数<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_alloc.h#L537\">refill()</a></p>\n<ul dir=\"auto\">\n<li>若free-list中没有可用区块时，会调用chunk_alloc<strong>从内存池</strong>中申请空间重新填充free-list。缺省申请20个新节点(新区块)，如果内存池空间不足，获得的节点数可能小于20</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_alloc.h#L465\">chunk_alloc()</a>函数从内存池申请空间，根据end_free-start_free判断内存池中剩余的空间</p>\n<ul dir=\"auto\">\n<li>如果剩余空间充足\n<ul dir=\"auto\">\n<li>直接调出20个区块返回给free-list</li>\n</ul>\n</li>\n<li>如果剩余空间不足以提供20个区块，但足够供应至少1个区块\n<ul dir=\"auto\">\n<li>拨出这不足20个区块的空间</li>\n</ul>\n</li>\n<li>如果剩余空间连一个区块都无法供应\n<ul dir=\"auto\">\n<li>利用malloc()从heap中分配内存（大小为需求量的2倍，加上一个随着分配次数增加而越来越大的附加量），为内存池注入新的可用空间（<strong>详细例子见下图</strong>）</li>\n<li>如果malloc()获取失败，chunk_alloc()就四处寻找有无”尚有未用且区块足够大“的free-list。找到了就挖出一块交出</li>\n<li>如果上一步仍未成功，那么就调用第一级分配器，第一级分配器有out-of-memory处理机制，或许有机会释放其它的内存拿来此处使用。如果可以，就成功，否则抛出bad_alloc异常</li>\n</ul>\n</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-9.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-9.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">上图中，一开始就调用chunk_alloc(32,20)，于是malloc()分配40个32bytes区块，其中第1个交出，另19个交给free-list[3]维护，余20个留给内存池；接下来客户调用chunk_alloc(64,20)，此时free_list[7]空空如也，必须向内存池申请。内存池只能供应(32*20)/64=10个64bytes区块，就把这10个区块返回，第1个交给客户，余9个由free_list[7]维护。此时内存池全空。接下来再调用chunk_alloc(96,20)，此时free-list[11]空空如也，必须向内存池申请。而内存池此时也为空，于是以malloc()分配40+n(附加量)个96bytes区块，其中第1个交出，另19个交给free-list[11]维护，余20+n(附加量)个区块留给内存池...</p>\n</li>\n</ul>\n<h3 tabindex=\"-1\" id=\"user-content-33-内存基本处理工具\" dir=\"auto\"><a class=\"heading-link\" href=\"#33-内存基本处理工具\">3.3 内存基本处理工具<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">STL定义了5个全局函数，作用于未初始化空间上，有助于容器的实现：</p>\n<ul dir=\"auto\">\n<li>作用于单个对象（见<a href=\"#31-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84\">3.1 对象构造与析构</a>，SGI STL定义在头文件<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_construct.h\">&lt;stl_construct.h&gt;</a>中）\n<ul dir=\"auto\">\n<li>construct()函数（构造单个对象）</li>\n<li>destroy()函数（析构单个对象）</li>\n</ul>\n</li>\n<li>作用于容器的区间（本节，SGI STL定义在头文件<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_uninitialized.h\">&lt;stl_uninitialized.h&gt;</a>中，是高层copy()、fill()、fill_n()的底层函数）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_uninitialized.h#L76\">uninitialized_copy()</a>函数</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_uninitialized.h#L171\">uninitialized_fill()</a>函数</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_uninitialized.h#L218\">uninitialized_fill_n()</a>函数</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">容器的全区间构造函数通常分2步：</p>\n<ol dir=\"auto\">\n<li>分配内存区块，足以包含范围内的所有元素</li>\n<li>调用上述3个函数在全区间范围内构造对象（因此，这3个函数使我们能够将内存的分配与对象的构造行为分离；并且3个函数都具有”commit or rollback“语意，要么所有对象都构造成功，要么一个都没有构造）</li>\n</ol>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-2-10.png\"><img src=\"/arkingc/note/raw/master/pic/stl-2-10.png\" style=\"max-width: 100%;\"></a> </div>\n<br>\n<h1 tabindex=\"-1\" id=\"user-content-三迭代器与traits编程技法\" dir=\"auto\"><a class=\"heading-link\" href=\"#三迭代器与traits编程技法\">三.迭代器与traits编程技法<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h1>\n<h2 tabindex=\"-1\" id=\"user-content-1迭代器相应类型\" dir=\"auto\"><a class=\"heading-link\" href=\"#1迭代器相应类型\">1.迭代器相应类型<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">在算法中运用迭代器时，很可能会用到其相应类型。所谓相应类型，迭代器所指之物的类型便是其中之一，算法可以在函数体中使用迭代器所指之物的类型来定义变量，也可能将迭代器所指之物的类型作为算法的返回值：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-3-1.png\"><img src=\"/arkingc/note/raw/master/pic/stl-3-1.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li><strong>在函数体中使用迭代器所指之物的类型</strong>\n<ul dir=\"auto\">\n<li>C++支持sizeof()，但并未支持typeof()。即便动用RTTI性质中的typeid()，获得的也只是类型名称，不能拿来做变量声明</li>\n<li>这里利用函数模板的参数推导机制解决。算法func()作为对外接口，算法的所有逻辑另外封装在一个实现函数func_impl()中，由于它是一个函数模板，一旦被调用，编译器就会自动进行参数推导，导出类型T</li>\n</ul>\n</li>\n<li><strong>迭代器所指之物的类型作为算法的返回类型</strong>\n<ul dir=\"auto\">\n<li>函数模板的参数推导机制推导的是参数，无法推导函数的返回类型</li>\n<li>这里使用嵌套类型声明解决。但是，对于类类型的迭代器，可以正常工作，但是<strong>非类类型的原生指针无法处理</strong></li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">通过上图，可以了解到在算法中对迭代器相应类型的需求。除了迭代器所指之物的类型(value type)，迭代器相应类型还包括另外4种，在traits编程技法中将会介绍，并且会提到如何使用traits来解决上面的问题（这也是STL中实际使用的方法）</p>\n<h2 tabindex=\"-1\" id=\"user-content-2traits编程技法\" dir=\"auto\"><a class=\"heading-link\" href=\"#2traits编程技法\">2.traits编程技法<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">上一节所使用的方法，在value type作为返回类型时，无法处理非类类型的原生指针。下图使用traits来解决，使用了模板偏特化来处理非类类型的原生指针：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-3-2.png\"><img src=\"/arkingc/note/raw/master/pic/stl-3-2.png\" style=\"max-width: 100%;\"></a> </div>\n<br>\n<p dir=\"auto\">现在，不论面对的是迭代器MyIter，或是原生指针int*或const int*，都可以通过traits取出正确的value type</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-3-3.png\"><img src=\"/arkingc/note/raw/master/pic/stl-3-3.png\" style=\"max-width: 100%;\"></a> </div>\n<blockquote>\n<p dir=\"auto\">当然，若要“特性萃取机”traits能够有效运作，每一个迭代器必须遵循约定，自行以内嵌类型定义的方式定义出相应类型。这是一个约定，谁不遵守这个约定，谁就不能兼容于STL这个大家庭</p>\n</blockquote>\n<p dir=\"auto\"><strong>根据经验，最常用到的迭代器相应类型有5种</strong>：</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>value type</strong>：指迭代器所指对象的类型</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>difference type</strong>：用以表示两个迭代器之间的距离</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>pointer</strong>：如果value type是T，那么pointer就是指向T的指针</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>reference</strong>：如果value type是T，那么reference就是T的引用</p>\n</li>\n<li>\n<p dir=\"auto\"><strong>iterator category</strong>：迭代器的类型（<a href=\"#21-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B\">详见</a>）</p>\n <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-3-4.png\"><img src=\"/arkingc/note/raw/master/pic/stl-3-4.png\" style=\"max-width: 100%;\"></a> </div>\n</li>\n</ol>\n<p dir=\"auto\">如果希望开发的容器能与STL相容，一定要为容器定义这5种相应类型。“特性萃取机”traits会很忠实地将特性萃取出来：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Iterator&gt;\nstruct iterator_traits{\n    typedef typename Iterator::iterator_category   iterator_category;\n    typedef typename Iterator::value_type          value_type;\n    typedef typename Iterator::difference_type     difference_type;\n    typedef typename Iterator::pointer             pointer;\n    typedef typename Iterator::reference           reference;\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Iterator</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">iterator_traits</span>{\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Iterator::iterator_category   iterator_category;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Iterator::value_type          value_type;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Iterator::difference_type     difference_type;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Iterator::pointer             pointer;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Iterator::reference           reference;\n};</pre></div>\n<p dir=\"auto\">iterator_traits必须针对传入的类型为pointer及pointer-to-const者设计偏特化版本：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//以C++内建的ptrdiff_t（定义于&lt;cstddef&gt;头文件）作为原生指针的difference type\n\n//针对原生指针的偏特化版本\ntemplate &lt;class T&gt;\nstruct iterator_traits&lt;T*&gt;{\n    //原生指针是一种Random Access Iterator\n    typedef random_access_iterator_tag   iterator_category;\n    typedef T                            value_type;\n    typedef ptrdiff_t                    difference_type;\n    typedef T*                           pointer;\n    typedef T&amp;                           reference;\n};\n\n//针对原生pointer-to-const的偏特化版本\ntemplate &lt;class T&gt;\nstruct iterator_traits&lt;const T*&gt;{\n    //原生指针是一种Random Access Iterator\n    typedef random_access_iterator_tag   iterator_category;\n    typedef T                            value_type;\n    typedef ptrdiff_t                    difference_type;\n    typedef const T*                     pointer;\n    typedef const T&amp;                     reference;\n};\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>以C++内建的ptrdiff_t（定义于&lt;cstddef&gt;头文件）作为原生指针的difference type</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>针对原生指针的偏特化版本</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">iterator_traits</span>&lt;T*&gt;{\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>原生指针是一种Random Access Iterator</span>\n    <span class=\"pl-k\">typedef</span> random_access_iterator_tag   iterator_category;\n    <span class=\"pl-k\">typedef</span> T                            value_type;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">ptrdiff_t</span>                    difference_type;\n    <span class=\"pl-k\">typedef</span> T*                           pointer;\n    <span class=\"pl-k\">typedef</span> T&amp;                           reference;\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>针对原生pointer-to-const的偏特化版本</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">iterator_traits</span>&lt;<span class=\"pl-k\">const</span> T*&gt;{\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>原生指针是一种Random Access Iterator</span>\n    <span class=\"pl-k\">typedef</span> random_access_iterator_tag   iterator_category;\n    <span class=\"pl-k\">typedef</span> T                            value_type;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">ptrdiff_t</span>                    difference_type;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">const</span> T*                     pointer;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">const</span> T&amp;                     reference;\n};</pre></div>\n<p dir=\"auto\">STL提供以下函数，简化迭代器相应类型的萃取：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//这个函数可以很方便地萃取category\ntemplate &lt;class Iterator&gt;\ninline typename iterator_traits&lt;Iterator&gt;::iterator_category\niterator_category(const Iterator&amp;) {\n  typedef typename iterator_traits&lt;Iterator&gt;::iterator_category category;\n  return category();\n}\n\n//这个函数可以很方便地萃取distance type\ntemplate &lt;class Iterator&gt;\ninline typename iterator_traits&lt;Iterator&gt;::difference_type*\ndistance_type(const Iterator&amp;) {\n  return static_cast&lt;typename iterator_traits&lt;Iterator&gt;::difference_type*&gt;(0);\n}\n\n//这个函数可以很方便地萃取value type\ntemplate &lt;class Iterator&gt;\ninline typename iterator_traits&lt;Iterator&gt;::value_type*\nvalue_type(const Iterator&amp;) {\n  return static_cast&lt;typename iterator_traits&lt;Iterator&gt;::value_type*&gt;(0);\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>这个函数可以很方便地萃取category</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Iterator</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category\n<span class=\"pl-en\">iterator_category</span>(<span class=\"pl-k\">const</span> Iterator&amp;) {\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">category</span>();\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>这个函数可以很方便地萃取distance type</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Iterator</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*\n<span class=\"pl-en\">distance_type</span>(<span class=\"pl-k\">const</span> Iterator&amp;) {\n  <span class=\"pl-k\">return</span> <span class=\"pl-k\">static_cast</span>&lt;<span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class=\"pl-c1\">0</span>);\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>这个函数可以很方便地萃取value type</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Iterator</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::value_type*\n<span class=\"pl-en\">value_type</span>(<span class=\"pl-k\">const</span> Iterator&amp;) {\n  <span class=\"pl-k\">return</span> <span class=\"pl-k\">static_cast</span>&lt;<span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class=\"pl-c1\">0</span>);\n}</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-21-迭代器类型\" dir=\"auto\"><a class=\"heading-link\" href=\"#21-迭代器类型\">2.1 迭代器类型<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">设计算法时，如果可能，尽量针对某种迭代器提供一个明确定义，并针对更强化的某种迭代器提供另一种定义，这样才能在不同情况下提供最大效率，如下图的advanced()函数，用于移动迭代器：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-3-5.png\"><img src=\"/arkingc/note/raw/master/pic/stl-3-5.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">在上图中，每个__advance()的最后一个参数都只声明类型，并未指定参数名称，因为它纯粹只是用来激活重载机制，函数之中根本不使用该参数。如果加上参数名称也没有错，但是没必要</p>\n<p dir=\"auto\">将advance()中的iterator_category(i)展开得到iterator_traits&lt;InputIterator&gt;::iterator_category()，这会产生一个临时对象，其类型隶属于几种迭代器中的一种。然后，根据这个类型，编译器才决定调用哪一个__advance()重载函数</p>\n<p dir=\"auto\"><strong>上图以class来定义迭代器的各种分类标签，有下列好处</strong>：</p>\n<ul dir=\"auto\">\n<li>可以促成重载机制的成功运作</li>\n<li><strong>通过继承，可以不必再写“单纯只做传递调用”的函数（如__advance()的Forward Iterator版只是单纯的调用Input Iterator版，因此可以省略）,可以通过<a href=\"/arkingc/note/blob/master/C%2B%2B/stlbookcode/c3/3tag-test.cpp\">这个例子</a>来模拟证实</strong></li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-3stditerator的保证\" dir=\"auto\"><a class=\"heading-link\" href=\"#3stditerator的保证\">3.std::iterator的保证<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">为了符合规范，任何迭代器都应该提供5个内嵌相应类型，以便于traits萃取，否则便是自别于整个STL架构，可能无法与其它STL组件顺利搭配。然而，写代码难免会有遗漏。因此，STL提供了一个iterators class如下，如果每个新设计的迭代器都继承自它，就可保证符合STL所需的规范；</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Category,\n          class T,\n          class Distance = ptrdiff_t,\n          class Pointer = T*,\n          class Reference = T&amp;&gt;\nstruct iterator{\n    typedef Category    iterator_category;\n    typedef T           value_type;\n    typedef Distance    difference_type;\n    typedef Pointer     pointer;\n    typedef Reference   reference;\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Category</span>,\n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>,\n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">Distance</span> = <span class=\"pl-c1\">ptrdiff_t</span>,\n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">Pointer</span> = T*,\n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">Reference</span> = T&amp;&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">iterator</span>{\n    <span class=\"pl-k\">typedef</span> Category    iterator_category;\n    <span class=\"pl-k\">typedef</span> T           value_type;\n    <span class=\"pl-k\">typedef</span> Distance    difference_type;\n    <span class=\"pl-k\">typedef</span> Pointer     pointer;\n    <span class=\"pl-k\">typedef</span> Reference   reference;\n};</pre></div>\n<p dir=\"auto\">iterator class不含任何成员，存粹只是类型定义，所以继承它不会导致任何额外负担。由于后3个参数皆有默认值，故新的迭代器只需提供前2个参数即可。以下为一个继承示例：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Item&gt;\nstruct ListIter : public std::iterator&lt;std::forword_iterator_tag, Item&gt;{\n    ...\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Item</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">ListIter</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">std</span>::iterator&lt;std::forword_iterator_tag, Item&gt;{\n    ...\n};</pre></div>\n<h2 tabindex=\"-1\" id=\"user-content-4sgi-stl的__type_traits\" dir=\"auto\"><a class=\"heading-link\" href=\"#4sgi-stl的__type_traits\">4.SGI STL的__type_traits<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI将STL的traits进一步扩大到迭代器以外，于是有了所谓的__type_traits，它属于SGI STL，不属于STL标准规范</p>\n<ul dir=\"auto\">\n<li>iterator_traits：负责萃取迭代器的特性</li>\n<li>__type_traits：负责萃取类型的特性，包括：\n<ul dir=\"auto\">\n<li>该类型是否具备non-trivial default ctor</li>\n<li>该类型是否具备non-trivial copy ctor</li>\n<li>该类型是否具备non-trivial assignment operator</li>\n<li>该类型是否具备non-trivial dtor</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">通过使用__type_traits，在对某个类型进行构造、析构、拷贝、赋值等操作时，就可以采用最有效率的措施。这对于大规模而操作频繁的容器，有着显著的效率提升</p>\n<p dir=\"auto\">萃取类型的特性时，我们希望得到一个”真“或”假“（以便决定采取什么策略），但其结果不应该只是个bool值，应该是个有着真/假性质的”对象”，因为我们希望利用响应的结果来进行参数推导，而编译器只有面对class object形式的参数，才会做参数推导，所以萃取类型的特性时，返回__true_type或__false_type：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"struct __true_type { };\nstruct __false_type { };\"><pre><span class=\"pl-k\">struct</span> <span class=\"pl-en\">__true_type</span> { };\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__false_type</span> { };</pre></div>\n<p dir=\"auto\">模板类__type_traits的泛化与特化/偏特化见下图：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-3-6.png\"><img src=\"/arkingc/note/raw/master/pic/stl-3-6.png\" style=\"max-width: 100%;\"></a> </div>\n<br>\n<h1 tabindex=\"-1\" id=\"user-content-四顺序容器\" dir=\"auto\"><a class=\"heading-link\" href=\"#四顺序容器\">四.顺序容器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h1>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-1.jpeg\"><img src=\"/arkingc/note/raw/master/pic/stl-4-1.jpeg\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">上图中的“衍生”并非“派生”，而是内含关系。例如heap内含一个vector，priority-queue内含一个heap，stack和queue都含一个deque，set/map/multiset/multimap都内含一个RB-tree，has_x都内含一个hashtable</p>\n<h2 tabindex=\"-1\" id=\"user-content-1vector\" dir=\"auto\"><a class=\"heading-link\" href=\"#1vector\">1.vector<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">array是静态空间，一旦配置了就不能改变；vector与array非常相似，但是vector是动态空间，随着元素的加入，内部机制会自动扩充以容纳新元素</p>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L12\">vector的定义</a></p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-2.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-2.png\" style=\"max-width: 100%;\"></a> </div>\n<h3 tabindex=\"-1\" id=\"user-content-11-迭代器\" dir=\"auto\"><a class=\"heading-link\" href=\"#11-迭代器\">1.1 迭代器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">vector维护的是一个连续线性空间，所以不论其元素类型为何，普通指针都可以作为vector的迭代器而满足所有必要条件，因为vector迭代器所需要的操作行为，如operator*，operator-&gt;，operator++，operator--，operator+，operator-，operator+=，operator-=，普通指针天生就具备。vector支持随机存取，而普通指针正有着这样的能力。所以，vector提供的是Random Access Iterators：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T,class Alloc = alloc&gt;\nclass vector{\npublic:\n    typedef T               value_type;\n    typedef value_type*     iterator;   //vector的迭代器时普通指针\n...\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>,<span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">vector</span>{\n<span class=\"pl-k\">public:</span>\n    <span class=\"pl-k\">typedef</span> T               value_type;\n    <span class=\"pl-k\">typedef</span> value_type*     iterator;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>vector的迭代器时普通指针</span>\n...\n};</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-12-分配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#12-分配器\">1.2 分配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">vector缺省使用alloc作为空间分配器，并据此另外定义了一个data_allocator，为的是更方便以元素大小为配置单位：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template&lt;class T,class Alloc = alloc&gt;\nclass vector{\nprotected:\n    typedef simple_alloc&lt;value_type,Alloc&gt; data_allocator;\n...\n};\"><pre><span class=\"pl-k\">template</span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>,<span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">vector</span>{\n<span class=\"pl-k\">protected:</span>\n    <span class=\"pl-k\">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;\n...\n};</pre></div>\n<p dir=\"auto\">因此，data_allocator::allocate(n)表示分配n个元素空间</p>\n<h3 tabindex=\"-1\" id=\"user-content-13-vector操作的实现\" dir=\"auto\"><a class=\"heading-link\" href=\"#13-vector操作的实现\">1.3 vector操作的实现<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">常见的vector操作包括：</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L98\">vector(size_type n,const T &amp;value)</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L98\">fill_initialize(size_type n,const T &amp;value)</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L213\">allocate_and_fill(size_type n, const T&amp; x)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L144\">push_back(const T &amp;x)</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L323\">insert_aux(iterator position,const T &amp;x)</a></li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L186\">pop_back()</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L197\">erase(iterator first, iterator last)</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L190\">erase(iterator position)</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_vector.h#L361\">insert(iterator position, size_type n, const T&amp; x)</a></li>\n</ul>\n<p dir=\"auto\"><strong>插入操作可能造成vector的3个指针重新配置，导致原有的迭代器全部失效</strong></p>\n<h2 tabindex=\"-1\" id=\"user-content-2list\" dir=\"auto\"><a class=\"heading-link\" href=\"#2list\">2.list<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L124\">list的定义</a></p>\n<h3 tabindex=\"-1\" id=\"user-content-21-节点\" dir=\"auto\"><a class=\"heading-link\" href=\"#21-节点\">2.1 节点<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-3.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-3.png\" style=\"max-width: 100%;\"></a> </div>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T&gt;\nstruct __list_node{\n    typedef void* void_pointer;\n    void_pointer prev;  //类型为void*\n    void_pointer next;\n    T data;\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__list_node</span>{\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>* void_pointer;\n    void_pointer prev;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>类型为void*</span>\n    void_pointer next;\n    T data;\n};</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-22-迭代器\" dir=\"auto\"><a class=\"heading-link\" href=\"#22-迭代器\">2.2 迭代器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在</p>\n<p dir=\"auto\">list迭代器必须有能力指向list的节点，并有能力进行正确的递增、递减、取值、成员存取等操作。list中，迭代器与节点的关系见下图：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-4.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-4.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">由于STL list是一个双向链表，迭代器必须具备前移、后移的能力，所以list提供的是Bidirectional Iterators</p>\n<p dir=\"auto\"><strong>list的插入和接合操作都不会造成原有的list迭代器失效，对于删除操作，也只有”指向被删除元素“的那个迭代器失效，其它迭代器不受任何影响</strong></p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template&lt;class T, class Ref, class Ptr&gt;\nstruct __list_iterator {\n  typedef __list_iterator&lt;T, T&amp;, T*&gt;             iterator;\n  typedef __list_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n  typedef __list_iterator&lt;T, Ref, Ptr&gt;           self;\n\n  typedef bidirectional_iterator_tag iterator_category;\n  typedef T value_type;\n  typedef Ptr pointer;\n  typedef Ref reference;\n  typedef __list_node&lt;T&gt;* link_type;//节点指针类型link_type\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\n\n  link_type node;//迭代器内部的指针，指向list的节点\n\n  __list_iterator(link_type x) : node(x) {}\n  __list_iterator() {}\n  __list_iterator(const iterator&amp; x) : node(x.node) {}\n\n  bool operator==(const self&amp; x) const { return node == x.node; }\n  bool operator!=(const self&amp; x) const { return node != x.node; }\n  //对迭代器取值，取的是节点的数据值\n  reference operator*() const { return (*node).data; }\n\n#ifndef __SGI_STL_NO_ARROW_OPERATOR\n  //以下是迭代器的成员存取运算子的标准做法\n  pointer operator-&gt;() const { return &amp;(operator*()); }\n#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n\n  //对迭代器累加1，就是前进一个节点\n  self&amp; operator++() { \n    node = (link_type)((*node).next);\n    return *this;\n  }\n  self operator++(int) { \n    self tmp = *this;\n    ++*this;\n    return tmp;\n  }\n\n  //对迭代器递减1，就是后退一个节点\n  self&amp; operator--() { \n    node = (link_type)((*node).prev);\n    return *this;\n  }\n  self operator--(int) { \n    self tmp = *this;\n    --*this;\n    return tmp;\n  }\n};\"><pre><span class=\"pl-k\">template</span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Ref</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Ptr</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__list_iterator</span> {\n  <span class=\"pl-k\">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;\n  <span class=\"pl-k\">typedef</span> __list_iterator&lt;T, <span class=\"pl-k\">const</span> T&amp;, <span class=\"pl-k\">const</span> T*&gt; const_iterator;\n  <span class=\"pl-k\">typedef</span> __list_iterator&lt;T, Ref, <span class=\"pl-c1\">Ptr</span>&gt;           self;\n\n  <span class=\"pl-k\">typedef</span> bidirectional_iterator_tag iterator_category;\n  <span class=\"pl-k\">typedef</span> T value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">Ptr</span> pointer;\n  <span class=\"pl-k\">typedef</span> Ref reference;\n  <span class=\"pl-k\">typedef</span> __list_node&lt;T&gt;* link_type;<span class=\"pl-c\"><span class=\"pl-c\">//</span>节点指针类型link_type</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">size_t</span> size_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">ptrdiff_t</span> difference_type;\n\n  link_type node;<span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器内部的指针，指向list的节点</span>\n\n  <span class=\"pl-en\">__list_iterator</span>(link_type x) : node(x) {}\n  <span class=\"pl-en\">__list_iterator</span>() {}\n  <span class=\"pl-en\">__list_iterator</span>(<span class=\"pl-k\">const</span> iterator&amp; x) : node(x.node) {}\n\n  <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>==(<span class=\"pl-k\">const</span> self&amp; x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> node == x.<span class=\"pl-smi\">node</span>; }\n  <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>!=(<span class=\"pl-k\">const</span> self&amp; x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> node != x.<span class=\"pl-smi\">node</span>; }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>对迭代器取值，取的是节点的数据值</span>\n  reference <span class=\"pl-k\">operator</span>*() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (*node).<span class=\"pl-smi\">data</span>; }\n\n#<span class=\"pl-k\">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下是迭代器的成员存取运算子的标准做法</span>\n  pointer <span class=\"pl-k\">operator</span>-&gt;() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> &amp;(<span class=\"pl-k\">operator</span>*()); }\n#<span class=\"pl-k\">endif</span> <span class=\"pl-c\"><span class=\"pl-c\">/*</span> __SGI_STL_NO_ARROW_OPERATOR <span class=\"pl-c\">*/</span></span>\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>对迭代器累加1，就是前进一个节点</span>\n  self&amp; <span class=\"pl-k\">operator</span>++() { \n    node = (link_type)((*node).<span class=\"pl-smi\">next</span>);\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  self <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>) { \n    self tmp = *<span class=\"pl-c1\">this</span>;\n    ++*<span class=\"pl-c1\">this</span>;\n    <span class=\"pl-k\">return</span> tmp;\n  }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>对迭代器递减1，就是后退一个节点</span>\n  self&amp; <span class=\"pl-k\">operator</span>--() { \n    node = (link_type)((*node).<span class=\"pl-smi\">prev</span>);\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  self <span class=\"pl-k\">operator</span>--(<span class=\"pl-k\">int</span>) { \n    self tmp = *<span class=\"pl-c1\">this</span>;\n    --*<span class=\"pl-c1\">this</span>;\n    <span class=\"pl-k\">return</span> tmp;\n  }\n};</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-23-list的数据结构\" dir=\"auto\"><a class=\"heading-link\" href=\"#23-list的数据结构\">2.3 list的数据结构<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">SGI list不仅是一个双向链表，还是一个环状双向链表。所以它只需要一个指针，便可完整表现整个链表：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T, class Alloc = alloc&gt;\nclass list {\nprotected:\n    typedef __list_node&lt;T&gt; list_node;\npublic:\n    typedef list_node* link_type;\n\nprotected:\n    link_type node; //只要一个指针，便可表示整个环状双向链表\n};\n\niterator begin() { return (link_type)((*node).next); }\niterator end() { return node; }\nsize_type size() const {\n    size_type result = 0;\n    distance(begin(), end(), result);\n    return result;\n}\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">list</span> {\n<span class=\"pl-k\">protected:</span>\n    <span class=\"pl-k\">typedef</span> __list_node&lt;T&gt; list_node;\n<span class=\"pl-k\">public:</span>\n    <span class=\"pl-k\">typedef</span> list_node* link_type;\n\n<span class=\"pl-k\">protected:</span>\n    link_type node; <span class=\"pl-c\"><span class=\"pl-c\">//</span>只要一个指针，便可表示整个环状双向链表</span>\n};\n\niterator <span class=\"pl-en\">begin</span>() { <span class=\"pl-k\">return</span> (link_type)((*node).<span class=\"pl-smi\">next</span>); }\niterator <span class=\"pl-en\">end</span>() { <span class=\"pl-k\">return</span> node; }\nsize_type <span class=\"pl-en\">size</span>() <span class=\"pl-k\">const</span> {\n    size_type result = <span class=\"pl-c1\">0</span>;\n    <span class=\"pl-c1\">distance</span>(<span class=\"pl-c1\">begin</span>(), <span class=\"pl-c1\">end</span>(), result);\n    <span class=\"pl-k\">return</span> result;\n}</pre></div>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-5.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-5.png\" style=\"max-width: 100%;\"></a> </div>\n<h3 tabindex=\"-1\" id=\"user-content-24-分配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#24-分配器\">2.4 分配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">list缺省使用alloc作为空间分配器，并据此另外定义了一个list_node_allocator，为的是更方便以节点大小为配置单位：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T, class Alloc = alloc&gt;\nclass list {\nprotected:\n    typedef simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;\n...\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">list</span> {\n<span class=\"pl-k\">protected:</span>\n    <span class=\"pl-k\">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;\n...\n};</pre></div>\n<p dir=\"auto\">因此，list_node_allocator::allocate(n)表示分配n个节点空间</p>\n<h3 tabindex=\"-1\" id=\"user-content-25-list操作的实现\" dir=\"auto\"><a class=\"heading-link\" href=\"#25-list操作的实现\">2.5 list操作的实现<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">节点操作</p>\n<ul dir=\"auto\">\n<li>分配一个节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L156\">get_node</a></li>\n<li>释放一个节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L157\">put_node</a></li>\n<li>生成（分配并构造）一个节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L159\">create_node</a></li>\n<li>销毁（析构并释放）一个节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L167\">destroy_node</a></li>\n<li>节点插入：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L269\">push_back</a>和<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L268\">push_front</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L243\">insert</a></li>\n</ul>\n</li>\n<li>节点移除：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L270\">erase</a>,<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L283\">pop_front</a>和<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L284\">pop_back</a></li>\n<li>移除某一数值的所有节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L468\">remove</a></li>\n<li>移除数值相同的连续节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L480\">unique</a></li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">链表操作</p>\n<ul dir=\"auto\">\n<li>创建一个空链表：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L217\">list()</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L173\">empty_initialize</a></li>\n</ul>\n</li>\n<li>链表清空：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L438\">clear</a></li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">链表拼接：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L328\">splice</a></p>\n<ul dir=\"auto\">\n<li>将[first,last)内的元素移动到position之前：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_list.h#L315\">transfer</a>（[first,last)区间可以在同一个list之中，transfer并非公开接口，公开的是splice）</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-6.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-6.png\" style=\"max-width: 100%;\"></a> </div>\n</li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-3deque\" dir=\"auto\"><a class=\"heading-link\" href=\"#3deque\">3.deque<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">deque是一种双向开口的连续线性空间</p>\n<p dir=\"auto\">deque和vector最大的差异：</p>\n<ol dir=\"auto\">\n<li>deque允许于常数时间内对起头端进行元素的插入或移除操作</li>\n<li>deque没有所谓容量观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来（deque没有必要提供所谓的空间保留功能）</li>\n</ol>\n<h3 tabindex=\"-1\" id=\"user-content-31-迭代器\" dir=\"auto\"><a class=\"heading-link\" href=\"#31-迭代器\">3.1 迭代器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">deque是分段连续空间。维持其”整体连续“假象的任务，落在了迭代器的operator++和operator--两个运算子身上</p>\n<p dir=\"auto\">deque迭代器必须能够指出分段连续空间（即缓冲区）在哪；必须能够判断自己是否已经处于其所在缓冲器的边缘。为了能够正确跳跃，迭代器必须随时掌握中控器map</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T, class Ref, class Ptr, size_t BufSiz&gt;\nstruct __deque_iterator {   //未继承std::iterator\n  typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;             iterator;\n  typedef __deque_iterator&lt;T, const T&amp;, const T*, BufSiz&gt; const_iterator;\n  static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }\n\n  //为继承std::iterator，所以必须自行撰写5个必要的迭代器相应类型\n  typedef random_access_iterator_tag iterator_category; // (1)\n  typedef T value_type;                                 // (2)\n  typedef Ptr pointer;                                  // (3)\n  typedef Ref reference;                                // (4)\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;                    // (5)\n  typedef T** map_pointer;\n\n  typedef __deque_iterator self;\n\n  //保持与容器的联结\n  T* cur;           //此迭代器所指缓冲区中的当前元素\n  T* first;         //此迭代器所指缓冲区的头\n  T* last;          //此迭代器所指缓冲区的尾(含备用空间)\n  map_pointer node; //指向中控器map\n...\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Ref</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Ptr</span>, <span class=\"pl-c1\">size_t</span> BufSiz&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__deque_iterator</span> {   <span class=\"pl-c\"><span class=\"pl-c\">//</span>未继承std::iterator</span>\n  <span class=\"pl-k\">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;             iterator;\n  <span class=\"pl-k\">typedef</span> __deque_iterator&lt;T, <span class=\"pl-k\">const</span> T&amp;, <span class=\"pl-k\">const</span> T*, BufSiz&gt; const_iterator;\n  <span class=\"pl-k\">static</span> <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">buffer_size</span>() {<span class=\"pl-k\">return</span> <span class=\"pl-c1\">__deque_buf_size</span>(BufSiz, <span class=\"pl-k\">sizeof</span>(T)); }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>为继承std::iterator，所以必须自行撰写5个必要的迭代器相应类型</span>\n  <span class=\"pl-k\">typedef</span> random_access_iterator_tag iterator_category; <span class=\"pl-c\"><span class=\"pl-c\">//</span> (1)</span>\n  <span class=\"pl-k\">typedef</span> T value_type;                                 <span class=\"pl-c\"><span class=\"pl-c\">//</span> (2)</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">Ptr</span> pointer;                                  <span class=\"pl-c\"><span class=\"pl-c\">//</span> (3)</span>\n  <span class=\"pl-k\">typedef</span> Ref reference;                                <span class=\"pl-c\"><span class=\"pl-c\">//</span> (4)</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">size_t</span> size_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">ptrdiff_t</span> difference_type;                    <span class=\"pl-c\"><span class=\"pl-c\">//</span> (5)</span>\n  <span class=\"pl-k\">typedef</span> T** map_pointer;\n\n  <span class=\"pl-k\">typedef</span> __deque_iterator self;\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>保持与容器的联结</span>\n  T* cur;           <span class=\"pl-c\"><span class=\"pl-c\">//</span>此迭代器所指缓冲区中的当前元素</span>\n  T* first;         <span class=\"pl-c\"><span class=\"pl-c\">//</span>此迭代器所指缓冲区的头</span>\n  T* last;          <span class=\"pl-c\"><span class=\"pl-c\">//</span>此迭代器所指缓冲区的尾(含备用空间)</span>\n  map_pointer node; <span class=\"pl-c\"><span class=\"pl-c\">//</span>指向中控器map</span>\n...\n};</pre></div>\n<p dir=\"auto\">迭代器操作：</p>\n<ul dir=\"auto\">\n<li>更新迭代器指向的缓冲区：set_node</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L130\">解引用*</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L132\">成员选择-&gt;</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/135\">迭代器相减-</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L140\">前置++</a>和<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L148\">后置++</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L154\">前置--</a>和<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L162\">后置--</a></li>\n<li>复合赋值<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L168\">+=</a>和<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L187\">-=</a></li>\n<li>迭代器<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L182\">+n</a>和<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L189\">-n</a></li>\n<li>随机存取<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L194\">[]</a></li>\n<li>相等判断<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L196\">==</a>，<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L197\">!=</a>和<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L198\">&lt;</a></li>\n</ul>\n<h3 tabindex=\"-1\" id=\"user-content-33-deque的数据结构\" dir=\"auto\"><a class=\"heading-link\" href=\"#33-deque的数据结构\">3.3 deque的数据结构<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">deque采用一块所谓的map作为<strong>主控(中控器)</strong>。这里所谓的map是指一小块连续空间，其中每个元素都是一个指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。SGI STL允许我们指定缓冲区大小，默认值0表示使用512bytes缓冲区</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-7.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-7.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">deque除了维护一个指向map的指针外，也维护start，finish两个迭代器。分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。此外，也必须记住目前的map大小。因为一旦map所提供的节点不足，就必须重新配置更大的一块map</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"temlate &lt;class T,class Alloc = alloc,size_t BufSiz = 0&gt;\nclass deque{\npublic:     //Basic types\n    typedef T value_type;\n    typedef value_type* pointer;\n    typedef size_t size_type;\n    ...\n\npublic:\n    typedef __deque_iterator&lt;T,T&amp;.T*,BufSiz&gt; iterator;  //迭代器类型\n\nprotected:  //Internal typedefs\n    //元素的指针的指针\n    typedef pointer* map_pointer;\n\nprotected:  //Data members\n    iterator start;         //第一个节点的迭代器\n    iterator finish;        //最后一个节点的迭代器\n\n    map_pointer map;        //指向map，map是块连续空间\n                            //其每个元素都是个指针，指向一个节点(缓冲区)\n    size_type map_size;     //map的大小，即内有多少个指针\n...\n};\"><pre>temlate &lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>,<span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc,<span class=\"pl-c1\">size_t</span> BufSiz = <span class=\"pl-c1\">0</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">deque</span>{\n<span class=\"pl-k\">public:</span>     <span class=\"pl-c\"><span class=\"pl-c\">//</span>Basic types</span>\n    <span class=\"pl-k\">typedef</span> T value_type;\n    <span class=\"pl-k\">typedef</span> value_type* pointer;\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">size_t</span> size_type;\n    ...\n\n<span class=\"pl-k\">public:</span>\n    <span class=\"pl-k\">typedef</span> __deque_iterator&lt;T,T&amp;.T*,BufSiz&gt; iterator;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器类型</span>\n\n<span class=\"pl-k\">protected:</span>  <span class=\"pl-c\"><span class=\"pl-c\">//</span>Internal typedefs</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>元素的指针的指针</span>\n    <span class=\"pl-k\">typedef</span> pointer* map_pointer;\n\n<span class=\"pl-k\">protected:</span>  <span class=\"pl-c\"><span class=\"pl-c\">//</span>Data members</span>\n    iterator start;         <span class=\"pl-c\"><span class=\"pl-c\">//</span>第一个节点的迭代器</span>\n    iterator finish;        <span class=\"pl-c\"><span class=\"pl-c\">//</span>最后一个节点的迭代器</span>\n\n    map_pointer map;        <span class=\"pl-c\"><span class=\"pl-c\">//</span>指向map，map是块连续空间</span>\n                            <span class=\"pl-c\"><span class=\"pl-c\">//</span>其每个元素都是个指针，指向一个节点(缓冲区)</span>\n    size_type map_size;     <span class=\"pl-c\"><span class=\"pl-c\">//</span>map的大小，即内有多少个指针</span>\n...\n};</pre></div>\n<p dir=\"auto\">deque的中控器、缓冲区、迭代器的关系如下图：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-8.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-8.png\" style=\"max-width: 100%;\"></a> </div>\n<h3 tabindex=\"-1\" id=\"user-content-34-分配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#34-分配器\">3.4 分配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">deque自行定义了2个专属的空间配置器：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"protected:\n    //专属的空间分配器，每次分配一个元素大小\n    typedef simple_alloc&lt;value_type,Alloc&gt; data_allocator;\n    //专属的空间分配器，每次分配一个指针大小\n    typedef simple_alloc&lt;pointer,Alloc&gt; map_allocator;\"><pre><span class=\"pl-k\">protected:</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>专属的空间分配器，每次分配一个元素大小</span>\n    <span class=\"pl-k\">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>专属的空间分配器，每次分配一个指针大小</span>\n    <span class=\"pl-k\">typedef</span> simple_alloc&lt;pointer,Alloc&gt; map_allocator;</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-35-deque操作的实现\" dir=\"auto\"><a class=\"heading-link\" href=\"#35-deque操作的实现\">3.5 deque操作的实现<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<ul dir=\"auto\">\n<li>deque构造与初始化：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L360\">deque</a>\n<ul dir=\"auto\">\n<li>元素初始化<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L847\">fill_initialize</a>\n<ul dir=\"auto\">\n<li>空间分配与成员设定<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L797\">create_map_and_nodes</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>插入操作：\n<ul dir=\"auto\">\n<li>在队列末尾插入：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L439\">push_back</a>\n<ul dir=\"auto\">\n<li>最后缓冲区只有1个可用空间时：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L898\">push_back_aux</a>\n<ul dir=\"auto\">\n<li>map不足时：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L632\">reserve_map_at_back</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L1289\">reallocate_map</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>在队列首部插入：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L448\">push_front</a>\n<ul dir=\"auto\">\n<li>第一个缓冲区没有可用空间时：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L912\">push_front_aux</a>\n<ul dir=\"auto\">\n<li>map不足时：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L639\">reserve_map_at_front</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L1289\">reallocate_map</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指定位置插入一个元素：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L447\">insert</a>\n<ul dir=\"auto\">\n<li>在首部插入：push_front</li>\n<li>在尾部插入：push_back</li>\n<li>在中间插入：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L994\">insert_aux</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>弹出操作：\n<ul dir=\"auto\">\n<li>弹出队列末尾元素：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L457\">pop_back</a>\n<ul dir=\"auto\">\n<li>最后缓冲区没有元素时：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L933\">pop_back_aux</a></li>\n</ul>\n</li>\n<li>弹出队列首部元素：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L466\">pop_front</a>\n<ul dir=\"auto\">\n<li>第一个缓冲区仅有一个元素时：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L945\">pop_front_aux</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>清除所有元素：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L774\">clear</a></li>\n<li>清除某个区间的元素：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_deque.h#L743\">erase</a></li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-4stack\" dir=\"auto\"><a class=\"heading-link\" href=\"#4stack\">4.stack<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">具有”修改某物接口，形成另一种风貌“的性质者，称为适配器。因此，STL stack往往不被归类为容器，而被归类为容器适配器</p>\n<p dir=\"auto\">SGI STL以deque作为缺省情况下的stack底部结构，定义如下：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T, class Sequence = deque&lt;T&gt; &gt;\nclass stack {\n  //以下__STL_NULL_TMPL_ARGS会展开为 &lt;&gt;\n  friend bool operator== __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);\n  friend bool operator&lt; __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);\npublic:\n  typedef typename Sequence::value_type value_type;\n  typedef typename Sequence::size_type size_type;\n  typedef typename Sequence::reference reference;\n  typedef typename Sequence::const_reference const_reference;\nprotected:\n  Sequence c;   //底层容器\npublic:\n  //以下完全利用Sequence c的操作，完成stack的操作\n  bool empty() const { return c.empty(); }\n  size_type size() const { return c.size(); }\n  reference top() { return c.back(); }\n  const_reference top() const { return c.back(); }\n  //deque是两头可进出，stack是后进后出\n  void push(const value_type&amp; x) { c.push_back(x); }\n  void pop() { c.pop_back(); }\n};\n\ntemplate &lt;class T, class Sequence&gt;\nbool operator==(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y) {\n  return x.c == y.c;\n}\n\ntemplate &lt;class T, class Sequence&gt;\nbool operator&lt;(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y) {\n  return x.c &lt; y.c;\n}\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Sequence</span> = deque&lt;T&gt; &gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">stack</span> {\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下__STL_NULL_TMPL_ARGS会展开为 &lt;&gt;</span>\n  <span class=\"pl-k\">friend</span> <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>== __STL_NULL_TMPL_ARGS (<span class=\"pl-k\">const</span> stack&amp;, <span class=\"pl-k\">const</span> stack&amp;);\n  <span class=\"pl-k\">friend</span> <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class=\"pl-k\">const</span> stack&amp;, <span class=\"pl-k\">const</span> stack&amp;);\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::value_type value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::size_type size_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::reference reference;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::const_reference const_reference;\n<span class=\"pl-k\">protected:</span>\n  Sequence c;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>底层容器</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下完全利用Sequence c的操作，完成stack的操作</span>\n  <span class=\"pl-k\">bool</span> <span class=\"pl-en\">empty</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">empty</span>(); }\n  size_type <span class=\"pl-en\">size</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">size</span>(); }\n  reference <span class=\"pl-en\">top</span>() { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">back</span>(); }\n  const_reference <span class=\"pl-en\">top</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">back</span>(); }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>deque是两头可进出，stack是后进后出</span>\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">push</span>(<span class=\"pl-k\">const</span> value_type&amp; x) { c.<span class=\"pl-c1\">push_back</span>(x); }\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">pop</span>() { c.<span class=\"pl-c1\">pop_back</span>(); }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Sequence</span>&gt;\n<span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>==(<span class=\"pl-k\">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class=\"pl-k\">const</span> stack&lt;T, Sequence&gt;&amp; y) {\n  <span class=\"pl-k\">return</span> x.<span class=\"pl-smi\">c</span> == y.<span class=\"pl-smi\">c</span>;\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Sequence</span>&gt;\n<span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>&lt;(<span class=\"pl-k\">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class=\"pl-k\">const</span> stack&lt;T, Sequence&gt;&amp; y) {\n  <span class=\"pl-k\">return</span> x.<span class=\"pl-smi\">c</span> &lt; y.<span class=\"pl-smi\">c</span>;\n}</pre></div>\n<p dir=\"auto\">只有stack顶端的元素有机会被外界取用，stack不提供遍历功能，也<strong>不提供迭代器</strong></p>\n<p dir=\"auto\"><strong>指定其它容器作为stack的底层容器的方法：</strong></p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"stack&lt;int,list&lt;int&gt; &gt; istack;\"><pre>stack&lt;<span class=\"pl-k\">int</span>,list&lt;<span class=\"pl-k\">int</span>&gt; &gt; istack;</pre></div>\n<h2 tabindex=\"-1\" id=\"user-content-5queue\" dir=\"auto\"><a class=\"heading-link\" href=\"#5queue\">5.queue<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">queue（队列）是一种先进先出的数据结构，尾端插入，首部移出</p>\n<p dir=\"auto\">SGI STL以deque作为缺省情况下的queue底部结构，定义如下：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T, class Sequence = deque&lt;T&gt; &gt;\nclass queue {\n  //以下__STL_NULL_TMPL_ARGS会展开为 &lt;&gt;\n  friend bool operator== __STL_NULL_TMPL_ARGS (const queue&amp; x, const queue&amp; y);\n  friend bool operator&lt; __STL_NULL_TMPL_ARGS (const queue&amp; x, const queue&amp; y);\npublic:\n  typedef typename Sequence::value_type value_type;\n  typedef typename Sequence::size_type size_type;\n  typedef typename Sequence::reference reference;\n  typedef typename Sequence::const_reference const_reference;\nprotected:\n  Sequence c;   //底层容器\npublic:\n  //以下完全利用Sequence c的操作，完成stack的操作\n  bool empty() const { return c.empty(); }\n  size_type size() const { return c.size(); }\n  reference front() { return c.front(); }\n  const_reference front() const { return c.front(); }\n  reference back() { return c.back(); }\n  const_reference back() const { return c.back(); }\n  //deque是两头可进出，queue是尾端进、首部出\n  void push(const value_type&amp; x) { c.push_back(x); }\n  void pop() { c.pop_front(); }\n};\n\ntemplate &lt;class T, class Sequence&gt;\nbool operator==(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T, Sequence&gt;&amp; y) {\n  return x.c == y.c;\n}\n\ntemplate &lt;class T, class Sequence&gt;\nbool operator&lt;(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T, Sequence&gt;&amp; y) {\n  return x.c &lt; y.c;\n}\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Sequence</span> = deque&lt;T&gt; &gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">queue</span> {\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下__STL_NULL_TMPL_ARGS会展开为 &lt;&gt;</span>\n  <span class=\"pl-k\">friend</span> <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>== __STL_NULL_TMPL_ARGS (<span class=\"pl-k\">const</span> queue&amp; x, <span class=\"pl-k\">const</span> queue&amp; y);\n  <span class=\"pl-k\">friend</span> <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class=\"pl-k\">const</span> queue&amp; x, <span class=\"pl-k\">const</span> queue&amp; y);\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::value_type value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::size_type size_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::reference reference;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::const_reference const_reference;\n<span class=\"pl-k\">protected:</span>\n  Sequence c;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>底层容器</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下完全利用Sequence c的操作，完成stack的操作</span>\n  <span class=\"pl-k\">bool</span> <span class=\"pl-en\">empty</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">empty</span>(); }\n  size_type <span class=\"pl-en\">size</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">size</span>(); }\n  reference <span class=\"pl-en\">front</span>() { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">front</span>(); }\n  const_reference <span class=\"pl-en\">front</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">front</span>(); }\n  reference <span class=\"pl-en\">back</span>() { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">back</span>(); }\n  const_reference <span class=\"pl-en\">back</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">back</span>(); }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>deque是两头可进出，queue是尾端进、首部出</span>\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">push</span>(<span class=\"pl-k\">const</span> value_type&amp; x) { c.<span class=\"pl-c1\">push_back</span>(x); }\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">pop</span>() { c.<span class=\"pl-c1\">pop_front</span>(); }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Sequence</span>&gt;\n<span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>==(<span class=\"pl-k\">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class=\"pl-k\">const</span> queue&lt;T, Sequence&gt;&amp; y) {\n  <span class=\"pl-k\">return</span> x.<span class=\"pl-smi\">c</span> == y.<span class=\"pl-smi\">c</span>;\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Sequence</span>&gt;\n<span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>&lt;(<span class=\"pl-k\">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class=\"pl-k\">const</span> queue&lt;T, Sequence&gt;&amp; y) {\n  <span class=\"pl-k\">return</span> x.<span class=\"pl-smi\">c</span> &lt; y.<span class=\"pl-smi\">c</span>;\n}</pre></div>\n<p dir=\"auto\">只有首部元素才有机会被外界取用，queue不提供遍历功能，也<strong>不提供迭代器</strong></p>\n<p dir=\"auto\"><strong>指定其它容器作为queue的底层容器的方法：</strong></p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"queue&lt;int,list&lt;int&gt; &gt; iqueue;\"><pre>queue&lt;<span class=\"pl-k\">int</span>,list&lt;<span class=\"pl-k\">int</span>&gt; &gt; iqueue;</pre></div>\n<h2 tabindex=\"-1\" id=\"user-content-6heap\" dir=\"auto\"><a class=\"heading-link\" href=\"#6heap\">6.heap<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">heap并不归属与STL容器组件，它是个幕后英雄，扮演priority queue的助手</p>\n<p dir=\"auto\">heap是一颗完全二叉树，完全二叉树使用数组实现，因此使用一个vector作为heap的结构，然后通过一组xxx_heap算法，使其符合heap的性质</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">上溯（在此之前应该push_back）：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L60\">push_heap</a></p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L53\">__push_heap_aux</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L40\">__push_heap</a></li>\n</ul>\n</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-13.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-13.png\" style=\"max-width: 100%;\"></a> </div>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L124\">pop_heap</a>（在此之后应该pop_back）</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L118\">__pop_heap_aux</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L110\">__pop_heap</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L91\">__adjust_heap</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-12.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-12.png\" style=\"max-width: 100%;\"></a> </div>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L209\">sort_heap</a></p>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-11.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-11.png\" style=\"max-width: 100%;\"></a> </div>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L184\">make_heap</a></p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_heap.h#L189\">__make_heap</a></li>\n</ul>\n</li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-7priority_queue\" dir=\"auto\"><a class=\"heading-link\" href=\"#7priority_queue\">7.priority_queue<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">顾名思义，priority_queue就是具有优先级的queue，允许首部移出，尾端插入。缺省情况下利用一个max-heap完成，因此首部元素优先级最高</p>\n<p dir=\"auto\">以下为SGI STL中priority_queue的定义：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T, class Sequence = vector&lt;T&gt;, \n          class Compare = less&lt;typename Sequence::value_type&gt; &gt;\nclass  priority_queue {\npublic:\n  typedef typename Sequence::value_type value_type;\n  typedef typename Sequence::size_type size_type;\n  typedef typename Sequence::reference reference;\n  typedef typename Sequence::const_reference const_reference;\nprotected:\n  Sequence c;       //底层容器\n  Compare comp;     //元素大小比较标准\npublic:\n  priority_queue() : c() {}\n  explicit priority_queue(const Compare&amp; x) :  c(), comp(x) {}\n\n  //以下用到的make_heap()、push_heap()、pop_heap()都是泛型算法\n  //构造一个priority queue，首先根据传入的迭代器区间初始化底层容器c，然后调用\n  //make_heap()使用底层容器建堆\n  template &lt;class InputIterator&gt;\n  priority_queue(InputIterator first, InputIterator last, const Compare&amp; x)\n    : c(first, last), comp(x) { make_heap(c.begin(), c.end(), comp); }\n  template &lt;class InputIterator&gt;\n  priority_queue(InputIterator first, InputIterator last) \n    : c(first, last) { make_heap(c.begin(), c.end(), comp); }\n\n  bool empty() const { return c.empty(); }\n  size_type size() const { return c.size(); }\n  const_reference top() const { return c.front(); }\n  void push(const value_type&amp; x) {\n    //先利用底层容器的push_back()将新元素推入末端，再重排heap\n    __STL_TRY {\n      c.push_back(x); \n      push_heap(c.begin(), c.end(), comp);\n    }\n    __STL_UNWIND(c.clear());\n  }\n  void pop() {\n    //从heap内取出一个元素。但不是真正弹出，而是重排heap，然后以底层容器的pop_back()\n    //取得被弹出的元素\n    __STL_TRY {\n      pop_heap(c.begin(), c.end(), comp);\n      c.pop_back();\n    }\n    __STL_UNWIND(c.clear());\n  }\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Sequence</span> = vector&lt;T&gt;, \n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">Compare</span> = less&lt;<span class=\"pl-k\">typename</span> Sequence::value_type&gt; &gt;\n<span class=\"pl-k\">class</span>  <span class=\"pl-en\">priority_queue</span> {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::value_type value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::size_type size_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::reference reference;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Sequence::const_reference const_reference;\n<span class=\"pl-k\">protected:</span>\n  Sequence c;       <span class=\"pl-c\"><span class=\"pl-c\">//</span>底层容器</span>\n  Compare comp;     <span class=\"pl-c\"><span class=\"pl-c\">//</span>元素大小比较标准</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-en\">priority_queue</span>() : c() {}\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">priority_queue</span>(<span class=\"pl-k\">const</span> Compare&amp; x) :  c(), comp(x) {}\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下用到的make_heap()、push_heap()、pop_heap()都是泛型算法</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造一个priority queue，首先根据传入的迭代器区间初始化底层容器c，然后调用</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>make_heap()使用底层容器建堆</span>\n  <span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">InputIterator</span>&gt;\n  <span class=\"pl-en\">priority_queue</span>(InputIterator first, InputIterator last, <span class=\"pl-k\">const</span> Compare&amp; x)\n    : c(first, last), comp(x) { <span class=\"pl-c1\">make_heap</span>(c.<span class=\"pl-c1\">begin</span>(), c.<span class=\"pl-c1\">end</span>(), comp); }\n  <span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">InputIterator</span>&gt;\n  <span class=\"pl-en\">priority_queue</span>(InputIterator first, InputIterator last) \n    : c(first, last) { <span class=\"pl-c1\">make_heap</span>(c.<span class=\"pl-c1\">begin</span>(), c.<span class=\"pl-c1\">end</span>(), comp); }\n\n  <span class=\"pl-k\">bool</span> <span class=\"pl-en\">empty</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">empty</span>(); }\n  size_type <span class=\"pl-en\">size</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">size</span>(); }\n  const_reference <span class=\"pl-en\">top</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> c.<span class=\"pl-c1\">front</span>(); }\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">push</span>(<span class=\"pl-k\">const</span> value_type&amp; x) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>先利用底层容器的push_back()将新元素推入末端，再重排heap</span>\n    __STL_TRY {\n      c.<span class=\"pl-c1\">push_back</span>(x); \n      <span class=\"pl-c1\">push_heap</span>(c.<span class=\"pl-c1\">begin</span>(), c.<span class=\"pl-c1\">end</span>(), comp);\n    }\n    <span class=\"pl-c1\">__STL_UNWIND</span>(c.<span class=\"pl-c1\">clear</span>());\n  }\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">pop</span>() {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>从heap内取出一个元素。但不是真正弹出，而是重排heap，然后以底层容器的pop_back()</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>取得被弹出的元素</span>\n    __STL_TRY {\n      <span class=\"pl-c1\">pop_heap</span>(c.<span class=\"pl-c1\">begin</span>(), c.<span class=\"pl-c1\">end</span>(), comp);\n      c.<span class=\"pl-c1\">pop_back</span>();\n    }\n    <span class=\"pl-c1\">__STL_UNWIND</span>(c.<span class=\"pl-c1\">clear</span>());\n  }\n};</pre></div>\n<p dir=\"auto\">和queue一样，priority queue只有首部的元素有机会被外界取用。不提供遍历功能，也<strong>不提供迭代器</strong></p>\n<h2 tabindex=\"-1\" id=\"user-content-8slist\" dir=\"auto\"><a class=\"heading-link\" href=\"#8slist\">8.slist<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">slist<strong>并不在标准规格之内</strong>，由SGI STL提供，slist和list不同的是slist是单链表</p>\n<p dir=\"auto\">单链表每个节点的消耗更小，但是只支持单向遍历，所以功能会受到许多限制</p>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_slist.h#L175\">slist的定义</a></p>\n<h3 tabindex=\"-1\" id=\"user-content-81-slist的节点\" dir=\"auto\"><a class=\"heading-link\" href=\"#81-slist的节点\">8.1 slist的节点<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-9.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-9.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">节点相关的结构：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//单向链表的节点基本结构\nstruct __slist_node_base\n{\n    __slist_node_base *next;\n};\n\n//单向链表的节点结构\ntemplate &lt;class T&gt;\nstruct __slist_node : public __slist_node_base\n{\n    T data;\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>单向链表的节点基本结构</span>\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__slist_node_base</span>\n{\n    __slist_node_base *next;\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>单向链表的节点结构</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__slist_node</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">__slist_node_base</span>\n{\n    T data;\n}<span class=\"pl-ii\"></span></pre></div>\n<p dir=\"auto\">节点相关的全局函数：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//已知某一节点prev_node，将新节点new_node插入其后\ninline __slist_node_base* __slist_make_link(\n    __slist_node_base *prev_node,\n    __slist_node_base *new_node)\n{\n    //令new节点的下一节点为prev节点的下一节点\n    new_node-&gt;next = prev_node-&gt;next;\n    prev_node-&gt;next = new_node; //令prev节点的下一节点指向new节点\n    return new_node;\n}\n\n//单向链表的大小（元素个数）\ninline size_t __slist_size(__slist_node_base *node)\n{\n    size_t result = 0;\n    for(;node != 0;node = node-&gt;next)\n        ++result;   //一个个累计\n    return result;\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>已知某一节点prev_node，将新节点new_node插入其后</span>\n<span class=\"pl-k\">inline</span> __slist_node_base* <span class=\"pl-en\">__slist_make_link</span>(\n    __slist_node_base *prev_node,\n    __slist_node_base *new_node)\n{\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>令new节点的下一节点为prev节点的下一节点</span>\n    new_node-&gt;<span class=\"pl-smi\">next</span> = prev_node-&gt;<span class=\"pl-smi\">next</span>;\n    prev_node-&gt;<span class=\"pl-smi\">next</span> = new_node; <span class=\"pl-c\"><span class=\"pl-c\">//</span>令prev节点的下一节点指向new节点</span>\n    <span class=\"pl-k\">return</span> new_node;\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>单向链表的大小（元素个数）</span>\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">__slist_size</span>(__slist_node_base *node)\n{\n    <span class=\"pl-c1\">size_t</span> result = <span class=\"pl-c1\">0</span>;\n    <span class=\"pl-k\">for</span>(;node != <span class=\"pl-c1\">0</span>;node = node-&gt;<span class=\"pl-smi\">next</span>)\n        ++result;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>一个个累计</span>\n    <span class=\"pl-k\">return</span> result;\n}</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-82-slist的迭代器\" dir=\"auto\"><a class=\"heading-link\" href=\"#82-slist的迭代器\">8.2 slist的迭代器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-10.png\"><img src=\"/arkingc/note/raw/master/pic/stl-4-10.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">迭代器的定义如下：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//单向链表的迭代器基本结构\nstruct __slist_iterator_base\n{\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\n  typedef forward_iterator_tag iterator_category;   //单向\n\n  __slist_node_base* node;  //指向节点基本结构\n\n  __slist_iterator_base(__slist_node_base* x) : node(x) {}\n\n  void incr() { node = node-&gt;next; }    //前进一个节点\n\n  bool operator==(const __slist_iterator_base&amp; x) const {\n    return node == x.node;\n  }\n  bool operator!=(const __slist_iterator_base&amp; x) const {\n    return node != x.node;\n  }\n};\n\n//单向链表的迭代器结构\ntemplate &lt;class T, class Ref, class Ptr&gt;\nstruct __slist_iterator : public __slist_iterator_base\n{\n  typedef __slist_iterator&lt;T, T&amp;, T*&gt;             iterator;\n  typedef __slist_iterator&lt;T, const T&amp;, const T*&gt; const_iterator;\n  typedef __slist_iterator&lt;T, Ref, Ptr&gt;           self;\n\n  typedef T value_type;\n  typedef Ptr pointer;\n  typedef Ref reference;\n  typedef __slist_node&lt;T&gt; list_node;\n\n  __slist_iterator(list_node* x) : __slist_iterator_base(x) {}\n  __slist_iterator() : __slist_iterator_base(0) {}\n  __slist_iterator(const iterator&amp; x) : __slist_iterator_base(x.node) {}\n\n  reference operator*() const { return ((list_node*) node)-&gt;data; }\n  pointer operator-&gt;() const { return &amp;(operator*()); }\n\n  self&amp; operator++()\n  {\n    incr(); //前进一个节点\n    return *this;\n  }\n  self operator++(int)\n  {\n    self tmp = *this;\n    incr(); //前进一个节点\n    return tmp;\n  }\n};\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>单向链表的迭代器基本结构</span>\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__slist_iterator_base</span>\n{\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">size_t</span> size_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">ptrdiff_t</span> difference_type;\n  <span class=\"pl-k\">typedef</span> forward_iterator_tag iterator_category;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>单向</span>\n\n  __slist_node_base* node;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>指向节点基本结构</span>\n\n  <span class=\"pl-en\">__slist_iterator_base</span>(__slist_node_base* x) : node(x) {}\n\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">incr</span>() { node = node-&gt;<span class=\"pl-smi\">next</span>; }    <span class=\"pl-c\"><span class=\"pl-c\">//</span>前进一个节点</span>\n\n  <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>==(<span class=\"pl-k\">const</span> __slist_iterator_base&amp; x) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> node == x.<span class=\"pl-smi\">node</span>;\n  }\n  <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>!=(<span class=\"pl-k\">const</span> __slist_iterator_base&amp; x) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> node != x.<span class=\"pl-smi\">node</span>;\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>单向链表的迭代器结构</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Ref</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Ptr</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__slist_iterator</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">__slist_iterator_base</span>\n{\n  <span class=\"pl-k\">typedef</span> __slist_iterator&lt;T, T&amp;, T*&gt;             iterator;\n  <span class=\"pl-k\">typedef</span> __slist_iterator&lt;T, <span class=\"pl-k\">const</span> T&amp;, <span class=\"pl-k\">const</span> T*&gt; const_iterator;\n  <span class=\"pl-k\">typedef</span> __slist_iterator&lt;T, Ref, <span class=\"pl-c1\">Ptr</span>&gt;           self;\n\n  <span class=\"pl-k\">typedef</span> T value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">Ptr</span> pointer;\n  <span class=\"pl-k\">typedef</span> Ref reference;\n  <span class=\"pl-k\">typedef</span> __slist_node&lt;T&gt; list_node;\n\n  <span class=\"pl-en\">__slist_iterator</span>(list_node* x) : __slist_iterator_base(x) {}\n  <span class=\"pl-en\">__slist_iterator</span>() : __slist_iterator_base(<span class=\"pl-c1\">0</span>) {}\n  <span class=\"pl-en\">__slist_iterator</span>(<span class=\"pl-k\">const</span> iterator&amp; x) : __slist_iterator_base(x.node) {}\n\n  reference <span class=\"pl-k\">operator</span>*() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> ((list_node*) node)-&gt;<span class=\"pl-smi\">data</span>; }\n  pointer <span class=\"pl-k\">operator</span>-&gt;() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> &amp;(<span class=\"pl-k\">operator</span>*()); }\n\n  self&amp; <span class=\"pl-k\">operator</span>++()\n  {\n    <span class=\"pl-c1\">incr</span>(); <span class=\"pl-c\"><span class=\"pl-c\">//</span>前进一个节点</span>\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  self <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>)\n  {\n    self tmp = *<span class=\"pl-c1\">this</span>;\n    <span class=\"pl-c1\">incr</span>(); <span class=\"pl-c\"><span class=\"pl-c\">//</span>前进一个节点</span>\n    <span class=\"pl-k\">return</span> tmp;\n  }\n};</pre></div>\n<br>\n<h1 tabindex=\"-1\" id=\"user-content-五关联容器\" dir=\"auto\"><a class=\"heading-link\" href=\"#五关联容器\">五.关联容器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h1>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-4-1.jpeg\"><img src=\"/arkingc/note/raw/master/pic/stl-4-1.jpeg\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">标准的STL关联容器分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表)。这些容器的底层机制均以RB-tree(红黑树)完成。RB-tree也是一个独立容器，但并不开放给外界使用</p>\n<p dir=\"auto\">此外，SGI STL还提供了一个不在标准规格之列的关联容器：hash table，以及以此hash table为底层机制而完成的hash_set(散列集合)、hash_map(散列映射表)、hash_multiset(散列多键集合)、hash_multimap(散列多键映射表)</p>\n<h2 tabindex=\"-1\" id=\"user-content-1rb-tree\" dir=\"auto\"><a class=\"heading-link\" href=\"#1rb-tree\">1.RB-tree<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<h3 tabindex=\"-1\" id=\"user-content-11-rb-tree的节点\" dir=\"auto\"><a class=\"heading-link\" href=\"#11-rb-tree的节点\">1.1 RB-tree的节点<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"typedef bool __rb_tree_color_type;\nconst __rb_tree_color_type __rb_tree_red = false;   //红色为0\nconst __rb_tree_color_type __rb_tree_black = true;  //黑色为1\n\n//RB-tree节点的基类\nstruct __rb_tree_node_base\n{\n  typedef __rb_tree_color_type color_type;\n  typedef __rb_tree_node_base* base_ptr;\n\n  color_type color; //颜色\n  base_ptr parent;  //指向父节点的指针\n  base_ptr left;    //指向左子节点的指针\n  base_ptr right;   //指向右子节点的指针\n\n  //静态函数，获取以x为根节点的RB-tree最小节点的指针\n  static base_ptr minimum(base_ptr x)\n  {\n    while (x-&gt;left != 0) x = x-&gt;left;\n    return x;\n  }\n\n  //静态函数，获取以x为根节点的RB-tree最大节点的指针\n  static base_ptr maximum(base_ptr x)\n  {\n    while (x-&gt;right != 0) x = x-&gt;right;\n    return x;\n  }\n};\n\n//RB-tree节点类\ntemplate &lt;class Value&gt;\nstruct __rb_tree_node : public __rb_tree_node_base\n{\n  typedef __rb_tree_node&lt;Value&gt;* link_type;\n  Value value_field;    //RB-tree节点的value\n};\"><pre><span class=\"pl-k\">typedef</span> <span class=\"pl-k\">bool</span> __rb_tree_color_type;\n<span class=\"pl-k\">const</span> __rb_tree_color_type __rb_tree_red = <span class=\"pl-c1\">false</span>;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>红色为0</span>\n<span class=\"pl-k\">const</span> __rb_tree_color_type __rb_tree_black = <span class=\"pl-c1\">true</span>;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>黑色为1</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>RB-tree节点的基类</span>\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__rb_tree_node_base</span>\n{\n  <span class=\"pl-k\">typedef</span> __rb_tree_color_type color_type;\n  <span class=\"pl-k\">typedef</span> __rb_tree_node_base* base_ptr;\n\n  color_type color; <span class=\"pl-c\"><span class=\"pl-c\">//</span>颜色</span>\n  base_ptr parent;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>指向父节点的指针</span>\n  base_ptr left;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>指向左子节点的指针</span>\n  base_ptr right;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>指向右子节点的指针</span>\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>静态函数，获取以x为根节点的RB-tree最小节点的指针</span>\n  <span class=\"pl-k\">static</span> base_ptr <span class=\"pl-en\">minimum</span>(base_ptr x)\n  {\n    <span class=\"pl-k\">while</span> (x-&gt;<span class=\"pl-smi\">left</span> != <span class=\"pl-c1\">0</span>) x = x-&gt;<span class=\"pl-smi\">left</span>;\n    <span class=\"pl-k\">return</span> x;\n  }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>静态函数，获取以x为根节点的RB-tree最大节点的指针</span>\n  <span class=\"pl-k\">static</span> base_ptr <span class=\"pl-en\">maximum</span>(base_ptr x)\n  {\n    <span class=\"pl-k\">while</span> (x-&gt;<span class=\"pl-smi\">right</span> != <span class=\"pl-c1\">0</span>) x = x-&gt;<span class=\"pl-smi\">right</span>;\n    <span class=\"pl-k\">return</span> x;\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>RB-tree节点类</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Value</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__rb_tree_node</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">__rb_tree_node_base</span>\n{\n  <span class=\"pl-k\">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;\n  Value value_field;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>RB-tree节点的value</span>\n};</pre></div>\n<p dir=\"auto\"><strong>键和值都包含在value_field中</strong></p>\n<h3 tabindex=\"-1\" id=\"user-content-12-rb-tree的迭代器\" dir=\"auto\"><a class=\"heading-link\" href=\"#12-rb-tree的迭代器\">1.2 RB-tree的迭代器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">SGI将RB-tree迭代器实现为两层：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-5-1.png\"><img src=\"/arkingc/note/raw/master/pic/stl-5-1.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">RB-tree迭代器属于双向迭代器，但不具备随机定位能力。前进操作operator++()调用了基类迭代器的increment()，后退操作operator--()调用了基类迭代器的decrement()。前进或后退的举止行为完全依据二叉搜索树的节点排列法则</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//迭代器基类\nstruct __rb_tree_base_iterator\n{\n  typedef __rb_tree_node_base::base_ptr base_ptr;\n  typedef bidirectional_iterator_tag iterator_category;\n  typedef ptrdiff_t difference_type;\n\n  base_ptr node;    //节点基类类型的指针，将迭代器连接到RB-tree的节点\n\n  void increment()\n  {\n    if (node-&gt;right != 0) {//如果node右子树不为空，则找到右子树的最左子节点\n      node = node-&gt;right;\n      while (node-&gt;left != 0)\n        node = node-&gt;left;\n    }\n    else {//如果node右子树为空，则找到第一个“该节点位于其左子树”的节点\n      base_ptr y = node-&gt;parent;\n      while (node == y-&gt;right) {\n        node = y;\n        y = y-&gt;parent;\n      }\n      if (node-&gt;right != y)\n        node = y;\n    }\n  }\n\n  void decrement()\n  {\n    if (node-&gt;color == __rb_tree_red &amp;&amp;\n        node-&gt;parent-&gt;parent == node)//这种情况发生于node为header时（亦即node为\n      node = node-&gt;right;            //end()时）header右子节点即mostright，指向max节点\n    else if (node-&gt;left != 0) {//如果左子树不为空，则找到左子树的最右子节点\n      base_ptr y = node-&gt;left;\n      while (y-&gt;right != 0)\n        y = y-&gt;right;\n      node = y;\n    }\n    else {//如果左子树为空，则找到第一个“该节点位于其右子树”的节点\n      base_ptr y = node-&gt;parent;\n      while (node == y-&gt;left) {\n        node = y;\n        y = y-&gt;parent;\n      }\n      node = y;\n    }\n  }\n};\n\n//迭代器类\ntemplate &lt;class Value, class Ref, class Ptr&gt;\nstruct __rb_tree_iterator : public __rb_tree_base_iterator\n{\n  typedef Value value_type;\n  typedef Ref reference;\n  typedef Ptr pointer;\n  typedef __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;             iterator;\n  typedef __rb_tree_iterator&lt;Value, const Value&amp;, const Value*&gt; const_iterator;\n  typedef __rb_tree_iterator&lt;Value, Ref, Ptr&gt;                   self;\n  typedef __rb_tree_node&lt;Value&gt;* link_type; //指向RB-tree节点的指针类型\n\n  __rb_tree_iterator() {}\n  __rb_tree_iterator(link_type x) { node = x; }\n  __rb_tree_iterator(const iterator&amp; it) { node = it.node; }\n\n  //解引用操作为获取所指RB-tree节点的value\n  reference operator*() const { return link_type(node)-&gt;value_field; }\n#ifndef __SGI_STL_NO_ARROW_OPERATOR\n  pointer operator-&gt;() const { return &amp;(operator*()); }\n#endif /* __SGI_STL_NO_ARROW_OPERATOR */\n\n  //调用父类的increment()，函数会修改node成员，使其指向后一个RB-tree节点\n  self&amp; operator++() { increment(); return *this; }\n  self operator++(int) {\n    self tmp = *this;\n    increment();\n    return tmp;\n  }\n    \n  //调用父类的decrement()，函数会修改node成员，使其指向前一个RB-tree节点\n  self&amp; operator--() { decrement(); return *this; }\n  self operator--(int) {\n    self tmp = *this;\n    decrement();\n    return tmp;\n  }\n};\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器基类</span>\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__rb_tree_base_iterator</span>\n{\n  <span class=\"pl-k\">typedef</span> __rb_tree_node_base::base_ptr base_ptr;\n  <span class=\"pl-k\">typedef</span> bidirectional_iterator_tag iterator_category;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">ptrdiff_t</span> difference_type;\n\n  base_ptr node;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>节点基类类型的指针，将迭代器连接到RB-tree的节点</span>\n\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">increment</span>()\n  {\n    <span class=\"pl-k\">if</span> (node-&gt;<span class=\"pl-smi\">right</span> != <span class=\"pl-c1\">0</span>) {<span class=\"pl-c\"><span class=\"pl-c\">//</span>如果node右子树不为空，则找到右子树的最左子节点</span>\n      node = node-&gt;<span class=\"pl-smi\">right</span>;\n      <span class=\"pl-k\">while</span> (node-&gt;<span class=\"pl-smi\">left</span> != <span class=\"pl-c1\">0</span>)\n        node = node-&gt;<span class=\"pl-smi\">left</span>;\n    }\n    <span class=\"pl-k\">else</span> {<span class=\"pl-c\"><span class=\"pl-c\">//</span>如果node右子树为空，则找到第一个“该节点位于其左子树”的节点</span>\n      base_ptr y = node-&gt;<span class=\"pl-smi\">parent</span>;\n      <span class=\"pl-k\">while</span> (node == y-&gt;<span class=\"pl-smi\">right</span>) {\n        node = y;\n        y = y-&gt;<span class=\"pl-smi\">parent</span>;\n      }\n      <span class=\"pl-k\">if</span> (node-&gt;<span class=\"pl-smi\">right</span> != y)\n        node = y;\n    }\n  }\n\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">decrement</span>()\n  {\n    <span class=\"pl-k\">if</span> (node-&gt;<span class=\"pl-smi\">color</span> == __rb_tree_red &amp;&amp;\n        node-&gt;<span class=\"pl-smi\">parent</span>-&gt;<span class=\"pl-smi\">parent</span> == node)<span class=\"pl-c\"><span class=\"pl-c\">//</span>这种情况发生于node为header时（亦即node为</span>\n      node = node-&gt;<span class=\"pl-smi\">right</span>;            <span class=\"pl-c\"><span class=\"pl-c\">//</span>end()时）header右子节点即mostright，指向max节点</span>\n    <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (node-&gt;<span class=\"pl-smi\">left</span> != <span class=\"pl-c1\">0</span>) {<span class=\"pl-c\"><span class=\"pl-c\">//</span>如果左子树不为空，则找到左子树的最右子节点</span>\n      base_ptr y = node-&gt;<span class=\"pl-smi\">left</span>;\n      <span class=\"pl-k\">while</span> (y-&gt;<span class=\"pl-smi\">right</span> != <span class=\"pl-c1\">0</span>)\n        y = y-&gt;<span class=\"pl-smi\">right</span>;\n      node = y;\n    }\n    <span class=\"pl-k\">else</span> {<span class=\"pl-c\"><span class=\"pl-c\">//</span>如果左子树为空，则找到第一个“该节点位于其右子树”的节点</span>\n      base_ptr y = node-&gt;<span class=\"pl-smi\">parent</span>;\n      <span class=\"pl-k\">while</span> (node == y-&gt;<span class=\"pl-smi\">left</span>) {\n        node = y;\n        y = y-&gt;<span class=\"pl-smi\">parent</span>;\n      }\n      node = y;\n    }\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器类</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Value</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Ref</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Ptr</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__rb_tree_iterator</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">__rb_tree_base_iterator</span>\n{\n  <span class=\"pl-k\">typedef</span> Value value_type;\n  <span class=\"pl-k\">typedef</span> Ref reference;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">Ptr</span> pointer;\n  <span class=\"pl-k\">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;             iterator;\n  <span class=\"pl-k\">typedef</span> __rb_tree_iterator&lt;Value, <span class=\"pl-k\">const</span> Value&amp;, <span class=\"pl-k\">const</span> Value*&gt; const_iterator;\n  <span class=\"pl-k\">typedef</span> __rb_tree_iterator&lt;Value, Ref, <span class=\"pl-c1\">Ptr</span>&gt;                   self;\n  <span class=\"pl-k\">typedef</span> __rb_tree_node&lt;Value&gt;* link_type; <span class=\"pl-c\"><span class=\"pl-c\">//</span>指向RB-tree节点的指针类型</span>\n\n  <span class=\"pl-en\">__rb_tree_iterator</span>() {}\n  <span class=\"pl-en\">__rb_tree_iterator</span>(link_type x) { node = x; }\n  <span class=\"pl-en\">__rb_tree_iterator</span>(<span class=\"pl-k\">const</span> iterator&amp; it) { node = it.<span class=\"pl-smi\">node</span>; }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>解引用操作为获取所指RB-tree节点的value</span>\n  reference <span class=\"pl-k\">operator</span>*() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">link_type</span>(node)-&gt;<span class=\"pl-smi\">value_field</span>; }\n#<span class=\"pl-k\">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR\n  pointer <span class=\"pl-k\">operator</span>-&gt;() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> &amp;(<span class=\"pl-k\">operator</span>*()); }\n#<span class=\"pl-k\">endif</span> <span class=\"pl-c\"><span class=\"pl-c\">/*</span> __SGI_STL_NO_ARROW_OPERATOR <span class=\"pl-c\">*/</span></span>\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>调用父类的increment()，函数会修改node成员，使其指向后一个RB-tree节点</span>\n  self&amp; <span class=\"pl-k\">operator</span>++() { <span class=\"pl-c1\">increment</span>(); <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  self <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>) {\n    self tmp = *<span class=\"pl-c1\">this</span>;\n    <span class=\"pl-c1\">increment</span>();\n    <span class=\"pl-k\">return</span> tmp;\n  }\n    \n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>调用父类的decrement()，函数会修改node成员，使其指向前一个RB-tree节点</span>\n  self&amp; <span class=\"pl-k\">operator</span>--() { <span class=\"pl-c1\">decrement</span>(); <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  self <span class=\"pl-k\">operator</span>--(<span class=\"pl-k\">int</span>) {\n    self tmp = *<span class=\"pl-c1\">this</span>;\n    <span class=\"pl-c1\">decrement</span>();\n    <span class=\"pl-k\">return</span> tmp;\n  }\n};</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-13-rb-tree操作的实现\" dir=\"auto\"><a class=\"heading-link\" href=\"#13-rb-tree操作的实现\">1.3 RB-tree操作的实现<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L428\">RB-tree的定义</a></p>\n<ul dir=\"auto\">\n<li><strong>节点操作</strong>：\n<ul dir=\"auto\">\n<li>涉及内存管理的操作\n<ul dir=\"auto\">\n<li>分配节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L447\">get_node</a></li>\n<li>释放节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L449\">put_node</a></li>\n<li>创建节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L452\">create_node</a></li>\n<li>拷贝节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L462\">clone_node</a></li>\n<li>销毁节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L471\">destroy_node</a></li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L489\">获取节点成员</a>：\n<ul dir=\"auto\">\n<li>left</li>\n<li>right</li>\n<li>parent</li>\n<li>value</li>\n<li>key</li>\n<li>color</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>RB-tree操作</strong>\n<ul dir=\"auto\">\n<li>创建空RB-tree：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L542\">rb_tree</a>\n<ul dir=\"auto\">\n<li>初始化：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L532\">init</a></li>\n</ul>\n</li>\n<li>获取root节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L485\">root</a></li>\n<li>获取最左子节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L486\">leftmost</a></li>\n<li>获取最右子节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L487\">rightmost</a></li>\n<li>获取起始节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L575\">begin</a></li>\n<li>获取末尾节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L577\">end</a></li>\n<li>是否为空：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L587\">empty</a></li>\n<li>大小：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L588\">size</a></li>\n<li><strong>插入节点</strong>：\n<ul dir=\"auto\">\n<li>节点值独一无二：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L753\">insert_unique</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L698\">__insert</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L249\">__rb_tree_rebalance</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L210\">__rb_tree_rotate_left</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L229\">__rb_tree_rotate_right</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>允许节点值重复：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L736\">insert_equal</a>\n<ul dir=\"auto\">\n<li>__insert（同上）\n<ul dir=\"auto\">\n<li>__rb_tree_rebalance（同上）\n<ul dir=\"auto\">\n<li>__rb_tree_rotate_left（同上）</li>\n<li>__rb_tree_rotate_right（同上）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>元素搜索</strong>：\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_tree.h#L964\">find</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-2set\" dir=\"auto\"><a class=\"heading-link\" href=\"#2set\">2.set<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_set.h#L45\">set的定义</a></p>\n<p dir=\"auto\">set的所有元素都会根据元素的键值自动被排序。元素的键值就是实值，实值就是键值、set不允许两个元素具有相同的键值</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Key, class Compare = less&lt;Key&gt;, class Alloc = alloc&gt;\nclass set {\npublic:\n    ...\n    //键值和实值类型相同，比较函数也是同一个\n    typedef Key key_type;\n    typedef Key value_type;\n    typedef Compare key_compare;\n    typedef Compare value_compare;\nprivate:\n    ...\n    typedef rb_tree&lt;key_type, value_type, \n                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;\n    rep_type t;  // 内含一棵RB-tree，使用RB-tree来表现set\npublic:\n    ...\n    //iterator定义为RB-tree的const_iterator，表示set的迭代器无法执行写操作\n    typedef typename rep_type::const_iterator iterator;\n    ...\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Key</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Compare</span> = less&lt;Key&gt;, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">set</span> {\n<span class=\"pl-k\">public:</span>\n    ...\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>键值和实值类型相同，比较函数也是同一个</span>\n    <span class=\"pl-k\">typedef</span> Key key_type;\n    <span class=\"pl-k\">typedef</span> Key value_type;\n    <span class=\"pl-k\">typedef</span> Compare key_compare;\n    <span class=\"pl-k\">typedef</span> Compare value_compare;\n<span class=\"pl-k\">private:</span>\n    ...\n    <span class=\"pl-k\">typedef</span> rb_tree&lt;key_type, value_type, \n                  identity&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;\n    rep_type t;  <span class=\"pl-c\"><span class=\"pl-c\">//</span> 内含一棵RB-tree，使用RB-tree来表现set</span>\n<span class=\"pl-k\">public:</span>\n    ...\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>iterator定义为RB-tree的const_iterator，表示set的迭代器无法执行写操作</span>\n    <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> rep_type::const_iterator iterator;\n    ...\n};</pre></div>\n<p dir=\"auto\">set的元素值就是键值，关系到set元素的排列规则。因此不能通过set的迭代器改变set的元素值。set将其迭代器定义为RB-tree的const_iterator以防止修改</p>\n<p dir=\"auto\">set所开放的各种操作接口，RB-tree也提供了，所以几乎所有的set操作行为，都只是转调用RB-tree的操作行为而已</p>\n<h2 tabindex=\"-1\" id=\"user-content-3map\" dir=\"auto\"><a class=\"heading-link\" href=\"#3map\">3.map<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_map.h#L58\">map的定义</a></p>\n<p dir=\"auto\">map的所有元素会根据元素的键值自动被排序。所有元素都是pair，同时拥有键值和实值，第一个元素被视为键值，第二个元素被视为实值。map不允许两个元素拥有相同的键值</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Key, class T, class Compare = less&lt;Key&gt;, class Alloc = alloc&gt;\nclass map {\npublic:\n  typedef Key key_type;     //键值类型\n  typedef T data_type;      //实值类型\n  typedef T mapped_type;    \n  typedef pair&lt;const Key, T&gt; value_type;    //键值对，RB-tree节点中的value类型\n  typedef Compare key_compare;  //键值比较函数\n\n  ...\n\nprivate:\n  typedef rb_tree&lt;key_type, value_type, \n                  select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;\n  rep_type t;  // 内含一棵RB-tree，使用RB-tree来表现map\npublic:\n  ...\n  //迭代器和set不同，允许修改实值\n  typedef typename rep_type::iterator iterator;\n  ...\n\n  //下标操作\n  T&amp; operator[](const key_type&amp; k) {\n    return (*((insert(value_type(k, T()))).first)).second;\n  }\n\n  //插入操作\n  pair&lt;iterator,bool&gt; insert(const value_type&amp; x) { return t.insert_unique(x); }\n\n  ...\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Key</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Compare</span> = less&lt;Key&gt;, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">map</span> {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> Key key_type;     <span class=\"pl-c\"><span class=\"pl-c\">//</span>键值类型</span>\n  <span class=\"pl-k\">typedef</span> T data_type;      <span class=\"pl-c\"><span class=\"pl-c\">//</span>实值类型</span>\n  <span class=\"pl-k\">typedef</span> T mapped_type;    \n  <span class=\"pl-k\">typedef</span> pair&lt;<span class=\"pl-k\">const</span> Key, T&gt; value_type;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>键值对，RB-tree节点中的value类型</span>\n  <span class=\"pl-k\">typedef</span> Compare key_compare;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>键值比较函数</span>\n\n  ...\n\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-k\">typedef</span> rb_tree&lt;key_type, value_type, \n                  select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;\n  rep_type t;  <span class=\"pl-c\"><span class=\"pl-c\">//</span> 内含一棵RB-tree，使用RB-tree来表现map</span>\n<span class=\"pl-k\">public:</span>\n  ...\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器和set不同，允许修改实值</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> rep_type::iterator iterator;\n  ...\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>下标操作</span>\n  T&amp; <span class=\"pl-k\">operator</span>[](<span class=\"pl-k\">const</span> key_type&amp; k) {\n    <span class=\"pl-k\">return</span> (*((<span class=\"pl-c1\">insert</span>(<span class=\"pl-c1\">value_type</span>(k, <span class=\"pl-c1\">T</span>()))).<span class=\"pl-smi\">first</span>)).<span class=\"pl-smi\">second</span>;\n  }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>插入操作</span>\n  pair&lt;iterator,<span class=\"pl-k\">bool</span>&gt; <span class=\"pl-en\">insert</span>(<span class=\"pl-k\">const</span> value_type&amp; x) { <span class=\"pl-k\">return</span> t.<span class=\"pl-c1\">insert_unique</span>(x); }\n\n  ...\n};</pre></div>\n<p dir=\"auto\">可以通过map的迭代器修改元素的实值，不能修改元素的键值</p>\n<p dir=\"auto\">map所开放的各种操作接口，RB-tree也都提供了，所以几乎所有的map操作行为，都只是转调用RB-tree的操作行为而已</p>\n<h2 tabindex=\"-1\" id=\"user-content-4multiset\" dir=\"auto\"><a class=\"heading-link\" href=\"#4multiset\">4.multiset<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_multiset.h#L45\">set的定义</a></p>\n<p dir=\"auto\">multiset的特性及用法和set完全相同，唯一的差别在于它允许键值重复，插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()</p>\n<h2 tabindex=\"-1\" id=\"user-content-5multimap\" dir=\"auto\"><a class=\"heading-link\" href=\"#5multimap\">5.multimap<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_multimap.h#L45\">map的定义</a></p>\n<p dir=\"auto\">multimap的特性及用法和map完全相同，唯一的差别在于它允许键值重复，插入操作采用的是底层机制RB-tree的insert_equal()而非insert_unique()</p>\n<h2 tabindex=\"-1\" id=\"user-content-6hashtable\" dir=\"auto\"><a class=\"heading-link\" href=\"#6hashtable\">6.hashtable<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-5-2.png\"><img src=\"/arkingc/note/raw/master/pic/stl-5-2.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">SGI STL中以开哈希实现hash table，hash table表格中的元素为桶，每个桶中包含了哈希到这个桶中的节点，节点定义如下：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Value&gt;\nstruct __hashtable_node\n{\n    __hashtable_node *next;\n    Value val;\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Value</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__hashtable_node</span>\n{\n    __hashtable_node *next;\n    Value val;\n};</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-61-hashtable的迭代器\" dir=\"auto\"><a class=\"heading-link\" href=\"#61-hashtable的迭代器\">6.1 hashtable的迭代器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey, class Alloc&gt;\nstruct __hashtable_iterator {\n  typedef hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;\n          hashtable;\n  typedef __hashtable_iterator&lt;Value, Key, HashFcn, \n                               ExtractKey, EqualKey, Alloc&gt;\n          iterator;\n  typedef __hashtable_const_iterator&lt;Value, Key, HashFcn, \n                                     ExtractKey, EqualKey, Alloc&gt;\n          const_iterator;\n  typedef __hashtable_node&lt;Value&gt; node;\n\n  typedef forward_iterator_tag iterator_category;\n  typedef Value value_type;\n  typedef ptrdiff_t difference_type;\n  typedef size_t size_type;\n  typedef Value&amp; reference;\n  typedef Value* pointer;\n\n  node* cur;        //迭代器目前所指的节点\n  hashtable* ht;    //指向相应的hashtable\n\n  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}\n  __hashtable_iterator() {}\n  reference operator*() const { return cur-&gt;val; }\n  pointer operator-&gt;() const { return &amp;(operator*()); }\n  iterator&amp; operator++();\n  iterator operator++(int);\n  bool operator==(const iterator&amp; it) const { return cur == it.cur; }\n  bool operator!=(const iterator&amp; it) const { return cur != it.cur; }\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Value</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Key</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">HashFcn</span>,\n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">ExtractKey</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">EqualKey</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">__hashtable_iterator</span> {\n  <span class=\"pl-k\">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;\n          hashtable;\n  <span class=\"pl-k\">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, \n                               ExtractKey, EqualKey, Alloc&gt;\n          iterator;\n  <span class=\"pl-k\">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn, \n                                     ExtractKey, EqualKey, Alloc&gt;\n          const_iterator;\n  <span class=\"pl-k\">typedef</span> __hashtable_node&lt;Value&gt; node;\n\n  <span class=\"pl-k\">typedef</span> forward_iterator_tag iterator_category;\n  <span class=\"pl-k\">typedef</span> Value value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">ptrdiff_t</span> difference_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-c1\">size_t</span> size_type;\n  <span class=\"pl-k\">typedef</span> Value&amp; reference;\n  <span class=\"pl-k\">typedef</span> Value* pointer;\n\n  node* cur;        <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器目前所指的节点</span>\n  hashtable* ht;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>指向相应的hashtable</span>\n\n  <span class=\"pl-en\">__hashtable_iterator</span>(node* n, hashtable* tab) : cur(n), ht(tab) {}\n  <span class=\"pl-en\">__hashtable_iterator</span>() {}\n  reference <span class=\"pl-k\">operator</span>*() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> cur-&gt;<span class=\"pl-smi\">val</span>; }\n  pointer <span class=\"pl-k\">operator</span>-&gt;() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> &amp;(<span class=\"pl-k\">operator</span>*()); }\n  iterator&amp; <span class=\"pl-k\">operator</span>++();\n  iterator <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>);\n  <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>==(<span class=\"pl-k\">const</span> iterator&amp; it) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> cur == it.<span class=\"pl-smi\">cur</span>; }\n  <span class=\"pl-k\">bool</span> <span class=\"pl-k\">operator</span>!=(<span class=\"pl-k\">const</span> iterator&amp; it) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> cur != it.<span class=\"pl-smi\">cur</span>; }\n};</pre></div>\n<p dir=\"auto\">前进操作首先尝试从目前所指的节点出发，前进一个位置(节点)，由于节点被安置于list内，所以利用节点的next指针即可轻易完成。如果目前节点正好是list的尾端，就跳至下一个bucket身，它正好指向下一个list的头部节点：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class V, class K, class HF, class ExK, class EqK, class A&gt;\n__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;&amp;\n__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::operator++()\n{\n  const node* old = cur;\n  cur = cur-&gt;next;  //如果存在，就是它。否则进入以下if流程\n  if (!cur) {\n    //根据元素值，定位出下一个bucket，其起头处就是我们的目的地\n    size_type bucket = ht-&gt;bkt_num(old-&gt;val);\n    while (!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.size())\n      cur = ht-&gt;buckets[bucket];\n  }\n  return *this;\n}\n\ntemplate &lt;class V, class K, class HF, class ExK, class EqK, class A&gt;\ninline __hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;\n__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::operator++(int)\n{\n  iterator tmp = *this;\n  ++*this;\n  return tmp;\n}\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">V</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">K</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">HF</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">ExK</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">EqK</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;&amp;\n__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class=\"pl-k\">operator</span>++()\n{\n  <span class=\"pl-k\">const</span> node* old = cur;\n  cur = cur-&gt;<span class=\"pl-smi\">next</span>;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>如果存在，就是它。否则进入以下if流程</span>\n  <span class=\"pl-k\">if</span> (!cur) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>根据元素值，定位出下一个bucket，其起头处就是我们的目的地</span>\n    size_type bucket = ht-&gt;<span class=\"pl-c1\">bkt_num</span>(old-&gt;<span class=\"pl-smi\">val</span>);\n    <span class=\"pl-k\">while</span> (!cur &amp;&amp; ++bucket &lt; ht-&gt;<span class=\"pl-smi\">buckets</span>.<span class=\"pl-c1\">size</span>())\n      cur = ht-&gt;<span class=\"pl-smi\">buckets</span>[bucket];\n  }\n  <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">V</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">K</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">HF</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">ExK</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">EqK</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">inline</span> __hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;\n__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>)\n{\n  iterator tmp = *<span class=\"pl-c1\">this</span>;\n  ++*<span class=\"pl-c1\">this</span>;\n  <span class=\"pl-k\">return</span> tmp;\n}</pre></div>\n<p dir=\"auto\">hashtable的迭代器没有后退操作，hashtable也没有定义所谓的逆向迭代器</p>\n<h3 tabindex=\"-1\" id=\"user-content-62-hashtable的实现\" dir=\"auto\"><a class=\"heading-link\" href=\"#62-hashtable的实现\">6.2 hashtable的实现<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L165\">hashtable的定义</a></p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey, class Alloc = alloc&gt;\nclass hashtable;\n\n...\n\ntemplate &lt;class Value, class Key, class HashFcn,\n          class ExtractKey, class EqualKey,\n          class Alloc&gt; //先前声明时，已给出Alloc默认值alloc\nclass hashtable {\npublic:\n  typedef HashFcn hasher;\n  typedef EqualKey key_equal;\n  ...\nprivate:\n  //以下3者都是function  objects\n  hasher hash;\n  key_equal equals;\n  ExtractKey get_key;\n\n  typedef __hashtable_node&lt;Value&gt; node;  //hashtable节点类型\n  typedef simple_alloc&lt;node, Alloc&gt; node_allocator;\n\n  vector&lt;node*,Alloc&gt; buckets; //hashtable的桶数组，以vector完成\n  size_type num_elements;      //元素个数\n  ...\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Value</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Key</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">HashFcn</span>,\n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">ExtractKey</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">EqualKey</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">hashtable</span>;\n\n...\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Value</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Key</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">HashFcn</span>,\n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">ExtractKey</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">EqualKey</span>,\n          <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span>&gt; <span class=\"pl-c\"><span class=\"pl-c\">//</span>先前声明时，已给出Alloc默认值alloc</span>\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">hashtable</span> {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> HashFcn hasher;\n  <span class=\"pl-k\">typedef</span> EqualKey key_equal;\n  ...\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下3者都是function  objects</span>\n  hasher hash;\n  key_equal equals;\n  ExtractKey get_key;\n\n  <span class=\"pl-k\">typedef</span> __hashtable_node&lt;Value&gt; node;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>hashtable节点类型</span>\n  <span class=\"pl-k\">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;\n\n  vector&lt;node*,Alloc&gt; buckets; <span class=\"pl-c\"><span class=\"pl-c\">//</span>hashtable的桶数组，以vector完成</span>\n  size_type num_elements;      <span class=\"pl-c\"><span class=\"pl-c\">//</span>元素个数</span>\n  ...\n};</pre></div>\n<p dir=\"auto\">SGI STL以质数来设计表格大小，并且先将28个质数（逐渐呈现大约2倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数中，“最接近某数并大于某数”的质数：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"static const int __stl_num_primes = 28;\nstatic const unsigned long __stl_prime_list[__stl_num_primes] =\n{\n  53,         97,           193,         389,       769,\n  1543,       3079,         6151,        12289,     24593,\n  49157,      98317,        196613,      393241,    786433,\n  1572869,    3145739,      6291469,     12582917,  25165843,\n  50331653,   100663319,    201326611,   402653189, 805306457, \n  1610612741, 3221225473ul, 4294967291ul\n};\n\n//该函数被next_size()所调用\ninline unsigned long __stl_next_prime(unsigned long n)\n{\n  const unsigned long* first = __stl_prime_list;\n  const unsigned long* last = __stl_prime_list + __stl_num_primes;\n  const unsigned long* pos = lower_bound(first, last, n);\n  return pos == last ? *(last - 1) : *pos;\n}\"><pre><span class=\"pl-k\">static</span> <span class=\"pl-k\">const</span> <span class=\"pl-k\">int</span> __stl_num_primes = <span class=\"pl-c1\">28</span>;\n<span class=\"pl-k\">static</span> <span class=\"pl-k\">const</span> <span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span> __stl_prime_list[__stl_num_primes] =\n{\n  <span class=\"pl-c1\">53</span>,         <span class=\"pl-c1\">97</span>,           <span class=\"pl-c1\">193</span>,         <span class=\"pl-c1\">389</span>,       <span class=\"pl-c1\">769</span>,\n  <span class=\"pl-c1\">1543</span>,       <span class=\"pl-c1\">3079</span>,         <span class=\"pl-c1\">6151</span>,        <span class=\"pl-c1\">12289</span>,     <span class=\"pl-c1\">24593</span>,\n  <span class=\"pl-c1\">49157</span>,      <span class=\"pl-c1\">98317</span>,        <span class=\"pl-c1\">196613</span>,      <span class=\"pl-c1\">393241</span>,    <span class=\"pl-c1\">786433</span>,\n  <span class=\"pl-c1\">1572869</span>,    <span class=\"pl-c1\">3145739</span>,      <span class=\"pl-c1\">6291469</span>,     <span class=\"pl-c1\">12582917</span>,  <span class=\"pl-c1\">25165843</span>,\n  <span class=\"pl-c1\">50331653</span>,   <span class=\"pl-c1\">100663319</span>,    <span class=\"pl-c1\">201326611</span>,   <span class=\"pl-c1\">402653189</span>, <span class=\"pl-c1\">805306457</span>, \n  <span class=\"pl-c1\">1610612741</span>, <span class=\"pl-c1\">3221225473ul</span>, <span class=\"pl-c1\">4294967291ul</span>\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>该函数被next_size()所调用</span>\n<span class=\"pl-k\">inline</span> <span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span> <span class=\"pl-en\">__stl_next_prime</span>(<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span> n)\n{\n  <span class=\"pl-k\">const</span> <span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span>* first = __stl_prime_list;\n  <span class=\"pl-k\">const</span> <span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span>* last = __stl_prime_list + __stl_num_primes;\n  <span class=\"pl-k\">const</span> <span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span>* pos = <span class=\"pl-c1\">lower_bound</span>(first, last, n);\n  <span class=\"pl-k\">return</span> pos == last ? *(last - <span class=\"pl-c1\">1</span>) : *pos;\n}</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-63-hashtable操作的实现\" dir=\"auto\"><a class=\"heading-link\" href=\"#63-hashtable操作的实现\">6.3 hashtable操作的实现<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<ul dir=\"auto\">\n<li><strong>节点操作</strong>\n<ul dir=\"auto\">\n<li>涉及内存管理\n<ul dir=\"auto\">\n<li>创建节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L477\">new_node</a></li>\n<li>销毁节点：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L488\">delete_node</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>hashtable操作</strong>\n<ul dir=\"auto\">\n<li>创建满足n个bucket的hashtable：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L217\">hashtable</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L499\">initialize_buckets</a></li>\n</ul>\n</li>\n<li>插入节点\n<ul dir=\"auto\">\n<li>不允许键值重复： <a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L296\">insert_unique</a>\n<ul dir=\"auto\">\n<li>判断和重新分配bucket：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L841\">resize</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L624\">insert_unique_noresize</a></li>\n</ul>\n</li>\n<li>允许键值重复：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L302\">insert_equal</a>\n<ul dir=\"auto\">\n<li>判断和重新分配bucket：resize（同上）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L647\">insert_equal_noresize</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>哈希映射寻找bucket\n<ul dir=\"auto\">\n<li>接受实值和buckets个数：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L472\">bkt_num</a></li>\n<li>只接受实值：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L462\">bkt_num</a></li>\n<li>只接受键值：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L457\">bkt_num_key</a></li>\n<li>接受键值和buckets个数：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L467\">bkt_num_key</a></li>\n</ul>\n</li>\n<li>清除：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L917\">clear</a></li>\n<li>复制：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L934\">copy_from</a></li>\n<li>查找元素：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L400\">find</a></li>\n<li>统计元素个数：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hashtable.h#L422\">count</a></li>\n</ul>\n</li>\n</ul>\n<h3 tabindex=\"-1\" id=\"user-content-64-hash-functions\" dir=\"auto\"><a class=\"heading-link\" href=\"#64-hash-functions\">6.4 hash functions<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">hash function是计算元素位置的函数，SGI将这项任务赋予了bkt_num()，再由它来调用这里提供的hash function，取得一个可以对hashtable进行模运算的值。针对char，int，long等整数类型，大部分的hash functions什么也没做，只是忠实返回原值</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"inline size_t __stl_hash_string(const char* s)\n{\n  unsigned long h = 0; \n  for ( ; *s; ++s)\n    h = 5*h + *s;\n  \n  return size_t(h);\n}\n\n__STL_TEMPLATE_NULL struct hash&lt;char*&gt;\n{\n  size_t operator()(const char* s) const { return __stl_hash_string(s); }\n};\n\n__STL_TEMPLATE_NULL struct hash&lt;const char*&gt;\n{\n  size_t operator()(const char* s) const { return __stl_hash_string(s); }\n};\n\n__STL_TEMPLATE_NULL struct hash&lt;char&gt; {\n  size_t operator()(char x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash&lt;unsigned char&gt; {\n  size_t operator()(unsigned char x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash&lt;signed char&gt; {\n  size_t operator()(unsigned char x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash&lt;short&gt; {\n  size_t operator()(short x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash&lt;unsigned short&gt; {\n  size_t operator()(unsigned short x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash&lt;int&gt; {\n  size_t operator()(int x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash&lt;unsigned int&gt; {\n  size_t operator()(unsigned int x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash&lt;long&gt; {\n  size_t operator()(long x) const { return x; }\n};\n__STL_TEMPLATE_NULL struct hash&lt;unsigned long&gt; {\n  size_t operator()(unsigned long x) const { return x; }\n};\"><pre><span class=\"pl-k\">inline</span> <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">__stl_hash_string</span>(<span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* s)\n{\n  <span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span> h = <span class=\"pl-c1\">0</span>; \n  <span class=\"pl-k\">for</span> ( ; *s; ++s)\n    h = <span class=\"pl-c1\">5</span>*h + *s;\n  \n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">size_t</span>(h);\n}\n\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">char</span>*&gt;\n{\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* s) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">__stl_hash_string</span>(s); }\n};\n\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>*&gt;\n{\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* s) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">__stl_hash_string</span>(s); }\n};\n\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">char</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">char</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">char</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">char</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">signed</span> <span class=\"pl-k\">char</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">char</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">short</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">short</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">short</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">short</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">int</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">int</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">int</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">int</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">long</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">long</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n__STL_TEMPLATE_NULL <span class=\"pl-k\">struct</span> <span class=\"pl-en\">hash</span>&lt;<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span>&gt; {\n  <span class=\"pl-c1\">size_t</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">unsigned</span> <span class=\"pl-k\">long</span> x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};</pre></div>\n<h2 tabindex=\"-1\" id=\"user-content-7hash_set\" dir=\"auto\"><a class=\"heading-link\" href=\"#7hash_set\">7.hash_set<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hash_set.h#L47\">hash_set的定义</a></p>\n<p dir=\"auto\">hash_set以hashtable为底层机制，由于hash_set所供应的操作接口hashtable都提供了，所以几乎所有的hash_set操作行为，都只是转调用hashtable的操作行为而已</p>\n<h2 tabindex=\"-1\" id=\"user-content-8hash_map\" dir=\"auto\"><a class=\"heading-link\" href=\"#8hash_map\">8.hash_map<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_hash_map.h#L49\">hash_map的定义</a></p>\n<p dir=\"auto\">hash_map以hashtable为底层机制，由于hash_map所供应的操作接口hashtable都提供了，所以几乎所有的hash_map操作行为，都只是转调用hashtable的操作行为而已</p>\n<h2 tabindex=\"-1\" id=\"user-content-9hash_multiset\" dir=\"auto\"><a class=\"heading-link\" href=\"#9hash_multiset\">9.hash_multiset<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_multiset.h#L45\">hash_multiset的定义</a></p>\n<p dir=\"auto\">hash_multiset和hash_set实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal()，后者则是采用insert_unique()</p>\n<h2 tabindex=\"-1\" id=\"user-content-10hash_multimap\" dir=\"auto\"><a class=\"heading-link\" href=\"#10hash_multimap\">10.hash_multimap<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">SGI STL中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_multimap.h#L45\">hash_multimap的定义</a></p>\n<p dir=\"auto\">hash_multimap和hash_map实现上的唯一差别在于，前者的元素插入操作采用底层机制hashtable的insert_equal()，后者则是采用insert_unique()</p>\n<br>\n<h1 tabindex=\"-1\" id=\"user-content-六算法\" dir=\"auto\"><a class=\"heading-link\" href=\"#六算法\">六.算法<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h1>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-1.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-1.png\" style=\"max-width: 100%;\"></a> </div>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-2.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-2.png\" style=\"max-width: 100%;\"></a> </div>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-3.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-3.png\" style=\"max-width: 100%;\"></a> </div>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-4.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-4.png\" style=\"max-width: 100%;\"></a> </div>\n<h2 tabindex=\"-1\" id=\"user-content-1区间拷贝\" dir=\"auto\"><a class=\"heading-link\" href=\"#1区间拷贝\">1.区间拷贝<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<h3 tabindex=\"-1\" id=\"user-content-11-copy\" dir=\"auto\"><a class=\"heading-link\" href=\"#11-copy\">1.1 copy<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">SGI STL的copy算法用尽各种办法，包括函数重载、类型特性、偏特化等编程技巧来尽可能地加强效率</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-5.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-5.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">泛化版本</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L177\">copy</a>\n<ul dir=\"auto\">\n<li>泛化版本：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L135\">__copy_dispatch</a>\n<ul dir=\"auto\">\n<li>版本一：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L108\">__copy</a></li>\n<li>版本二：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L128\">__copy</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L118\">__copy_d</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>偏特化版本：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L157\">__copy_dispatch</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L146\">__copy_t</a>（指针所指对象具有trivial...）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L152\">__copy_t</a>（指针所指对象具有non-trivial...）</li>\n</ul>\n</li>\n<li>偏特化版本：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L166\">__copy_dispatch</a>\n<ul dir=\"auto\">\n<li>__copy_t（同上）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">特化版本</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L183\">copy</a>（针对const char*）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algobase.h#L188\">copy</a>（针对const wchar_t*）</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">copy将输入区间<code>[first,last)</code>内的元素复制到输出区间<code>[result,result+(last-first))</code>内，也就是说，它会执行赋值操作<code>*result = *first,*(result+1) = *(first+1),...</code>依次类推。返回一个迭代器：<code>result+(last-first)</code>。copy对其template参数所要求的条件非常宽松。其输入区间只需由inputIterators构成即可，输出区间只需要由OutputIterator构成即可。这<strong>意味着可以使用copy算法，将任何容器的任何一段区间的内容，复制到任何容器的任何一段区间上</strong></p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-6.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-6.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">由于拷贝的顺序，对于没有使用memmove()的版本，要特别注意目的区间与源区间重合的情况。memmove()能处理区间重合的情况</p>\n<p dir=\"auto\">copy会为输出区间内的元素赋予新值，而不是产生新的元素。它不能改变输出区间的迭代器个数。换句话说，copy不能直接用来将元素插入空容器中。如果想将元素插入序列之内，要么使用序列容器的insert成员函数，要么使用copy算法并搭配insert_iterator</p>\n<h3 tabindex=\"-1\" id=\"user-content-12-copy_backward\" dir=\"auto\"><a class=\"heading-link\" href=\"#12-copy_backward\">1.2 copy_backward<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">copy_backward将<code>[first,last)</code>区间的每一个元素，以逆行的方向复制到以result-1为起点，方向亦为逆行的区间上。换句话说，copy_backward算法会执行赋值操作<code>*(result-1) = *(last - 1),*(result-2) = *(last - 2),...</code>以此类推，返回一个迭代器：<code>result-(last-first)</code></p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-7.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-7.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">copy_backward所接受的迭代器必须是BidirectionalIterators，才能够“倒行逆施”</p>\n<h2 tabindex=\"-1\" id=\"user-content-2set相关算法\" dir=\"auto\"><a class=\"heading-link\" href=\"#2set相关算法\">2.set相关算法<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">这部分介绍的4个算法所接受的set，必须是有序区间，元素可能重复。换句话说，它们可以接受STL的set/multiset容器作为输入区间。hash_set/hash_multiset两种容器，以hashtable为底层机制，其内的元素并未呈现排序状态，所以虽然名称中也有set字样，却不可应用于这里的4个算法</p>\n<h3 tabindex=\"-1\" id=\"user-content-21-set_union\" dir=\"auto\"><a class=\"heading-link\" href=\"#21-set_union\">2.1 set_union<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">这个函数求集合s1和s2的并集。s1和s2及其并集都是以排序区间表示。函数返回一个迭代器，指向输出区间的尾端</p>\n<p dir=\"auto\">s1和s2内的每个元素都不需要唯一，因此，如果某个值在s1出现n此，在s2出现m次，那么该值在输出区间中会出现max(m,n)次</p>\n<p dir=\"auto\">SGI SLT中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2104\">set_union的实现</a>，操作示例如下：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-8.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-8.png\" style=\"max-width: 100%;\"></a> </div>\n<h3 tabindex=\"-1\" id=\"user-content-22-set_intersection\" dir=\"auto\"><a class=\"heading-link\" href=\"#22-set_intersection\">2.2 set_intersection<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">这个函数求集合s1和s2的交集。s1和s2及其交集都是以排序区间表示。函数返回一个迭代器，指向输出区间的尾端</p>\n<p dir=\"auto\">SGI SLT中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2155\">set_intersection的实现</a>，操作示例如下：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-9.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-9.png\" style=\"max-width: 100%;\"></a> </div>\n<h3 tabindex=\"-1\" id=\"user-content-23-set_difference\" dir=\"auto\"><a class=\"heading-link\" href=\"#23-set_difference\">2.3 set_difference<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">该函数计算两个集合的差集，即当s1为第一个参数，s2为第二个参数时，计算s1-s2。内含“出现于s1但不出现于s2”的每一个元素。s1和s2及其差集都是以排序区间表示。函数返回一个迭代器，指向输出区间的尾端</p>\n<p dir=\"auto\">SGI SLT中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2195\">set_difference的实现</a>，操作示例如下：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-10.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-10.png\" style=\"max-width: 100%;\"></a> </div>\n<h3 tabindex=\"-1\" id=\"user-content-24-set_symmetric_difference\" dir=\"auto\"><a class=\"heading-link\" href=\"#24-set_symmetric_difference\">2.4 set_symmetric_difference<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">这个函数求集合s1和s2的对称差集，也就是说，它能构造出集合s1-s2与集合s2-s1的并集，内含“出现于s1但不出现于s2”以及“出现于s2但不出现于s1”的每一个元素。s1、s2及其对称差集都是以排序区间表示，返回值是一个迭代器，指向输出区间的尾端</p>\n<p dir=\"auto\">由于s1和s2内的每个元素不需要唯一，因此如果某个值在s1出现n此，在s2出现m次，那么该值在输出区间中会出现|n-m|次</p>\n<p dir=\"auto\">SGI SLT中<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2235\">set_symmetric_difference的实现</a>，操作示例如下：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-11.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-11.png\" style=\"max-width: 100%;\"></a> </div>\n<h2 tabindex=\"-1\" id=\"user-content-3排序sort\" dir=\"auto\"><a class=\"heading-link\" href=\"#3排序sort\">3.排序sort<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">sort要求传入的迭代器为随机迭代器，因此只能对vector和deque进行排序</p>\n<p dir=\"auto\">STL的sort算法，数据量大时采用Quick Sort，分段递归排序。一旦分段后的数据量小于某个门槛，为避免Quick Sort的递归调用带来过大的额外负荷，就改用Insertion Sort。如果递归层次过深，还会改用Heap Sort</p>\n<p dir=\"auto\">以下为SGI SLT的sort实现：</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1048\">sort</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1005\">__lg</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1012\">__introsort_loop</a>\n<ul dir=\"auto\">\n<li>当子区间大于__stl_threshold(16)时才运行，否则直接返回\n<ul dir=\"auto\">\n<li>当深度限制为0时，使用堆排序</li>\n<li>当深度限制大于0时，继续递归排序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L983\">__final_insertion_sort</a>（此时，已经基本有序）\n<ul dir=\"auto\">\n<li>当数组区间大于__stl_threshold(16)时\n<ul dir=\"auto\">\n<li>对前面大小为16的区间调用：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L940\">__insertion_sort</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L916\">__linear_insert</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L891\">__unguarded_linear_insert</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>对后面的区间调用：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L962\">__unguarded_insertion_sort</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L955\">__unguarded_insertion_sort_aux</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L891\">__unguarded_linear_insert</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>当数组区间小于等于__stl_threshold(16)时\n<ul dir=\"auto\">\n<li>调用：__insertion_sort（同上）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 tabindex=\"-1\" id=\"user-content-4其它算法\" dir=\"auto\"><a class=\"heading-link\" href=\"#4其它算法\">4.其它算法<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\"><strong>相对简单的算法</strong>：</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>查找</strong></p>\n<ul dir=\"auto\">\n<li>adjacent_find（查找第一对满足条件的相邻元素，返回第一个元素的迭代器）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L97\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L108\">版本二</a></li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L84\">find</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L90\">find_if</a>（可以指定操作）</li>\n<li>find_end（在区间一中查找区间二最后一次出现的位置）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2557\">版本一</a>\n<ul dir=\"auto\">\n<li>单向迭代器版：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2457\">__find_end</a></li>\n<li>双向迭代器版：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2507\">__find_end</a></li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2575\">版本二</a>（可以指定操作）\n<ul dir=\"auto\">\n<li>单向迭代器版：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2480\">__find_end</a></li>\n<li>双向迭代器版：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2530\">__find_end</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>find_first_of（在区间一中查找区间二中任一元素第一次出现点）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2430\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2441\">版本二</a>（允许指定操作）</li>\n</ul>\n</li>\n<li>max_element\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2284\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2293\">版本二</a>（允许指定比较操作）</li>\n</ul>\n</li>\n<li>min_element\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2303\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2312\">版本二</a>（允许指定比较操作）</li>\n</ul>\n</li>\n<li>search（在序列一的区间中查找序列二的首次出现点）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L193\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L234\">版本二</a>（允许指定操作）</li>\n</ul>\n</li>\n<li>search_n（在序列一中查找连续n个满足条件的元素的起点）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L242\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L266\">版本二</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><strong>统计</strong></p>\n<ul dir=\"auto\">\n<li>count（统计等于某值的个数）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L139\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L120\">版本二</a>（计数变量作为参数传入）</li>\n</ul>\n</li>\n<li>count_if（可以指定操作）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L149\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L128\">版本二</a>（计数变量作为参数传入）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><strong>单区间操作</strong></p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L77\">for_each</a>（将仿函数f施行于指定区间，f不允许修改元素，因为迭代器类型是InputIterators）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L357\">generate</a>（将仿函数gen的运算结果赋值到指定区间的所有元素上）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L363\">generate_n</a>（将仿函数gen的运算结果赋值到迭代器first开始的n个元素上）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L752\">partition</a>（不保证元素的原始相对位置）</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-14.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-14.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L849\">stable_partition</a>（保留元素的原始相对位置）</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L392\">remove</a>（区间大小并不发送变化，需要移除的元素会被后面的覆盖，区间尾部会有残余，返回指向第一个残余元素的迭代器）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L370\">remove_copy</a></li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L400\">remove_if</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L381\">remove_copy_if</a></li>\n</ul>\n</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-15.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-15.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L325\">replace</a></p>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L339\">replace_copy</a></p>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L332\">repalce_if</a></p>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L348\">replace_copy_if</a></p>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L516\">reverse</a></p>\n<ul dir=\"auto\">\n<li>迭代器为双向迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L500\">__reverse</a></li>\n<li>迭代器为随机迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L510\">__reverse</a></li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L521\">reverse_copy</a></p>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B\">rotate</a>（将[first,middle)和[middle,last)的元素互换，middle所指元素将成为容器第一个元素）</p>\n<ul dir=\"auto\">\n<li>迭代器为向前迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L533\">__rotate</a></li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-16.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-16.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>迭代器为双向迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L549\">__rotate</a></li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-17.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-17.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>迭代器为随机迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L586\">__rotate</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L558\">__gcd</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L569\">__rotate_cycle</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L604\">rotate_copy</a></p>\n</li>\n<li>\n<p dir=\"auto\">transform</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L307\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L316\">版本二</a></li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">unique（移除相邻的重复元素，必须相邻，所以要先排序。和remove一样，会有残余）</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L487\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L493\">版本二</a>（允许指定操作）</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L438\">unique_copy</a></p>\n<ul dir=\"auto\">\n<li>迭代器为向前迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L408\">__unique_copy</a></li>\n<li>迭代器为输出迭代器(不能读)：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L431\">__unique_copy</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L418\">__unique_copy</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><strong>双区间操作</strong></p>\n<ul dir=\"auto\">\n<li>includes（判断区间二是否“涵盖于”区间一，两个区间必须有序）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2076\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2090\">版本二</a></li>\n</ul>\n</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-12.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-12.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>merged（合并两个区间，置于另一段空间，返回指向结果序列最后元素下一位位置的迭代器）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1761\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1780\">版本二</a>（允许指定操作）</li>\n</ul>\n</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-13.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-13.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L242\">swap_ranges</a>（将区间一的元素与first2开始等个数的元素互换）</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\"><strong>较为复杂的算法</strong>：</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><strong>查找</strong></p>\n<ul dir=\"auto\">\n<li>lower_bound（查找等于value的第一个元素的位置，不存在则返回第一个插入点）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1452\">版本一</a>\n<ul dir=\"auto\">\n<li>迭代器是向前迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1407\">__lower_bound</a></li>\n<li>迭代器是随机迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1431\">__lower_bound</a></li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1505\">版本二</a>（允许指定比较操作）</li>\n</ul>\n</li>\n<li>upper_bound（查找value的最后一个插入点，即如果存在元素等于value，那么插入最后一个等于value的元素之后）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1557\">版本一</a>\n<ul dir=\"auto\">\n<li>迭代器是向前迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1512\">__upper_bound</a></li>\n<li>迭代器是随机迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1536\">__upper_bound</a></li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1610\">版本二</a>（允许指定比较操作）</li>\n</ul>\n</li>\n<li>binary_search\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1747\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1757\">版本二</a>（允许指定比较操作）</li>\n</ul>\n</li>\n<li>equal_range（返回一对迭代器i和j，i是lower_bound的结果，j是upper_bound的结果）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1675\">版本一</a>\n<ul dir=\"auto\">\n<li>迭代器是向前迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1618\">__equal_range</a></li>\n<li>迭代器是随机迭代器：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1648\">__equal_range</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><strong>单区间操作</strong></p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">next_permutation（按字典序计算下一个排列组合。算法思想：从最尾端开始往前寻找两个相邻元素，令第一个元素为*i，第二个元素为*ii，且满足*i&lt;*ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找到第一个大于*i的元素，设为*j，将i，j元素对调，再将ii之后的所有元素颠倒排列。就是下一个排列组合）</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2322\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2349\">版本二</a></li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">prev_permutation（按字典序计算上一个排列组合。算法思想：从最尾端开始往前寻找两个相邻元素，令第一个元素为*i，第二个元素为*ii，且满足*i&gt;*ii。找到这样一组相邻元素后，再从最尾端开始往前检验，找到第一个小于*i的元素，设为*j，将i，j元素对调，再将ii之后的所有元素颠倒排列。就是下一个排列组合）</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2376\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2403\">版本二</a></li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">random_shuffle</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L622\">版本一</a>（使用内部随机数产生器）\n<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L610\">__random_shuffle</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L628\">版本二</a>（使用一个会产生随机数的仿函数）</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">partial_sort（将middle-first个最小元素排序并置于[first,middle)，其余元素放在middle开始的后半部）</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1272\">版本一</a>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1262\">__partial_sort</a></li>\n</ul>\n</li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1289\">版本二</a>（运行指定比较操作）\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1279\">__partial_sort</a></li>\n</ul>\n</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-13.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-13.png\" style=\"max-width: 100%;\"></a> </div>\n</li>\n<li>\n<p dir=\"auto\">partial_sort_copy</p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1322\">版本一</a></li>\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1357\">版本二</a>（允许指定比较操作）</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2058\">inplace_merge</a></p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L2022\">inplace_merge_aux</a>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">有额外的缓冲区辅助：<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1982\">__merge_adaptive</a></p>\n<ul dir=\"auto\">\n<li>当序列1较小，且缓冲区足够容纳序列1</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-18.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-18.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>当序列2较小，且缓冲区足够容纳序列2</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-19.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-19.png\" style=\"max-width: 100%;\"></a> </div>\n<ul dir=\"auto\">\n<li>当缓冲区不足以容纳序列1和序列2\n<a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1867\">__rotate_adaptive</a></li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-20.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-20.png\" style=\"max-width: 100%;\"></a> </div>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1380\">nth_element</a></p>\n<ul dir=\"auto\">\n<li><a href=\"/arkingc/note/blob/master/C%2B%2B/tass-sgi-stl-2.91.57-source/stl_algo.h#L1365\">__nth_element</a></li>\n</ul>\n</li>\n</ul>\n  <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-6-21.png\"><img src=\"/arkingc/note/raw/master/pic/stl-6-21.png\" style=\"max-width: 100%;\"></a> </div>\n  <br>\n</li>\n</ul>\n<h1 tabindex=\"-1\" id=\"user-content-七仿函数\" dir=\"auto\"><a class=\"heading-link\" href=\"#七仿函数\">七.仿函数<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h1>\n<p dir=\"auto\">在STL标准规格定案后，仿函数采用<strong>函数对象</strong>作为新名称</p>\n<p dir=\"auto\">函数指针的缺点在于：不能满足STL对抽象性的要求，也不能满足软件积木的要求——函数指针无法和STL其它组件（如适配器）搭配，产生更灵活的变化</p>\n<p dir=\"auto\">就实现而言，仿函数其实就是一个“行为类似函数”的对象，为了能够“行为类似函数”，其类别定义中必须自定义function call运算子。拥有这样的运算子后，就可以在仿函数的对象后面加上一对小括号，以此调用仿函数所定义的operator()</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-7-1.png\"><img src=\"/arkingc/note/raw/master/pic/stl-7-1.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">STL仿函数的分类，若以操作数的个数划分，可分为一元和二元仿函数，若以功能划分，可分为算术运算，关系运算，逻辑运算三大类</p>\n<p dir=\"auto\">任何应用程序欲使用STL內建的仿函数，都必须含入头文件，SGI则将它们实际定义于&lt;stl_function.h&gt;头文件</p>\n<h2 tabindex=\"-1\" id=\"user-content-1仿函数的相应类型\" dir=\"auto\"><a class=\"heading-link\" href=\"#1仿函数的相应类型\">1.仿函数的相应类型<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">STL仿函数应该有能力被函数适配器修饰，彼此像积木一样地串接。为了拥有适配能力，每一个仿函数必须定义自己的相应类型。就像迭代器如果要融入整个STL大家庭，也必须依照规定定义自己的5个相应类型一样。这些相应类型是为了让适配器能够取出，获得仿函数的某些信息</p>\n<p dir=\"auto\">仿函数的相应类型主要用来表现<strong>函数参数类型</strong>和<strong>传回值类型</strong></p>\n<p dir=\"auto\">为方便起见，&lt;stl_function.h&gt;定义了两个classes，分别代表一元仿函数和二元仿函数（STL不支持三元仿函数），其中没有任何data members或member functions，唯有一些类型定义。任何仿函数只要依据需求选择继承其中一个class，就自动拥有了那些相应类型，也就拥有了适配能力</p>\n<h3 tabindex=\"-1\" id=\"user-content-11-unary_function\" dir=\"auto\"><a class=\"heading-link\" href=\"#11-unary_function\">1.1 unary_function<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">unary_function用来呈现一元函数的参数类型和返回值类型：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Arg, class Result&gt;\nstruct unary_function {\n    typedef Arg argument_type;\n    typedef Result result_type;\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Result</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">unary_function</span> {\n    <span class=\"pl-k\">typedef</span> Arg argument_type;\n    <span class=\"pl-k\">typedef</span> Result result_type;\n};</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-12-binary_function\" dir=\"auto\"><a class=\"heading-link\" href=\"#12-binary_function\">1.2 binary_function<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">binary_function用来呈现二元函数的第一参数类型，第二参数类型，以及返回值类型：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Arg1, class Arg2, class Result&gt;\nstruct binary_function {\n    typedef Arg1 first_argument_type;\n    typedef Arg2 second_argument_type;\n    typedef Result result_type;\n};  \"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg2</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Result</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">binary_function</span> {\n    <span class=\"pl-k\">typedef</span> Arg1 first_argument_type;\n    <span class=\"pl-k\">typedef</span> Arg2 second_argument_type;\n    <span class=\"pl-k\">typedef</span> Result result_type;\n};  </pre></div>\n<h2 tabindex=\"-1\" id=\"user-content-2算术类仿函数\" dir=\"auto\"><a class=\"heading-link\" href=\"#2算术类仿函数\">2.算术类仿函数<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">以下为STL内建的“算术类仿函数”，除了“否定”运算为一元运算，其它都是二元运算：</p>\n<ul dir=\"auto\">\n<li>加法：plus&lt;T&gt;</li>\n<li>减法：minus&lt;T&gt;</li>\n<li>乘法：multiplies&lt;T&gt;</li>\n<li>除法：divides&lt;T&gt;</li>\n<li>取模：modulus&lt;T&gt;</li>\n<li>否定：negate&lt;T&gt;</li>\n</ul>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T&gt;\nstruct plus : public binary_function&lt;T, T, T&gt; {\n    T operator()(const T&amp; x, const T&amp; y) const { return x + y; }\n};\n\ntemplate &lt;class T&gt;\nstruct minus : public binary_function&lt;T, T, T&gt; {\n    T operator()(const T&amp; x, const T&amp; y) const { return x - y; }\n};\n\ntemplate &lt;class T&gt;\nstruct multiplies : public binary_function&lt;T, T, T&gt; {\n    T operator()(const T&amp; x, const T&amp; y) const { return x * y; }\n};\n\ntemplate &lt;class T&gt;\nstruct divides : public binary_function&lt;T, T, T&gt; {\n    T operator()(const T&amp; x, const T&amp; y) const { return x / y; }\n};\n\ntemplate &lt;class T&gt;\nstruct modulus : public binary_function&lt;T, T, T&gt; {\n    T operator()(const T&amp; x, const T&amp; y) const { return x % y; }\n};\n\ntemplate &lt;class T&gt;\nstruct negate : public unary_function&lt;T, T&gt; {\n    T operator()(const T&amp; x) const { return -x; }\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">plus</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, T&gt; {\n    T <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x + y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">minus</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, T&gt; {\n    T <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x - y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">multiplies</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, T&gt; {\n    T <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x * y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">divides</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, T&gt; {\n    T <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x / y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">modulus</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, T&gt; {\n    T <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x % y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">negate</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;T, T&gt; {\n    T <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> -x; }\n};</pre></div>\n<h2 tabindex=\"-1\" id=\"user-content-3关系运算类仿函数\" dir=\"auto\"><a class=\"heading-link\" href=\"#3关系运算类仿函数\">3.关系运算类仿函数<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">以下为STL内建的“关系运算类仿函数”，每一个都是二元运算：</p>\n<ul dir=\"auto\">\n<li>等于：equal_to&lt;T&gt;</li>\n<li>不等于：not_equal_to&lt;T&gt;</li>\n<li>大于：greater&lt;T&gt;</li>\n<li>大于或等于：greater_equal&lt;T&gt;</li>\n<li>小于：less&lt;T&gt;</li>\n<li>小于或等于：less_equal&lt;T&gt;</li>\n</ul>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T&gt;\nstruct equal_to : public binary_function&lt;T, T, bool&gt; {\n    bool operator()(const T&amp; x, const T&amp; y) const { return x == y; }\n};\n\ntemplate &lt;class T&gt;\nstruct not_equal_to : public binary_function&lt;T, T, bool&gt; {\n    bool operator()(const T&amp; x, const T&amp; y) const { return x != y; }\n};\n\ntemplate &lt;class T&gt;\nstruct greater : public binary_function&lt;T, T, bool&gt; {\n    bool operator()(const T&amp; x, const T&amp; y) const { return x &gt; y; }\n};\n\ntemplate &lt;class T&gt;\nstruct less : public binary_function&lt;T, T, bool&gt; {\n    bool operator()(const T&amp; x, const T&amp; y) const { return x &lt; y; }\n};\n\ntemplate &lt;class T&gt;\nstruct greater_equal : public binary_function&lt;T, T, bool&gt; {\n    bool operator()(const T&amp; x, const T&amp; y) const { return x &gt;= y; }\n};\n\ntemplate &lt;class T&gt;\nstruct less_equal : public binary_function&lt;T, T, bool&gt; {\n    bool operator()(const T&amp; x, const T&amp; y) const { return x &lt;= y; }\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">equal_to</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x == y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">not_equal_to</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x != y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">greater</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x &gt; y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">less</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x &lt; y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">greater_equal</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x &gt;= y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">less_equal</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x &lt;= y; }\n};</pre></div>\n<h2 tabindex=\"-1\" id=\"user-content-4逻辑运算类仿函数\" dir=\"auto\"><a class=\"heading-link\" href=\"#4逻辑运算类仿函数\">4.逻辑运算类仿函数<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">以下为STL内建的“逻辑运算类仿函数”，其中And和Or是二元运算，Not为一元运算：</p>\n<ul dir=\"auto\">\n<li>逻辑运算 And：logical_and&lt;T&gt;</li>\n<li>逻辑运算 Or：logical_or&lt;T&gt;</li>\n<li>逻辑运算 Not：logical_not&lt;T&gt;</li>\n</ul>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T&gt;\nstruct logical_and : public binary_function&lt;T, T, bool&gt; {\n    bool operator()(const T&amp; x, const T&amp; y) const { return x &amp;&amp; y; }\n};\n\ntemplate &lt;class T&gt;\nstruct logical_or : public binary_function&lt;T, T, bool&gt; {\n    bool operator()(const T&amp; x, const T&amp; y) const { return x || y; }\n};\n\ntemplate &lt;class T&gt;\nstruct logical_not : public unary_function&lt;T, bool&gt; {\n    bool operator()(const T&amp; x) const { return !x; }\n};\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">logical_and</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x &amp;&amp; y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">logical_or</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x, <span class=\"pl-k\">const</span> T&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x || y; }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">logical_not</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;T, <span class=\"pl-k\">bool</span>&gt; {\n    <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> !x; }\n};</pre></div>\n<h2 tabindex=\"-1\" id=\"user-content-5证同选择与投射\" dir=\"auto\"><a class=\"heading-link\" href=\"#5证同选择与投射\">5.证同，选择与投射<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">C++标准并未涵盖这里介绍的任何一个仿函数，不过它们常常存在于各个实现品中作为内部运用。在SGI STL中的实现如下：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//证同函数。任何数值通过此函数后，不会有任何改变\n//此函数运用于&lt;stl_set.h&gt;，用来指定RB-tree所需的KeyOfValue op\n//那是因为set元素的键值即实值，所以采用identity\ntemplate &lt;class T&gt;\nstruct identity : public unary_function&lt;T, T&gt; {\n  const T&amp; operator()(const T&amp; x) const { return x; }\n};\n\n//选择函数：接受一个pair，传回其第一元素\n//此函数运用于&lt;stl_map.h&gt;，用来指定RB-tree所需的KeyOfValue op\n//由于map系以pair元素的第一元素为其键值，所以采用select1st\ntemplate &lt;class Pair&gt;\nstruct select1st : public unary_function&lt;Pair, typename Pair::first_type&gt; {\n  const typename Pair::first_type&amp; operator()(const Pair&amp; x) const\n  {\n    return x.first;\n  }\n};\n\n//选择函数：接受一个pair,传回其第二元素\n//SGI STL并未运用此函数\ntemplate &lt;class Pair&gt;\nstruct select2nd : public unary_function&lt;Pair, typename Pair::second_type&gt; {\n  const typename Pair::second_type&amp; operator()(const Pair&amp; x) const\n  {\n    return x.second;\n  }\n};\n\n//投射函数：传回其第一参数，忽略第二参数\ntemplate &lt;class Arg1, class Arg2&gt;\nstruct project1st : public binary_function&lt;Arg1, Arg2, Arg1&gt; {\n  Arg1 operator()(const Arg1&amp; x, const Arg2&amp;) const { return x; }\n};\n\n//投射函数：传回第二参数，忽略第一参数\ntemplate &lt;class Arg1, class Arg2&gt;\nstruct project2nd : public binary_function&lt;Arg1, Arg2, Arg2&gt; {\n  Arg2 operator()(const Arg1&amp;, const Arg2&amp; y) const { return y; }\n};\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>证同函数。任何数值通过此函数后，不会有任何改变</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>此函数运用于&lt;stl_set.h&gt;，用来指定RB-tree所需的KeyOfValue op</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>那是因为set元素的键值即实值，所以采用identity</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">identity</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;T, T&gt; {\n  <span class=\"pl-k\">const</span> T&amp; <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>选择函数：接受一个pair，传回其第一元素</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>此函数运用于&lt;stl_map.h&gt;，用来指定RB-tree所需的KeyOfValue op</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>由于map系以pair元素的第一元素为其键值，所以采用select1st</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Pair</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">select1st</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;Pair, <span class=\"pl-k\">typename</span> Pair::first_type&gt; {\n  <span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Pair::first_type&amp; <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> Pair&amp; x) <span class=\"pl-k\">const</span>\n  {\n    <span class=\"pl-k\">return</span> x.<span class=\"pl-smi\">first</span>;\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>选择函数：接受一个pair,传回其第二元素</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>SGI STL并未运用此函数</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Pair</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">select2nd</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;Pair, <span class=\"pl-k\">typename</span> Pair::second_type&gt; {\n  <span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Pair::second_type&amp; <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> Pair&amp; x) <span class=\"pl-k\">const</span>\n  {\n    <span class=\"pl-k\">return</span> x.<span class=\"pl-smi\">second</span>;\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>投射函数：传回其第一参数，忽略第二参数</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg2</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">project1st</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;Arg1, Arg2, Arg1&gt; {\n  Arg1 <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> Arg1&amp; x, <span class=\"pl-k\">const</span> Arg2&amp;) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> x; }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>投射函数：传回第二参数，忽略第一参数</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg2</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">project2nd</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;Arg1, Arg2, Arg2&gt; {\n  Arg2 <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> Arg1&amp;, <span class=\"pl-k\">const</span> Arg2&amp; y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> y; }\n};</pre></div>\n<br>\n<h1 tabindex=\"-1\" id=\"user-content-八适配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#八适配器\">八.适配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h1>\n<p dir=\"auto\">适配器在STL组件的灵活组合运用功能上，扮演着轴承、转换器的角色</p>\n<p dir=\"auto\">STL所提供的各种适配器中：1）改变仿函数接口者，称为函数适配器；2）改变容器接口者，称为容器适配器；3）改变迭代器接口者，称为迭代器适配器</p>\n<h2 tabindex=\"-1\" id=\"user-content-1容器适配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#1容器适配器\">1.容器适配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">STL提供两个容器适配器：queue和stack，它们修饰deque的接口而生成新的容器风貌</p>\n<p dir=\"auto\">stack的底层由deque构成。stack封锁住了所有的deque对外接口，只开放符合stack原则的几个函数</p>\n<p dir=\"auto\">queue的底层也由deque构成。queue封锁住了所有的deque对外接口，只开放符合queue原则的几个函数</p>\n<blockquote>\n<p dir=\"auto\">stack和queue的具体详见第四章</p>\n</blockquote>\n<h2 tabindex=\"-1\" id=\"user-content-2迭代器适配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#2迭代器适配器\">2.迭代器适配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">STL提供了许多应用于迭代器身上的适配器，包括：</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\"><a href=\"#21-insert-iterators\">insert iterators</a>：可以将一般迭代的赋值操作转变为插入操作，可以分为下面几个</p>\n<ul dir=\"auto\">\n<li><a href=\"#1back_insert_iterator\">back_insert_iterator</a>：专门负责尾端的插入操作</li>\n<li><a href=\"#2front_insert_iterator\">front_insert_iterator</a>：专门负责首部的插入操作</li>\n<li><a href=\"#3insert_iterator\">insert_iterator</a>：可以从任意位置执行插入操作</li>\n</ul>\n<p dir=\"auto\">由于上面3个迭代器的使用接口不是十分直观，因此，STL提供了三个相应函数用以获取相应迭代器：</p>\n <div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-8-2.png\"><img src=\"/arkingc/note/raw/master/pic/stl-8-2.png\" style=\"max-width: 100%;\"></a> </div>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"#22-reverse-iterators\">reverse iterators</a>：可以将一般迭代器的行进方向反转</p>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"#23-iostream-iterators\">iostream iterators</a>：可以将迭代器绑定到某个iostream对象身上</p>\n<ul dir=\"auto\">\n<li>绑定到istream对象身上的，称为istream_iterator，拥有输入功能</li>\n<li>绑定到ostream对象身上的，称为ostream_iterator，拥有输出功能</li>\n</ul>\n</li>\n</ol>\n<p dir=\"auto\"><strong>C++ Standard规定它们的接口可以藉由获得</strong>，SGI STL将它们实际定义于&lt;stl_iterator.h&gt;</p>\n<h3 tabindex=\"-1\" id=\"user-content-21-insert-iterators\" dir=\"auto\"><a class=\"heading-link\" href=\"#21-insert-iterators\">2.1 insert iterators<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\"><strong>insert iterators实现的主要观念是</strong>：每一个insert iterators内部都维护有一个容器（必须由用户指定）；容器当然有自己的迭代器，于是，当客户端对insert iterators做赋值操作时，就在insert iterators中被转为对该容器的迭代器做插入操作（也就是说，调用底层容器的push_front()或push_back()或insert()）</p>\n<p dir=\"auto\">其它迭代器惯常的行为如：operator++、operator++(int)、operator*都被关闭，更没有提供operator--或operator--(int)或operator-&gt;等功能，因此类型被定义为output_iterator_tag</p>\n<h4 tabindex=\"-1\" id=\"user-content-1back_insert_iterator\" dir=\"auto\"><a class=\"heading-link\" href=\"#1back_insert_iterator\">1）back_insert_iterator<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Container&gt;\nclass back_insert_iterator {\nprotected:\n  Container* container; //底层容器\npublic:\n  typedef output_iterator_tag iterator_category;    //迭代器类型\n  typedef void                value_type;\n  typedef void                difference_type;\n  typedef void                pointer;\n  typedef void                reference;\n\n  //构造函数。传入一个容器，使back_insert_iterator与容器绑定起来\n  explicit back_insert_iterator(Container&amp; x) : container(&amp;x) {}\n  //赋值操作\n  back_insert_iterator&lt;Container&gt;&amp;\n  operator=(const typename Container::value_type&amp; value) { \n    container-&gt;push_back(value);  //赋值操作的关键是转调用容器的push_back()\n    return *this;\n  }\n  //以下3个操作对back_insert_iterator不起作用（关闭功能）\n  //三个操作符返回的都是back_insert_iterator自己\n  back_insert_iterator&lt;Container&gt;&amp; operator*() { return *this; }\n  back_insert_iterator&lt;Container&gt;&amp; operator++() { return *this; }\n  back_insert_iterator&lt;Container&gt;&amp; operator++(int) { return *this; }\n};\n\n//这是一个辅助函数，帮助我们方便使用back_insert_iterator\ntemplate &lt;class Container&gt;\ninline back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x) {\n  return back_insert_iterator&lt;Container&gt;(x);\n}\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Container</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">back_insert_iterator</span> {\n<span class=\"pl-k\">protected:</span>\n  Container* container; <span class=\"pl-c\"><span class=\"pl-c\">//</span>底层容器</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> output_iterator_tag iterator_category;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器类型</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                difference_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                pointer;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                reference;\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数。传入一个容器，使back_insert_iterator与容器绑定起来</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">back_insert_iterator</span>(Container&amp; x) : container(&amp;x) {}\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>赋值操作</span>\n  back_insert_iterator&lt;Container&gt;&amp;\n  <span class=\"pl-k\">operator</span>=(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Container::value_type&amp; value) { \n    container-&gt;<span class=\"pl-c1\">push_back</span>(value);  <span class=\"pl-c\"><span class=\"pl-c\">//</span>赋值操作的关键是转调用容器的push_back()</span>\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下3个操作对back_insert_iterator不起作用（关闭功能）</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>三个操作符返回的都是back_insert_iterator自己</span>\n  back_insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>*() { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  back_insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>++() { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  back_insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>) { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>这是一个辅助函数，帮助我们方便使用back_insert_iterator</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Container</span>&gt;\n<span class=\"pl-k\">inline</span> back_insert_iterator&lt;Container&gt; <span class=\"pl-en\">back_inserter</span>(Container&amp; x) {\n  <span class=\"pl-k\">return</span> back_insert_iterator&lt;Container&gt;(x);\n}</pre></div>\n<h4 tabindex=\"-1\" id=\"user-content-2front_insert_iterator\" dir=\"auto\"><a class=\"heading-link\" href=\"#2front_insert_iterator\">2）front_insert_iterator<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Container&gt;\nclass front_insert_iterator {\nprotected:\n  Container* container; //底层容器\npublic:\n  typedef output_iterator_tag iterator_category;   //迭代器类型\n  typedef void                value_type;\n  typedef void                difference_type;\n  typedef void                pointer;\n  typedef void                reference;\n\n  //构造函数。传入一个容器，使front_insert_iterator与容器绑定起来\n  explicit front_insert_iterator(Container&amp; x) : container(&amp;x) {}\n  //赋值操作\n  front_insert_iterator&lt;Container&gt;&amp;\n  operator=(const typename Container::value_type&amp; value) { \n    container-&gt;push_front(value);  //赋值操作的关键是转调用容器的push_front()\n    return *this;\n  }\n  //以下3个操作对front_insert_iterator不起作用（关闭功能）\n  //三个操作符返回的都是front_insert_iterator自己\n  front_insert_iterator&lt;Container&gt;&amp; operator*() { return *this; }\n  front_insert_iterator&lt;Container&gt;&amp; operator++() { return *this; }\n  front_insert_iterator&lt;Container&gt;&amp; operator++(int) { return *this; }\n};\n\n//这是一个辅助函数，帮助我们方便使用front_insert_iterator\ntemplate &lt;class Container&gt;\ninline front_insert_iterator&lt;Container&gt; front_inserter(Container&amp; x) {\n  return front_insert_iterator&lt;Container&gt;(x);\n}\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Container</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">front_insert_iterator</span> {\n<span class=\"pl-k\">protected:</span>\n  Container* container; <span class=\"pl-c\"><span class=\"pl-c\">//</span>底层容器</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> output_iterator_tag iterator_category;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器类型</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                difference_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                pointer;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                reference;\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数。传入一个容器，使front_insert_iterator与容器绑定起来</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">front_insert_iterator</span>(Container&amp; x) : container(&amp;x) {}\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>赋值操作</span>\n  front_insert_iterator&lt;Container&gt;&amp;\n  <span class=\"pl-k\">operator</span>=(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Container::value_type&amp; value) { \n    container-&gt;<span class=\"pl-c1\">push_front</span>(value);  <span class=\"pl-c\"><span class=\"pl-c\">//</span>赋值操作的关键是转调用容器的push_front()</span>\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下3个操作对front_insert_iterator不起作用（关闭功能）</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>三个操作符返回的都是front_insert_iterator自己</span>\n  front_insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>*() { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  front_insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>++() { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  front_insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>) { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>这是一个辅助函数，帮助我们方便使用front_insert_iterator</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Container</span>&gt;\n<span class=\"pl-k\">inline</span> front_insert_iterator&lt;Container&gt; <span class=\"pl-en\">front_inserter</span>(Container&amp; x) {\n  <span class=\"pl-k\">return</span> front_insert_iterator&lt;Container&gt;(x);\n}</pre></div>\n<h4 tabindex=\"-1\" id=\"user-content-3insert_iterator\" dir=\"auto\"><a class=\"heading-link\" href=\"#3insert_iterator\">3）insert_iterator<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Container&gt;\nclass insert_iterator {\nprotected:\n  Container* container;                 //底层容器\n  typename Container::iterator iter;    //底层容器的迭代器（前2个插入迭代器没有）\npublic:\n  typedef output_iterator_tag iterator_category;    //迭代器类型\n  typedef void                value_type;\n  typedef void                difference_type;\n  typedef void                pointer;\n  typedef void                reference;\n\n  //构造函数。传入一个容器，使insert_iterator与容器和容器迭代器绑定起来\n  insert_iterator(Container&amp; x, typename Container::iterator i) \n    : container(&amp;x), iter(i) {}\n  //赋值操作\n  insert_iterator&lt;Container&gt;&amp;\n  operator=(const typename Container::value_type&amp; value) { \n    iter = container-&gt;insert(iter, value);  //赋值操作的关键是转调用容器的insert()\n    ++iter; //使insert iterator永远随其目标贴身移动\n    return *this;\n  }\n  //以下3个操作对insert_iterator不起作用（关闭功能）\n  //三个操作符返回的都是insert_iterator自己\n  insert_iterator&lt;Container&gt;&amp; operator*() { return *this; }\n  insert_iterator&lt;Container&gt;&amp; operator++() { return *this; }\n  insert_iterator&lt;Container&gt;&amp; operator++(int) { return *this; }\n};\n\n//这是一个辅助函数，帮助我们方便使用insert_iterator\n//和前2个插入迭代器不容，这里还需额外传入一个底层容器的迭代器\ntemplate &lt;class Container, class Iterator&gt;\ninline insert_iterator&lt;Container&gt; inserter(Container&amp; x, Iterator i) {\n  typedef typename Container::iterator iter;\n  return insert_iterator&lt;Container&gt;(x, iter(i));\n}\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Container</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">insert_iterator</span> {\n<span class=\"pl-k\">protected:</span>\n  Container* container;                 <span class=\"pl-c\"><span class=\"pl-c\">//</span>底层容器</span>\n  <span class=\"pl-k\">typename</span> Container::iterator iter;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>底层容器的迭代器（前2个插入迭代器没有）</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> output_iterator_tag iterator_category;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器类型</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                difference_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                pointer;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                reference;\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数。传入一个容器，使insert_iterator与容器和容器迭代器绑定起来</span>\n  <span class=\"pl-en\">insert_iterator</span>(Container&amp; x, <span class=\"pl-k\">typename</span> Container::iterator i) \n    : container(&amp;x), iter(i) {}\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>赋值操作</span>\n  insert_iterator&lt;Container&gt;&amp;\n  <span class=\"pl-k\">operator</span>=(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Container::value_type&amp; value) { \n    iter = container-&gt;<span class=\"pl-c1\">insert</span>(iter, value);  <span class=\"pl-c\"><span class=\"pl-c\">//</span>赋值操作的关键是转调用容器的insert()</span>\n    ++iter; <span class=\"pl-c\"><span class=\"pl-c\">//</span>使insert iterator永远随其目标贴身移动</span>\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以下3个操作对insert_iterator不起作用（关闭功能）</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>三个操作符返回的都是insert_iterator自己</span>\n  insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>*() { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>++() { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  insert_iterator&lt;Container&gt;&amp; <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>) { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>这是一个辅助函数，帮助我们方便使用insert_iterator</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>和前2个插入迭代器不容，这里还需额外传入一个底层容器的迭代器</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Container</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Iterator</span>&gt;\n<span class=\"pl-k\">inline</span> insert_iterator&lt;Container&gt; <span class=\"pl-en\">inserter</span>(Container&amp; x, Iterator i) {\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Container::iterator iter;\n  <span class=\"pl-k\">return</span> insert_iterator&lt;Container&gt;(x, <span class=\"pl-c1\">iter</span>(i));\n}</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-22-reverse-iterators\" dir=\"auto\"><a class=\"heading-link\" href=\"#22-reverse-iterators\">2.2 reverse iterators<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">可以通过一个<strong>双向顺序容器</strong>调用rbegin()，和rend()来获取相应的逆向迭代器。只要双向顺序容器提供了begin(),end()，它的rbegin()和rend()就如同下面的形式。单向顺序容器slist不可使用reserve iterators。有些容器如stack、queue、priority_queue并不提供begin()，end()，当然也就没有rbegin()和rend()：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class T, class Alloc = alloc&gt;\nclass vector {\npublic:\n  typedef T value_type;\n  typedef value_type* iterator; //容器迭代器类型\n  typedef reverse_iterator&lt;iterator&gt; reverse_iterator; //逆向迭代器类型\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n...\n};\n\ntemplate &lt;class T, class Alloc = alloc&gt;\nclass list {\npublic:\n    typedef __list_iterator&lt;T, T&amp;, T*&gt;   iterator; //容器迭代器类型\n    typedef reverse_iterator&lt;iterator&gt; reverse_iterator;  //逆向迭代器类型\n    reverse_iterator rbegin() { return reverse_iterator(end()); }\n    reverse_iterator rend() { return reverse_iterator(begin()); }\n...\n};\n\ntemplate &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; \nclass deque {\npublic:\n    typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;   iterator;  //容器迭代器类型\n    typedef reverse_iterator&lt;iterator&gt; reverse_iterator; //逆向迭代器类型\n    iterator begin() { return start; }\n    iterator end() { return finish; }\n    reverse_iterator rbegin() { return reverse_iterator(finish); }\n    reverse_iterator rend() { return reverse_iterator(start); }\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">vector</span> {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> T value_type;\n  <span class=\"pl-k\">typedef</span> value_type* iterator; <span class=\"pl-c\"><span class=\"pl-c\">//</span>容器迭代器类型</span>\n  <span class=\"pl-k\">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator; <span class=\"pl-c\"><span class=\"pl-c\">//</span>逆向迭代器类型</span>\n  reverse_iterator <span class=\"pl-en\">rbegin</span>() { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">reverse_iterator</span>(<span class=\"pl-c1\">end</span>()); }\n  reverse_iterator <span class=\"pl-en\">rend</span>() { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">reverse_iterator</span>(<span class=\"pl-c1\">begin</span>()); }\n...\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">list</span> {\n<span class=\"pl-k\">public:</span>\n    <span class=\"pl-k\">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;   iterator; <span class=\"pl-c\"><span class=\"pl-c\">//</span>容器迭代器类型</span>\n    <span class=\"pl-k\">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>逆向迭代器类型</span>\n    reverse_iterator <span class=\"pl-en\">rbegin</span>() { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">reverse_iterator</span>(<span class=\"pl-c1\">end</span>()); }\n    reverse_iterator <span class=\"pl-en\">rend</span>() { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">reverse_iterator</span>(<span class=\"pl-c1\">begin</span>()); }\n...\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Alloc</span> = alloc, <span class=\"pl-c1\">size_t</span> BufSiz = <span class=\"pl-c1\">0</span>&gt; \n<span class=\"pl-k\">class</span> <span class=\"pl-en\">deque</span> {\n<span class=\"pl-k\">public:</span>\n    <span class=\"pl-k\">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;   iterator;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>容器迭代器类型</span>\n    <span class=\"pl-k\">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator; <span class=\"pl-c\"><span class=\"pl-c\">//</span>逆向迭代器类型</span>\n    iterator <span class=\"pl-en\">begin</span>() { <span class=\"pl-k\">return</span> start; }\n    iterator <span class=\"pl-en\">end</span>() { <span class=\"pl-k\">return</span> finish; }\n    reverse_iterator <span class=\"pl-en\">rbegin</span>() { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">reverse_iterator</span>(finish); }\n    reverse_iterator <span class=\"pl-en\">rend</span>() { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">reverse_iterator</span>(start); }</pre></div>\n<p dir=\"auto\">正向迭代器和逆向迭代器的逻辑位置如下图：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-8-3.png\"><img src=\"/arkingc/note/raw/master/pic/stl-8-3.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\">具有这样的逻辑位置关系，当我们将一个正向迭代器区间转换为一个逆向迭代器区间后，不必再有任何额外处理，就可以让接受这个逆向迭代器区间的算法，以相反的元素次序处理区间中的每一个元素</p>\n<p dir=\"auto\">reverse_iterator实现如下：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"template &lt;class Iterator&gt;\nclass reverse_iterator \n{\nprotected:\n  Iterator current; //对应的正向迭代器\npublic:\n  //迭代器的5种相应类型都和其对应的正向迭代器相同\n  typedef typename iterator_traits&lt;Iterator&gt;::iterator_category\n          iterator_category;\n  typedef typename iterator_traits&lt;Iterator&gt;::value_type\n          value_type;\n  typedef typename iterator_traits&lt;Iterator&gt;::difference_type\n          difference_type;\n  typedef typename iterator_traits&lt;Iterator&gt;::pointer\n          pointer;\n  typedef typename iterator_traits&lt;Iterator&gt;::reference\n          reference;\n\n  typedef Iterator iterator_type;              //代表正向迭代器\n  typedef reverse_iterator&lt;Iterator&gt; self;     //代表逆向迭代器\n\npublic:\n  reverse_iterator() {}\n  //下面这个构造函数将逆向迭代器与正向迭代器x关联起来\n  explicit reverse_iterator(iterator_type x) : current(x) {}\n  reverse_iterator(const self&amp; x) : current(x.current) {}\n  \n  //base()成员函数返回相应的正向迭代器\n  iterator_type base() const { return current; }\n\n  //对逆向迭代器取值，就是将“对应的正向迭代器”后退一步后取值ßßßß\n  reference operator*() const {\n    Iterator tmp = current;\n    return *--tmp;\n  }\n\n  //前置++，++变为--\n  self&amp; operator++() {\n    --current;\n    return *this;\n  }\n  //后置++，++变--\n  self operator++(int) {\n    self tmp = *this;\n    --current;\n    return tmp;\n  }\n  //前置--，--变++\n  self&amp; operator--() {\n    ++current;\n    return *this;\n  }\n  //后置--，--变++\n  self operator--(int) {\n    self tmp = *this;\n    ++current;\n    return tmp;\n  }\n\n  //前进与后退方向完全逆转\n  self operator+(difference_type n) const {\n    return self(current - n);\n  }\n  self&amp; operator+=(difference_type n) {\n    current -= n;\n    return *this;\n  }\n  self operator-(difference_type n) const {\n    return self(current + n);\n  }\n  self&amp; operator-=(difference_type n) {\n    current += n;\n    return *this;\n  }\n  //第一个*会调用本类的operator*，第二个不会\n  reference operator[](difference_type n) const { return *(*this + n); }  \n}; \"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Iterator</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">reverse_iterator</span> \n{\n<span class=\"pl-k\">protected:</span>\n  Iterator current; <span class=\"pl-c\"><span class=\"pl-c\">//</span>对应的正向迭代器</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器的5种相应类型都和其对应的正向迭代器相同</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category\n          iterator_category;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::value_type\n          value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::difference_type\n          difference_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::pointer\n          pointer;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> iterator_traits&lt;Iterator&gt;::reference\n          reference;\n\n  <span class=\"pl-k\">typedef</span> Iterator iterator_type;              <span class=\"pl-c\"><span class=\"pl-c\">//</span>代表正向迭代器</span>\n  <span class=\"pl-k\">typedef</span> reverse_iterator&lt;Iterator&gt; self;     <span class=\"pl-c\"><span class=\"pl-c\">//</span>代表逆向迭代器</span>\n\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-en\">reverse_iterator</span>() {}\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>下面这个构造函数将逆向迭代器与正向迭代器x关联起来</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">reverse_iterator</span>(iterator_type x) : current(x) {}\n  <span class=\"pl-en\">reverse_iterator</span>(<span class=\"pl-k\">const</span> self&amp; x) : current(x.current) {}\n  \n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>base()成员函数返回相应的正向迭代器</span>\n  iterator_type <span class=\"pl-en\">base</span>() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> current; }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>对逆向迭代器取值，就是将“对应的正向迭代器”后退一步后取值ßßßß</span>\n  reference <span class=\"pl-k\">operator</span>*() <span class=\"pl-k\">const</span> {\n    Iterator tmp = current;\n    <span class=\"pl-k\">return</span> *--tmp;\n  }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>前置++，++变为--</span>\n  self&amp; <span class=\"pl-k\">operator</span>++() {\n    --current;\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>后置++，++变--</span>\n  self <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>) {\n    self tmp = *<span class=\"pl-c1\">this</span>;\n    --current;\n    <span class=\"pl-k\">return</span> tmp;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>前置--，--变++</span>\n  self&amp; <span class=\"pl-k\">operator</span>--() {\n    ++current;\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>后置--，--变++</span>\n  self <span class=\"pl-k\">operator</span>--(<span class=\"pl-k\">int</span>) {\n    self tmp = *<span class=\"pl-c1\">this</span>;\n    ++current;\n    <span class=\"pl-k\">return</span> tmp;\n  }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>前进与后退方向完全逆转</span>\n  self <span class=\"pl-k\">operator</span>+(difference_type n) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>(current - n);\n  }\n  self&amp; <span class=\"pl-k\">operator</span>+=(difference_type n) {\n    current -= n;\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  self <span class=\"pl-k\">operator</span>-(difference_type n) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>(current + n);\n  }\n  self&amp; <span class=\"pl-k\">operator</span>-=(difference_type n) {\n    current += n;\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>第一个*会调用本类的operator*，第二个不会</span>\n  reference <span class=\"pl-k\">operator</span>[](difference_type n) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> *(*<span class=\"pl-c1\">this</span> + n); }  \n}; </pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-23-iostream-iterators\" dir=\"auto\"><a class=\"heading-link\" href=\"#23-iostream-iterators\">2.3 iostream iterators<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<h4 tabindex=\"-1\" id=\"user-content-1istream_iterator\" dir=\"auto\"><a class=\"heading-link\" href=\"#1istream_iterator\">1）istream_iterator<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">所谓绑定一个istream object，其实就是在istream iterator内部维护一个istream member，客户端对于这个迭代器所做的operator++操作，会被引导调用迭代器内部所含的那个istream member的输入操作(operator&gt;&gt;)。这个迭代器是个input iterator，不具备operator--</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//此版本是旧有的HP规格，未符合标准接口：istream_iterator&lt;T,charT,traits,Distance&gt;\n//然而一般使用input iterators时都只使用第一个template参数、此时以下仍适用\n//SGI STL 3.3已实现出符合标准接口的istream_iterator，做法与本版大同小异\ntemplate &lt;class T, class Distance = ptrdiff_t&gt; \nclass istream_iterator {\n  friend bool\n  operator== __STL_NULL_TMPL_ARGS (const istream_iterator&lt;T, Distance&gt;&amp; x,\n                                   const istream_iterator&lt;T, Distance&gt;&amp; y);\nprotected:\n  istream* stream;\n  T value;\n  bool end_marker;\n  void read() {\n    end_marker = (*stream) ? true : false;\n    if (end_marker) *stream &gt;&gt; value;       //关键\n    //输入后，stream的状态可能改变，所以下面再判断一次以决定end_marker\n    //当读到eof或读到类型不符的数据，stream即处于false状态\n    end_marker = (*stream) ? true : false;\n  }\npublic:\n  typedef input_iterator_tag iterator_category; //迭代器类型\n  typedef T                  value_type;\n  typedef Distance           difference_type;\n  typedef const T*           pointer;\n  typedef const T&amp;           reference;\n\n  istream_iterator() : stream(&amp;cin), end_marker(false) {}\n  istream_iterator(istream&amp; s) : stream(&amp;s) { read(); }\n  //以上两行的用法：\n  // istream_iterator&lt;int&gt; eos;         造成end_marker为false\n  // istream_iterator&lt;int&gt; initer(cin)  引发read()，程序至此会等待输入\n  \n  reference operator*() const { return value; }\n  pointer operator-&gt;() const { return &amp;(operator*()); }\n\n  //迭代器前进一个位置，就代表要读取一次数据\n  istream_iterator&lt;T, Distance&gt;&amp; operator++() { \n    read(); \n    return *this;\n  }\n  istream_iterator&lt;T, Distance&gt; operator++(int)  {\n    istream_iterator&lt;T, Distance&gt; tmp = *this;\n    read();\n    return tmp;\n  }\n};\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>此版本是旧有的HP规格，未符合标准接口：istream_iterator&lt;T,charT,traits,Distance&gt;</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>然而一般使用input iterators时都只使用第一个template参数、此时以下仍适用</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>SGI STL 3.3已实现出符合标准接口的istream_iterator，做法与本版大同小异</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Distance</span> = <span class=\"pl-c1\">ptrdiff_t</span>&gt; \n<span class=\"pl-k\">class</span> <span class=\"pl-en\">istream_iterator</span> {\n  <span class=\"pl-k\">friend</span> <span class=\"pl-k\">bool</span>\n  <span class=\"pl-k\">operator</span>== __STL_NULL_TMPL_ARGS (<span class=\"pl-k\">const</span> istream_iterator&lt;T, Distance&gt;&amp; x,\n                                   <span class=\"pl-k\">const</span> istream_iterator&lt;T, Distance&gt;&amp; y);\n<span class=\"pl-k\">protected:</span>\n  istream* stream;\n  T value;\n  <span class=\"pl-k\">bool</span> end_marker;\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">read</span>() {\n    end_marker = (*stream) ? <span class=\"pl-c1\">true</span> : <span class=\"pl-c1\">false</span>;\n    <span class=\"pl-k\">if</span> (end_marker) *stream &gt;&gt; value;       <span class=\"pl-c\"><span class=\"pl-c\">//</span>关键</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>输入后，stream的状态可能改变，所以下面再判断一次以决定end_marker</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>当读到eof或读到类型不符的数据，stream即处于false状态</span>\n    end_marker = (*stream) ? <span class=\"pl-c1\">true</span> : <span class=\"pl-c1\">false</span>;\n  }\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> input_iterator_tag iterator_category; <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器类型</span>\n  <span class=\"pl-k\">typedef</span> T                  value_type;\n  <span class=\"pl-k\">typedef</span> Distance           difference_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">const</span> T*           pointer;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">const</span> T&amp;           reference;\n\n  <span class=\"pl-en\">istream_iterator</span>() : stream(&amp;cin), end_marker(<span class=\"pl-c1\">false</span>) {}\n  <span class=\"pl-en\">istream_iterator</span>(istream&amp; s) : stream(&amp;s) { <span class=\"pl-c1\">read</span>(); }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>以上两行的用法：</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> istream_iterator&lt;int&gt; eos;         造成end_marker为false</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> istream_iterator&lt;int&gt; initer(cin)  引发read()，程序至此会等待输入</span>\n  \n  reference <span class=\"pl-k\">operator</span>*() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> value; }\n  pointer <span class=\"pl-k\">operator</span>-&gt;() <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> &amp;(<span class=\"pl-k\">operator</span>*()); }\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器前进一个位置，就代表要读取一次数据</span>\n  istream_iterator&lt;T, Distance&gt;&amp; <span class=\"pl-k\">operator</span>++() { \n    <span class=\"pl-c1\">read</span>(); \n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  istream_iterator&lt;T, Distance&gt; <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>)  {\n    istream_iterator&lt;T, Distance&gt; tmp = *<span class=\"pl-c1\">this</span>;\n    <span class=\"pl-c1\">read</span>();\n    <span class=\"pl-k\">return</span> tmp;\n  }\n};</pre></div>\n<p dir=\"auto\">下图展示了copy()和istream_iterator共同合作的例子：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-8-4.png\"><img src=\"/arkingc/note/raw/master/pic/stl-8-4.png\" style=\"max-width: 100%;\"></a> </div>\n<h4 tabindex=\"-1\" id=\"user-content-2ostream_iterator\" dir=\"auto\"><a class=\"heading-link\" href=\"#2ostream_iterator\">2）ostream_iterator<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<p dir=\"auto\">所谓绑定一个ostream object，其实就是在oßstream iterator内部维护一个ostream member，客户端对于这个迭代器所做的operator=操作，会被引导调用迭代器内部所含的那个ostream member的输出操作(operator&lt;&lt;)。这个迭代器是个Onput iterator</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//此版本是旧有的HP规格，未符合标准接口：istream_iterator&lt;T,charT,traits&gt;\n//然而一般使用onput iterators时都只使用第一个template参数、此时以下仍适用\n//SGI STL 3.3已实现出符合标准接口的ostream_iterator，做法与本版大同小异\ntemplate &lt;class T&gt;\nclass ostream_iterator {\nprotected:\n  ostream* stream;\n  const char* string;   //每次输出后的间隔符号\npublic:\n  typedef output_iterator_tag iterator_category;    //迭代器类型\n  typedef void                value_type;\n  typedef void                difference_type;\n  typedef void                pointer;\n  typedef void                reference;\n\n  ostream_iterator(ostream&amp; s) : stream(&amp;s), string(0) {}\n  ostream_iterator(ostream&amp; s, const char* c) : stream(&amp;s), string(c)  {}\n  //对迭代器做赋值操作，就代表要输出一笔数据\n  ostream_iterator&lt;T&gt;&amp; operator=(const T&amp; value) { \n    *stream &lt;&lt; value;               //关键，输出数值\n    if (string) *stream &lt;&lt; string;  //如果间隔符号不为空，输出间隔符号\n    return *this;\n  }\n  ostream_iterator&lt;T&gt;&amp; operator*() { return *this; }\n  ostream_iterator&lt;T&gt;&amp; operator++() { return *this; } \n  ostream_iterator&lt;T&gt;&amp; operator++(int) { return *this; } \n};\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>此版本是旧有的HP规格，未符合标准接口：istream_iterator&lt;T,charT,traits&gt;</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>然而一般使用onput iterators时都只使用第一个template参数、此时以下仍适用</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>SGI STL 3.3已实现出符合标准接口的ostream_iterator，做法与本版大同小异</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">ostream_iterator</span> {\n<span class=\"pl-k\">protected:</span>\n  ostream* stream;\n  <span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* string;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>每次输出后的间隔符号</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">typedef</span> output_iterator_tag iterator_category;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>迭代器类型</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                value_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                difference_type;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                pointer;\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">void</span>                reference;\n\n  <span class=\"pl-en\">ostream_iterator</span>(ostream&amp; s) : stream(&amp;s), string(<span class=\"pl-c1\">0</span>) {}\n  <span class=\"pl-en\">ostream_iterator</span>(ostream&amp; s, <span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* c) : stream(&amp;s), string(c)  {}\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>对迭代器做赋值操作，就代表要输出一笔数据</span>\n  ostream_iterator&lt;T&gt;&amp; <span class=\"pl-k\">operator</span>=(<span class=\"pl-k\">const</span> T&amp; value) { \n    *stream &lt;&lt; value;               <span class=\"pl-c\"><span class=\"pl-c\">//</span>关键，输出数值</span>\n    <span class=\"pl-k\">if</span> (string) *stream &lt;&lt; string;  <span class=\"pl-c\"><span class=\"pl-c\">//</span>如果间隔符号不为空，输出间隔符号</span>\n    <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>;\n  }\n  ostream_iterator&lt;T&gt;&amp; <span class=\"pl-k\">operator</span>*() { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; }\n  ostream_iterator&lt;T&gt;&amp; <span class=\"pl-k\">operator</span>++() { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; } \n  ostream_iterator&lt;T&gt;&amp; <span class=\"pl-k\">operator</span>++(<span class=\"pl-k\">int</span>) { <span class=\"pl-k\">return</span> *<span class=\"pl-c1\">this</span>; } \n};</pre></div>\n<p dir=\"auto\">下图展示了copy()和ostream_iterator共同合作的例子：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-8-5.png\"><img src=\"/arkingc/note/raw/master/pic/stl-8-5.png\" style=\"max-width: 100%;\"></a> </div>\n<h2 tabindex=\"-1\" id=\"user-content-3函数适配器\" dir=\"auto\"><a class=\"heading-link\" href=\"#3函数适配器\">3.函数适配器<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h2>\n<p dir=\"auto\">函数适配器(functor adapters，亦即function adapters)是所有适配器中数量最庞大的一个族群，其适配灵活度也是前2者所不能及，可以适配、适配、再适配</p>\n<p dir=\"auto\"><strong>函数适配器的价值</strong>：通过它们之间的绑定、组合、修饰能力，几乎可以无限制地创造出各种可能的表达式，搭配STL算法一起演出。下表是STL函数适配器一览表：</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-8-1.png\"><img src=\"/arkingc/note/raw/master/pic/stl-8-1.png\" style=\"max-width: 100%;\"></a> </div>\n<p dir=\"auto\"><strong>适配操作包括</strong>：</p>\n<ul dir=\"auto\">\n<li><strong>bind、negate、compose</strong></li>\n<li><strong>对一般函数或成员函数的修饰</strong></li>\n</ul>\n<p dir=\"auto\"><strong>C++标准规定，这些适配器的接口可由&lt;functional&gt;获得</strong>，SGI STL将它们定义于&lt;stl_function.h&gt;</p>\n<p dir=\"auto\"><strong>注意，所有期望获得适配能力的组件，本身都必须是可适配的。换句话说，1）一元仿函数必须继承自unary_function；2）二元仿函数必须继承自binary_function；3）成员函数必须以mem_fun处理过；4）一般函数必须以ptr_fun处理过。一个未经ptr_fun处理过的一般函数，虽然也能以函数指针的形式传给STL算法使用，却无法拥有任何适配能力</strong></p>\n<p dir=\"auto\">下图是count_if()和bind2nd(less(),12)的搭配实例；</p>\n<div align=\"center\" dir=\"auto\"> <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"/arkingc/note/blob/master/pic/stl-8-6.png\"><img src=\"/arkingc/note/raw/master/pic/stl-8-6.png\" style=\"max-width: 100%;\"></a> </div>\n<h3 tabindex=\"-1\" id=\"user-content-31-not1和not2\" dir=\"auto\"><a class=\"heading-link\" href=\"#31-not1和not2\">3.1 not1和not2<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<h4 tabindex=\"-1\" id=\"user-content-1not1\" dir=\"auto\"><a class=\"heading-link\" href=\"#1not1\">1）not1<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//以下适配器用来表示某个 &quot;可适配 predicate&quot; 的逻辑负值\ntemplate &lt;class Predicate&gt;\nclass unary_negate\n  : public unary_function&lt;typename Predicate::argument_type, bool&gt; {\nprotected:\n  Predicate pred;   //内部成员\npublic:\n  explicit unary_negate(const Predicate&amp; x) : pred(x) {}\n  bool operator()(const typename Predicate::argument_type&amp; x) const {\n    return !pred(x); //将pred的运算结果加上否定运算\n  }\n};\n\n//辅助函数，使我们得以更方便使用unary_negate\ntemplate &lt;class Predicate&gt;\ninline unary_negate&lt;Predicate&gt; not1(const Predicate&amp; pred) {\n  return unary_negate&lt;Predicate&gt;(pred);\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>以下适配器用来表示某个 \"可适配 predicate\" 的逻辑负值</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Predicate</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">unary_negate</span>\n  : public unary_function&lt;<span class=\"pl-k\">typename</span> Predicate::argument_type, <span class=\"pl-k\">bool</span>&gt; {\n<span class=\"pl-k\">protected:</span>\n  Predicate pred;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">unary_negate</span>(<span class=\"pl-k\">const</span> Predicate&amp; x) : pred(x) {}\n  <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Predicate::argument_type&amp; x) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> !<span class=\"pl-c1\">pred</span>(x); <span class=\"pl-c\"><span class=\"pl-c\">//</span>将pred的运算结果加上否定运算</span>\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>辅助函数，使我们得以更方便使用unary_negate</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Predicate</span>&gt;\n<span class=\"pl-k\">inline</span> unary_negate&lt;Predicate&gt; <span class=\"pl-en\">not1</span>(<span class=\"pl-k\">const</span> Predicate&amp; pred) {\n  <span class=\"pl-k\">return</span> unary_negate&lt;Predicate&gt;(pred);\n}</pre></div>\n<h4 tabindex=\"-1\" id=\"user-content-2not2\" dir=\"auto\"><a class=\"heading-link\" href=\"#2not2\">2）not2<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//以下适配器用来表示某个 &quot;可适配 binary predicate&quot; 的逻辑负值\ntemplate &lt;class Predicate&gt; \nclass binary_negate \n  : public binary_function&lt;typename Predicate::first_argument_type,\n                           typename Predicate::second_argument_type,\n                           bool&gt; {\nprotected:\n  Predicate pred;   //内部成员\npublic:\n  explicit binary_negate(const Predicate&amp; x) : pred(x) {}\n  bool operator()(const typename Predicate::first_argument_type&amp; x, \n                  const typename Predicate::second_argument_type&amp; y) const {\n    return !pred(x, y);  //将pred的运算结果加上否定运算\n  }\n};\n\n//辅助函数，使我们得以更方便使用binary_negate\ntemplate &lt;class Predicate&gt;\ninline binary_negate&lt;Predicate&gt; not2(const Predicate&amp; pred) {\n  return binary_negate&lt;Predicate&gt;(pred);\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>以下适配器用来表示某个 \"可适配 binary predicate\" 的逻辑负值</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Predicate</span>&gt; \n<span class=\"pl-k\">class</span> <span class=\"pl-en\">binary_negate</span> \n  : public binary_function&lt;<span class=\"pl-k\">typename</span> Predicate::first_argument_type,\n                           <span class=\"pl-k\">typename</span> Predicate::second_argument_type,\n                           <span class=\"pl-k\">bool</span>&gt; {\n<span class=\"pl-k\">protected:</span>\n  Predicate pred;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">binary_negate</span>(<span class=\"pl-k\">const</span> Predicate&amp; x) : pred(x) {}\n  <span class=\"pl-k\">bool</span> <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Predicate::first_argument_type&amp; x, \n                  <span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Predicate::second_argument_type&amp; y) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> !<span class=\"pl-c1\">pred</span>(x, y);  <span class=\"pl-c\"><span class=\"pl-c\">//</span>将pred的运算结果加上否定运算</span>\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>辅助函数，使我们得以更方便使用binary_negate</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Predicate</span>&gt;\n<span class=\"pl-k\">inline</span> binary_negate&lt;Predicate&gt; <span class=\"pl-en\">not2</span>(<span class=\"pl-k\">const</span> Predicate&amp; pred) {\n  <span class=\"pl-k\">return</span> binary_negate&lt;Predicate&gt;(pred);\n}</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-32-bind1st和bind2st\" dir=\"auto\"><a class=\"heading-link\" href=\"#32-bind1st和bind2st\">3.2 bind1st和bind2st<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<h4 tabindex=\"-1\" id=\"user-content-1bind1st\" dir=\"auto\"><a class=\"heading-link\" href=\"#1bind1st\">1）bind1st<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//以下适配器用来表示某个 &quot;可适配 binary function&quot; 转换为 “unary function”\ntemplate &lt;class Operation&gt; \nclass binder1st\n  : public unary_function&lt;typename Operation::second_argument_type,\n                          typename Operation::result_type&gt; {\nprotected:\n  Operation op;     //内部成员\n  typename Operation::first_argument_type value;    //内部成员\npublic:\n  binder1st(const Operation&amp; x,\n            const typename Operation::first_argument_type&amp; y)\n      : op(x), value(y) {}  //将表达式和第一参数记录于内部成员\n  typename Operation::result_type\n  operator()(const typename Operation::second_argument_type&amp; x) const {\n    return op(value, x);    //实际调用表达式，并将value绑定为第一参数\n  }\n};\n\n//辅助函数，使我们得以更方便使用binder1st\ntemplate &lt;class Operation, class T&gt;\ninline binder1st&lt;Operation&gt; bind1st(const Operation&amp; op, const T&amp; x) {\n  //先把x转型为op的第一参数类型\n  typedef typename Operation::first_argument_type arg1_type;\n  return binder1st&lt;Operation&gt;(op, arg1_type(x));\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>以下适配器用来表示某个 \"可适配 binary function\" 转换为 “unary function”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation</span>&gt; \n<span class=\"pl-k\">class</span> <span class=\"pl-en\">binder1st</span>\n  : public unary_function&lt;<span class=\"pl-k\">typename</span> Operation::second_argument_type,\n                          <span class=\"pl-k\">typename</span> Operation::result_type&gt; {\n<span class=\"pl-k\">protected:</span>\n  Operation op;     <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n  <span class=\"pl-k\">typename</span> Operation::first_argument_type value;    <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-en\">binder1st</span>(<span class=\"pl-k\">const</span> Operation&amp; x,\n            <span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Operation::first_argument_type&amp; y)\n      : op(x), value(y) {}  <span class=\"pl-c\"><span class=\"pl-c\">//</span>将表达式和第一参数记录于内部成员</span>\n  <span class=\"pl-k\">typename</span> Operation::result_type\n  <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Operation::second_argument_type&amp; x) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">op</span>(value, x);    <span class=\"pl-c\"><span class=\"pl-c\">//</span>实际调用表达式，并将value绑定为第一参数</span>\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>辅助函数，使我们得以更方便使用binder1st</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">inline</span> binder1st&lt;Operation&gt; <span class=\"pl-en\">bind1st</span>(<span class=\"pl-k\">const</span> Operation&amp; op, <span class=\"pl-k\">const</span> T&amp; x) {\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>先把x转型为op的第一参数类型</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Operation::first_argument_type arg1_type;\n  <span class=\"pl-k\">return</span> binder1st&lt;Operation&gt;(op, <span class=\"pl-c1\">arg1_type</span>(x));\n}</pre></div>\n<h4 tabindex=\"-1\" id=\"user-content-2bind2st\" dir=\"auto\"><a class=\"heading-link\" href=\"#2bind2st\">2）bind2st<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//以下适配器用来表示某个 &quot;可适配 binary function&quot; 转换为 “unary function”\ntemplate &lt;class Operation&gt; \nclass binder2nd\n  : public unary_function&lt;typename Operation::first_argument_type,\n                          typename Operation::result_type&gt; {\nprotected:\n  Operation op;     //内部成员\n  typename Operation::second_argument_type value;   //内部成员\npublic:\n  binder2nd(const Operation&amp; x,\n            const typename Operation::second_argument_type&amp; y) \n      : op(x), value(y) {}  //将表达式和第二参数记录于内部成员\n  typename Operation::result_type\n  operator()(const typename Operation::first_argument_type&amp; x) const {\n    return op(x, value);  //实际调用表达式，并将value绑定为第二参数\n  }\n};\n\n//辅助函数，使我们得以更方便使用binder2nd\ntemplate &lt;class Operation, class T&gt;\ninline binder2nd&lt;Operation&gt; bind2nd(const Operation&amp; op, const T&amp; x) {\n  //先把x转型为op的第一参数类型\n  typedef typename Operation::second_argument_type arg2_type;\n  return binder2nd&lt;Operation&gt;(op, arg2_type(x));\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>以下适配器用来表示某个 \"可适配 binary function\" 转换为 “unary function”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation</span>&gt; \n<span class=\"pl-k\">class</span> <span class=\"pl-en\">binder2nd</span>\n  : public unary_function&lt;<span class=\"pl-k\">typename</span> Operation::first_argument_type,\n                          <span class=\"pl-k\">typename</span> Operation::result_type&gt; {\n<span class=\"pl-k\">protected:</span>\n  Operation op;     <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n  <span class=\"pl-k\">typename</span> Operation::second_argument_type value;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-en\">binder2nd</span>(<span class=\"pl-k\">const</span> Operation&amp; x,\n            <span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Operation::second_argument_type&amp; y) \n      : op(x), value(y) {}  <span class=\"pl-c\"><span class=\"pl-c\">//</span>将表达式和第二参数记录于内部成员</span>\n  <span class=\"pl-k\">typename</span> Operation::result_type\n  <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Operation::first_argument_type&amp; x) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">op</span>(x, value);  <span class=\"pl-c\"><span class=\"pl-c\">//</span>实际调用表达式，并将value绑定为第二参数</span>\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>辅助函数，使我们得以更方便使用binder2nd</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">inline</span> binder2nd&lt;Operation&gt; <span class=\"pl-en\">bind2nd</span>(<span class=\"pl-k\">const</span> Operation&amp; op, <span class=\"pl-k\">const</span> T&amp; x) {\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>先把x转型为op的第一参数类型</span>\n  <span class=\"pl-k\">typedef</span> <span class=\"pl-k\">typename</span> Operation::second_argument_type arg2_type;\n  <span class=\"pl-k\">return</span> binder2nd&lt;Operation&gt;(op, <span class=\"pl-c1\">arg2_type</span>(x));\n}</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-33-compose1和compose2\" dir=\"auto\"><a class=\"heading-link\" href=\"#33-compose1和compose2\">3.3 compose1和compose2<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<h4 tabindex=\"-1\" id=\"user-content-1compose1\" dir=\"auto\"><a class=\"heading-link\" href=\"#1compose1\">1）compose1<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//已知两个 &quot;可适配 unary function&quot; f(),g()，以下适配器用来产生一个h()，\n//使 h(x) = f(g(x))\ntemplate &lt;class Operation1, class Operation2&gt;\nclass unary_compose : public unary_function&lt;typename Operation2::argument_type,\n                                            typename Operation1::result_type&gt; {\nprotected:\n  Operation1 op1;   //内部成员\n  Operation2 op2;   //内部成员\npublic:\n  //构造函数，将两个表达式记录于内部成员\n  unary_compose(const Operation1&amp; x, const Operation2&amp; y) : op1(x), op2(y) {}\n  \n  typename Operation1::result_type\n  operator()(const typename Operation2::argument_type&amp; x) const {\n    return op1(op2(x));     //函数合成\n  }\n};\n\n//辅助函数，让我们得以方便运用unary_compose\ntemplate &lt;class Operation1, class Operation2&gt;\ninline unary_compose&lt;Operation1, Operation2&gt; compose1(const Operation1&amp; op1, \n                                                      const Operation2&amp; op2) {\n  return unary_compose&lt;Operation1, Operation2&gt;(op1, op2);\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>已知两个 \"可适配 unary function\" f(),g()，以下适配器用来产生一个h()，</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>使 h(x) = f(g(x))</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation2</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">unary_compose</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;<span class=\"pl-k\">typename</span> Operation2::argument_type,\n                                            <span class=\"pl-k\">typename</span> Operation1::result_type&gt; {\n<span class=\"pl-k\">protected:</span>\n  Operation1 op1;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n  Operation2 op2;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数，将两个表达式记录于内部成员</span>\n  <span class=\"pl-en\">unary_compose</span>(<span class=\"pl-k\">const</span> Operation1&amp; x, <span class=\"pl-k\">const</span> Operation2&amp; y) : op1(x), op2(y) {}\n  \n  <span class=\"pl-k\">typename</span> Operation1::result_type\n  <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Operation2::argument_type&amp; x) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">op1</span>(<span class=\"pl-c1\">op2</span>(x));     <span class=\"pl-c\"><span class=\"pl-c\">//</span>函数合成</span>\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>辅助函数，让我们得以方便运用unary_compose</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation2</span>&gt;\n<span class=\"pl-k\">inline</span> unary_compose&lt;Operation1, Operation2&gt; <span class=\"pl-en\">compose1</span>(<span class=\"pl-k\">const</span> Operation1&amp; op1, \n                                                      <span class=\"pl-k\">const</span> Operation2&amp; op2) {\n  <span class=\"pl-k\">return</span> unary_compose&lt;Operation1, Operation2&gt;(op1, op2);\n}</pre></div>\n<h4 tabindex=\"-1\" id=\"user-content-2compose2\" dir=\"auto\"><a class=\"heading-link\" href=\"#2compose2\">2）compose2<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h4>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//已知一个 “可适配 binary function” f 和 两个 &quot;可适配 unary function&quot; g1,g2，\n//以下适配器用来产生一个h，使 h(x) = f(g1(x),g2(x))\ntemplate &lt;class Operation1, class Operation2, class Operation3&gt;\nclass binary_compose\n  : public unary_function&lt;typename Operation2::argument_type,\n                          typename Operation1::result_type&gt; {\nprotected:\n  Operation1 op1;   //内部成员\n  Operation2 op2;   //内部成员\n  Operation3 op3;   //内部成员\npublic:\n  //构造函数，将三个表达式记录于内部成员\n  binary_compose(const Operation1&amp; x, const Operation2&amp; y, \n                 const Operation3&amp; z) : op1(x), op2(y), op3(z) { }\n  typename Operation1::result_type\n  operator()(const typename Operation2::argument_type&amp; x) const {\n    return op1(op2(x), op3(x));     //函数合成\n  }\n};\n\n//辅助函数，让我们得以方便运用binary_compose\ntemplate &lt;class Operation1, class Operation2, class Operation3&gt;\ninline binary_compose&lt;Operation1, Operation2, Operation3&gt; \ncompose2(const Operation1&amp; op1, const Operation2&amp; op2, const Operation3&amp; op3) {\n  return binary_compose&lt;Operation1, Operation2, Operation3&gt;(op1, op2, op3);\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>已知一个 “可适配 binary function” f 和 两个 \"可适配 unary function\" g1,g2，</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>以下适配器用来产生一个h，使 h(x) = f(g1(x),g2(x))</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation2</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation3</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">binary_compose</span>\n  : public unary_function&lt;<span class=\"pl-k\">typename</span> Operation2::argument_type,\n                          <span class=\"pl-k\">typename</span> Operation1::result_type&gt; {\n<span class=\"pl-k\">protected:</span>\n  Operation1 op1;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n  Operation2 op2;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n  Operation3 op3;   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数，将三个表达式记录于内部成员</span>\n  <span class=\"pl-en\">binary_compose</span>(<span class=\"pl-k\">const</span> Operation1&amp; x, <span class=\"pl-k\">const</span> Operation2&amp; y, \n                 <span class=\"pl-k\">const</span> Operation3&amp; z) : op1(x), op2(y), op3(z) { }\n  <span class=\"pl-k\">typename</span> Operation1::result_type\n  <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> <span class=\"pl-k\">typename</span> Operation2::argument_type&amp; x) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">op1</span>(<span class=\"pl-c1\">op2</span>(x), <span class=\"pl-c1\">op3</span>(x));     <span class=\"pl-c\"><span class=\"pl-c\">//</span>函数合成</span>\n  }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>辅助函数，让我们得以方便运用binary_compose</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation2</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Operation3</span>&gt;\n<span class=\"pl-k\">inline</span> binary_compose&lt;Operation1, Operation2, Operation3&gt; \n<span class=\"pl-en\">compose2</span>(<span class=\"pl-k\">const</span> Operation1&amp; op1, <span class=\"pl-k\">const</span> Operation2&amp; op2, <span class=\"pl-k\">const</span> Operation3&amp; op3) {\n  <span class=\"pl-k\">return</span> binary_compose&lt;Operation1, Operation2, Operation3&gt;(op1, op2, op3);\n}</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-34-用于函数指针的ptr_fun\" dir=\"auto\"><a class=\"heading-link\" href=\"#34-用于函数指针的ptr_fun\">3.4 用于函数指针的ptr_fun<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//以下适配器其实就是把一个一元函数指针包起来\n//当仿函数被动调用时，就调用该函数指针\ntemplate &lt;class Arg, class Result&gt;\nclass pointer_to_unary_function : public unary_function&lt;Arg, Result&gt; {\nprotected:\n  Result (*ptr)(Arg);   //内部成员，一个函数指针\npublic:\n  pointer_to_unary_function() {}\n  //构造函数，将函数指针记录于内部成员中\n  explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}\n  //通过函数指针指向函数\n  Result operator()(Arg x) const { return ptr(x); }\n};\n\n//辅助函数，让我们得以方便使用pointer_to_unary_function \ntemplate &lt;class Arg, class Result&gt;\ninline pointer_to_unary_function&lt;Arg, Result&gt; ptr_fun(Result (*x)(Arg)) {\n  return pointer_to_unary_function&lt;Arg, Result&gt;(x);\n}\n\n//以下适配器其实就是把一个二元函数指针包起来\n//当仿函数被动调用时，就调用该函数指针\ntemplate &lt;class Arg1, class Arg2, class Result&gt;\nclass pointer_to_binary_function : public binary_function&lt;Arg1, Arg2, Result&gt; {\nprotected:\n    Result (*ptr)(Arg1, Arg2);  //内部成员，一个函数指针\npublic:\n    pointer_to_binary_function() {}\n    //构造函数，将函数指针记录于内部成员中\n    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}\n    //通过函数指针指向函数\n    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }\n};\n\n//辅助函数，让我们得以方便使用pointer_to_binary_function \ntemplate &lt;class Arg1, class Arg2, class Result&gt;\ninline pointer_to_binary_function&lt;Arg1, Arg2, Result&gt; \nptr_fun(Result (*x)(Arg1, Arg2)) {\n  return pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;(x);\n}\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>以下适配器其实就是把一个一元函数指针包起来</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>当仿函数被动调用时，就调用该函数指针</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Result</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">pointer_to_unary_function</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;Arg, Result&gt; {\n<span class=\"pl-k\">protected:</span>\n  <span class=\"pl-en\">Result</span> (*ptr)(Arg);   <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员，一个函数指针</span>\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-en\">pointer_to_unary_function</span>() {}\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数，将函数指针记录于内部成员中</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">pointer_to_unary_function</span>(Result (*x)(Arg)) : ptr(x) {}\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>通过函数指针指向函数</span>\n  Result <span class=\"pl-en\">operator</span>()(Arg x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">ptr</span>(x); }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>辅助函数，让我们得以方便使用pointer_to_unary_function </span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Result</span>&gt;\n<span class=\"pl-k\">inline</span> pointer_to_unary_function&lt;Arg, Result&gt; <span class=\"pl-en\">ptr_fun</span>(Result (*x)(Arg)) {\n  <span class=\"pl-k\">return</span> pointer_to_unary_function&lt;Arg, Result&gt;(x);\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>以下适配器其实就是把一个二元函数指针包起来</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>当仿函数被动调用时，就调用该函数指针</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg2</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Result</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">pointer_to_binary_function</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;Arg1, Arg2, Result&gt; {\n<span class=\"pl-k\">protected:</span>\n    <span class=\"pl-en\">Result</span> (*ptr)(Arg1, Arg2);  <span class=\"pl-c\"><span class=\"pl-c\">//</span>内部成员，一个函数指针</span>\n<span class=\"pl-k\">public:</span>\n    <span class=\"pl-en\">pointer_to_binary_function</span>() {}\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数，将函数指针记录于内部成员中</span>\n    <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">pointer_to_binary_function</span>(Result (*x)(Arg1, Arg2)) : ptr(x) {}\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>通过函数指针指向函数</span>\n    Result <span class=\"pl-en\">operator</span>()(Arg1 x, Arg2 y) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> <span class=\"pl-c1\">ptr</span>(x, y); }\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>辅助函数，让我们得以方便使用pointer_to_binary_function </span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg1</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Arg2</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">Result</span>&gt;\n<span class=\"pl-k\">inline</span> pointer_to_binary_function&lt;Arg1, Arg2, Result&gt; \n<span class=\"pl-en\">ptr_fun</span>(Result (*x)(Arg1, Arg2)) {\n  <span class=\"pl-k\">return</span> pointer_to_binary_function&lt;Arg1, Arg2, Result&gt;(x);\n}</pre></div>\n<h3 tabindex=\"-1\" id=\"user-content-35-用于成员函数指针的mem_fun和mem_fun_ref\" dir=\"auto\"><a class=\"heading-link\" href=\"#35-用于成员函数指针的mem_fun和mem_fun_ref\">3.5 用于成员函数指针的mem_fun和mem_fun_ref<svg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"></path></svg></a></h3>\n<p dir=\"auto\">假设Shape是一个继承体系中的基类，并且具有虚函数display()，有一个vector&lt;Shape*&gt; V，那么可以给for_each()传入一个以适配器mem_fun修饰的display()：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"for_each(V.begin(),V.end(),mem_fun(&amp;Shape::display));\"><pre><span class=\"pl-en\">for_each</span>(V.begin(),V.end(),mem_fun(&amp;Shape::display));</pre></div>\n<p dir=\"auto\">不能写成：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"for_each(V.begin(),V.end(),&amp;Shape::display);\nfor_each(V.begin(),V.end(),Shape::display);\"><pre><span class=\"pl-en\">for_each</span>(V.begin(),V.end(),&amp;Shape::display);\n<span class=\"pl-en\">for_each</span>(V.begin(),V.end(),Shape::display);</pre></div>\n<p dir=\"auto\">以下是用于成员函数的适配器的实现：</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//“无任何参数”、“通过pointer调用”、“non-const成员函数”\ntemplate &lt;class S, class T&gt;\nclass mem_fun_t : public unary_function&lt;T*, S&gt; {\npublic:\n  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}       //构造函数\n  S operator()(T* p) const { return (p-&gt;*f)(); }    //转调用\nprivate:\n  S (T::*f)();\n};\n\n//“无任何参数”、“通过pointer调用”、“const成员函数”\ntemplate &lt;class S, class T&gt;\nclass const_mem_fun_t : public unary_function&lt;const T*, S&gt; {\npublic:\n  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {} //构造函数\n  S operator()(const T* p) const { return (p-&gt;*f)(); }    //转调用\nprivate:\n  S (T::*f)() const;\n};\n\n//“无任何参数”、“通过reference调用”、“non-const成员函数”\ntemplate &lt;class S, class T&gt;\nclass mem_fun_ref_t : public unary_function&lt;T, S&gt; {\npublic:\n  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}   //构造函数\n  S operator()(T&amp; r) const { return (r.*f)(); }     //转调用\nprivate:\n  S (T::*f)();\n};\n\n//“无任何参数”、“通过reference调用”、“const成员函数”\ntemplate &lt;class S, class T&gt;\nclass const_mem_fun_ref_t : public unary_function&lt;T, S&gt; {\npublic:\n  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}  //构造函数\n  S operator()(const T&amp; r) const { return (r.*f)(); }          //转调用\nprivate:\n  S (T::*f)() const;\n};\n\n//“有1个参数”、“通过pointer调用”、“non-const成员函数”\ntemplate &lt;class S, class T, class A&gt;\nclass mem_fun1_t : public binary_function&lt;T*, A, S&gt; {\npublic:\n  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}         //构造函数\n  S operator()(T* p, A x) const { return (p-&gt;*f)(x); }  //转调用\nprivate:\n  S (T::*f)(A);\n};\n\n//“有1个参数”、“通过pointer调用”、“const成员函数”\ntemplate &lt;class S, class T, class A&gt;\nclass const_mem_fun1_t : public binary_function&lt;const T*, A, S&gt; {\npublic:\n  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}  //构造函数\n  S operator()(const T* p, A x) const { return (p-&gt;*f)(x); } //转调用\nprivate:\n  S (T::*f)(A) const;\n};\n\n//“有1个参数”、“通过reference调用”、“non-const成员函数”\ntemplate &lt;class S, class T, class A&gt;\nclass mem_fun1_ref_t : public binary_function&lt;T, A, S&gt; {\npublic:\n  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}     //构造函数\n  S operator()(T&amp; r, A x) const { return (r.*f)(x); }   //转调用\nprivate:\n  S (T::*f)(A);\n};\n\n//“有1个参数”、“通过reference调用”、“const成员函数”\ntemplate &lt;class S, class T, class A&gt;\nclass const_mem_fun1_ref_t : public binary_function&lt;T, A, S&gt; {\npublic:\n  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {} //构造函数\n  S operator()(const T&amp; r, A x) const { return (r.*f)(x); }     //转调用\nprivate:\n  S (T::*f)(A) const;\n};\n\n/*********************************************************\n * 下面的8个辅助函数简化了上面8个类的使用\n * mem_fun 与 mem_fun_ref\n * mem_fun1 与 mem_fun1_ref：C++标准已经去掉了1，改成和上面2个\n                            函数重载的形式\n *********************************************************/\n\ntemplate &lt;class S, class T&gt;\ninline mem_fun_t&lt;S,T&gt; mem_fun(S (T::*f)()) { \n  return mem_fun_t&lt;S,T&gt;(f);\n}\n\ntemplate &lt;class S, class T&gt;\ninline const_mem_fun_t&lt;S,T&gt; mem_fun(S (T::*f)() const) {\n  return const_mem_fun_t&lt;S,T&gt;(f);\n}\n\ntemplate &lt;class S, class T&gt;\ninline mem_fun_ref_t&lt;S,T&gt; mem_fun_ref(S (T::*f)()) { \n  return mem_fun_ref_t&lt;S,T&gt;(f);\n}\n\ntemplate &lt;class S, class T&gt;\ninline const_mem_fun_ref_t&lt;S,T&gt; mem_fun_ref(S (T::*f)() const) {\n  return const_mem_fun_ref_t&lt;S,T&gt;(f);\n}\n\ntemplate &lt;class S, class T, class A&gt;\ninline mem_fun1_t&lt;S,T,A&gt; mem_fun1(S (T::*f)(A)) { \n  return mem_fun1_t&lt;S,T,A&gt;(f);\n}\n\ntemplate &lt;class S, class T, class A&gt;\ninline const_mem_fun1_t&lt;S,T,A&gt; mem_fun1(S (T::*f)(A) const) {\n  return const_mem_fun1_t&lt;S,T,A&gt;(f);\n}\n\ntemplate &lt;class S, class T, class A&gt;\ninline mem_fun1_ref_t&lt;S,T,A&gt; mem_fun1_ref(S (T::*f)(A)) { \n  return mem_fun1_ref_t&lt;S,T,A&gt;(f);\n}\n\ntemplate &lt;class S, class T, class A&gt;\ninline const_mem_fun1_ref_t&lt;S,T,A&gt; mem_fun1_ref(S (T::*f)(A) const) {\n  return const_mem_fun1_ref_t&lt;S,T,A&gt;(f);\n}\n\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span>“无任何参数”、“通过pointer调用”、“non-const成员函数”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">mem_fun_t</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;T*, S&gt; {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">mem_fun_t</span>(S (T::*pf)()) : f(pf) {}       <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n  S <span class=\"pl-en\">operator</span>()(T* p) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (p-&gt;*f)(); }    <span class=\"pl-c\"><span class=\"pl-c\">//</span>转调用</span>\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-en\">S</span> (T::*f)();\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>“无任何参数”、“通过pointer调用”、“const成员函数”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">const_mem_fun_t</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;<span class=\"pl-k\">const</span> T*, S&gt; {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">const_mem_fun_t</span>(S (T::*pf)() <span class=\"pl-k\">const</span>) : f(pf) {} <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n  S <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T* p) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (p-&gt;*f)(); }    <span class=\"pl-c\"><span class=\"pl-c\">//</span>转调用</span>\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-en\">S</span> (T::*f)() <span class=\"pl-k\">const</span>;\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>“无任何参数”、“通过reference调用”、“non-const成员函数”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">mem_fun_ref_t</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;T, S&gt; {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">mem_fun_ref_t</span>(S (T::*pf)()) : f(pf) {}   <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n  S <span class=\"pl-en\">operator</span>()(T&amp; r) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (r.*f)(); }     <span class=\"pl-c\"><span class=\"pl-c\">//</span>转调用</span>\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-en\">S</span> (T::*f)();\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>“无任何参数”、“通过reference调用”、“const成员函数”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">const_mem_fun_ref_t</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">unary_function</span>&lt;T, S&gt; {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">const_mem_fun_ref_t</span>(S (T::*pf)() <span class=\"pl-k\">const</span>) : f(pf) {}  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n  S <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; r) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (r.*f)(); }          <span class=\"pl-c\"><span class=\"pl-c\">//</span>转调用</span>\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-en\">S</span> (T::*f)() <span class=\"pl-k\">const</span>;\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>“有1个参数”、“通过pointer调用”、“non-const成员函数”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">mem_fun1_t</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T*, A, S&gt; {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">mem_fun1_t</span>(S (T::*pf)(A)) : f(pf) {}         <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n  S <span class=\"pl-en\">operator</span>()(T* p, A x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (p-&gt;*f)(x); }  <span class=\"pl-c\"><span class=\"pl-c\">//</span>转调用</span>\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-en\">S</span> (T::*f)(A);\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>“有1个参数”、“通过pointer调用”、“const成员函数”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">const_mem_fun1_t</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;<span class=\"pl-k\">const</span> T*, A, S&gt; {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">const_mem_fun1_t</span>(S (T::*pf)(A) <span class=\"pl-k\">const</span>) : f(pf) {}  <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n  S <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T* p, A x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (p-&gt;*f)(x); } <span class=\"pl-c\"><span class=\"pl-c\">//</span>转调用</span>\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-en\">S</span> (T::*f)(A) <span class=\"pl-k\">const</span>;\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>“有1个参数”、“通过reference调用”、“non-const成员函数”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">mem_fun1_ref_t</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, A, S&gt; {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">mem_fun1_ref_t</span>(S (T::*pf)(A)) : f(pf) {}     <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n  S <span class=\"pl-en\">operator</span>()(T&amp; r, A x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (r.*f)(x); }   <span class=\"pl-c\"><span class=\"pl-c\">//</span>转调用</span>\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-en\">S</span> (T::*f)(A);\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>“有1个参数”、“通过reference调用”、“const成员函数”</span>\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">const_mem_fun1_ref_t</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">binary_function</span>&lt;T, A, S&gt; {\n<span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">const_mem_fun1_ref_t</span>(S (T::*pf)(A) <span class=\"pl-k\">const</span>) : f(pf) {} <span class=\"pl-c\"><span class=\"pl-c\">//</span>构造函数</span>\n  S <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> T&amp; r, A x) <span class=\"pl-k\">const</span> { <span class=\"pl-k\">return</span> (r.*f)(x); }     <span class=\"pl-c\"><span class=\"pl-c\">//</span>转调用</span>\n<span class=\"pl-k\">private:</span>\n  <span class=\"pl-en\">S</span> (T::*f)(A) <span class=\"pl-k\">const</span>;\n};\n\n<span class=\"pl-c\"><span class=\"pl-c\">/*</span>********************************************************</span>\n<span class=\"pl-c\"> * 下面的8个辅助函数简化了上面8个类的使用</span>\n<span class=\"pl-c\"> * mem_fun 与 mem_fun_ref</span>\n<span class=\"pl-c\"> * mem_fun1 与 mem_fun1_ref：C++标准已经去掉了1，改成和上面2个</span>\n<span class=\"pl-c\">                            函数重载的形式</span>\n<span class=\"pl-c\"> ********************************************************<span class=\"pl-c\">*/</span></span>\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">mem_fun_t</span>&lt;S,T&gt; <span class=\"pl-en\">mem_fun</span>(S (T::*f)()) { \n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">mem_fun_t</span>&lt;S,T&gt;(f);\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">const_mem_fun_t</span>&lt;S,T&gt; <span class=\"pl-en\">mem_fun</span>(S (T::*f)() <span class=\"pl-k\">const</span>) {\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">const_mem_fun_t</span>&lt;S,T&gt;(f);\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">mem_fun_ref_t</span>&lt;S,T&gt; <span class=\"pl-en\">mem_fun_ref</span>(S (T::*f)()) { \n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">mem_fun_ref_t</span>&lt;S,T&gt;(f);\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">const_mem_fun_ref_t</span>&lt;S,T&gt; <span class=\"pl-en\">mem_fun_ref</span>(S (T::*f)() <span class=\"pl-k\">const</span>) {\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">const_mem_fun_ref_t</span>&lt;S,T&gt;(f);\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">mem_fun1_t</span>&lt;S,T,A&gt; <span class=\"pl-en\">mem_fun1</span>(S (T::*f)(A)) { \n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">mem_fun1_t</span>&lt;S,T,A&gt;(f);\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">const_mem_fun1_t</span>&lt;S,T,A&gt; <span class=\"pl-en\">mem_fun1</span>(S (T::*f)(A) <span class=\"pl-k\">const</span>) {\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">const_mem_fun1_t</span>&lt;S,T,A&gt;(f);\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">mem_fun1_ref_t</span>&lt;S,T,A&gt; <span class=\"pl-en\">mem_fun1_ref</span>(S (T::*f)(A)) { \n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">mem_fun1_ref_t</span>&lt;S,T,A&gt;(f);\n}\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">S</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>, <span class=\"pl-k\">class</span> <span class=\"pl-en\">A</span>&gt;\n<span class=\"pl-k\">inline</span> <span class=\"pl-c1\">const_mem_fun1_ref_t</span>&lt;S,T,A&gt; <span class=\"pl-en\">mem_fun1_ref</span>(S (T::*f)(A) <span class=\"pl-k\">const</span>) {\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">const_mem_fun1_ref_t</span>&lt;S,T,A&gt;(f);\n}\n</pre></div>\n</article>","renderedFileInfo":null,"shortPath":null,"tabSize":8,"topBannersInfo":{"overridingGlobalFundingFile":false,"globalPreferredFundingPath":null,"repoOwner":"arkingc","repoName":"note","showInvalidCitationWarning":false,"citationHelpUrl":"https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/about-citation-files","showDependabotConfigurationBanner":false,"actionsOnboardingTip":null},"truncated":false,"viewable":true,"workflowRedirectUrl":null,"symbols":{"timedOut":true,"notAnalyzed":false,"symbols":[{"name":" 一.简介","kind":"section_1","identStart":3151,"identEnd":3162,"extentStart":3150,"extentEnd":8972,"fullyQualifiedName":" 一.简介","identUtf16":{"start":{"lineNumber":68,"utf16Col":1},"end":{"lineNumber":68,"utf16Col":6}},"extentUtf16":{"start":{"lineNumber":68,"utf16Col":0},"end":{"lineNumber":151,"utf16Col":0}}},{"name":" 1.GNU源代码开放精神","kind":"section_2","identStart":3166,"identEnd":3193,"extentStart":3164,"extentEnd":5293,"fullyQualifiedName":" 1.GNU源代码开放精神","identUtf16":{"start":{"lineNumber":70,"utf16Col":2},"end":{"lineNumber":70,"utf16Col":15}},"extentUtf16":{"start":{"lineNumber":70,"utf16Col":0},"end":{"lineNumber":82,"utf16Col":0}}},{"name":" 2.STL版本","kind":"section_2","identStart":5295,"identEnd":5307,"extentStart":5293,"extentEnd":6813,"fullyQualifiedName":" 2.STL版本","identUtf16":{"start":{"lineNumber":82,"utf16Col":2},"end":{"lineNumber":82,"utf16Col":10}},"extentUtf16":{"start":{"lineNumber":82,"utf16Col":0},"end":{"lineNumber":111,"utf16Col":0}}},{"name":" 3.SGI STL头文件分布","kind":"section_2","identStart":6815,"identEnd":6840,"extentStart":6813,"extentEnd":8682,"fullyQualifiedName":" 3.SGI STL头文件分布","identUtf16":{"start":{"lineNumber":111,"utf16Col":2},"end":{"lineNumber":111,"utf16Col":17}},"extentUtf16":{"start":{"lineNumber":111,"utf16Col":0},"end":{"lineNumber":136,"utf16Col":0}}},{"name":" 4.STL六大部件","kind":"section_2","identStart":8684,"identEnd":8702,"extentStart":8682,"extentEnd":8972,"fullyQualifiedName":" 4.STL六大部件","identUtf16":{"start":{"lineNumber":136,"utf16Col":2},"end":{"lineNumber":136,"utf16Col":12}},"extentUtf16":{"start":{"lineNumber":136,"utf16Col":0},"end":{"lineNumber":151,"utf16Col":0}}},{"name":" 二.空间分配器","kind":"section_1","identStart":8973,"identEnd":8993,"extentStart":8972,"extentEnd":26567,"fullyQualifiedName":" 二.空间分配器","identUtf16":{"start":{"lineNumber":151,"utf16Col":1},"end":{"lineNumber":151,"utf16Col":9}},"extentUtf16":{"start":{"lineNumber":151,"utf16Col":0},"end":{"lineNumber":537,"utf16Col":0}}},{"name":" 1.空间分配器的标准接口","kind":"section_2","identStart":9361,"identEnd":9394,"extentStart":9359,"extentEnd":11673,"fullyQualifiedName":" 1.空间分配器的标准接口","identUtf16":{"start":{"lineNumber":157,"utf16Col":2},"end":{"lineNumber":157,"utf16Col":15}},"extentUtf16":{"start":{"lineNumber":157,"utf16Col":0},"end":{"lineNumber":224,"utf16Col":0}}},{"name":" 2.SGI标准的空间分配器std::allocator","kind":"section_2","identStart":11675,"identEnd":11719,"extentStart":11673,"extentEnd":12024,"fullyQualifiedName":" 2.SGI标准的空间分配器std::allocator","identUtf16":{"start":{"lineNumber":224,"utf16Col":2},"end":{"lineNumber":224,"utf16Col":30}},"extentUtf16":{"start":{"lineNumber":224,"utf16Col":0},"end":{"lineNumber":228,"utf16Col":0}}},{"name":" 3.SGI特殊的空间分配器std::alloc","kind":"section_2","identStart":12026,"identEnd":12066,"extentStart":12024,"extentEnd":26567,"fullyQualifiedName":" 3.SGI特殊的空间分配器std::alloc","identUtf16":{"start":{"lineNumber":228,"utf16Col":2},"end":{"lineNumber":228,"utf16Col":26}},"extentUtf16":{"start":{"lineNumber":228,"utf16Col":0},"end":{"lineNumber":537,"utf16Col":0}}},{"name":" 3.1 对象构造与析构","kind":"section_3","identStart":12397,"identEnd":12423,"extentStart":12394,"extentEnd":12915,"fullyQualifiedName":" 3.1 对象构造与析构","identUtf16":{"start":{"lineNumber":236,"utf16Col":3},"end":{"lineNumber":236,"utf16Col":15}},"extentUtf16":{"start":{"lineNumber":236,"utf16Col":0},"end":{"lineNumber":244,"utf16Col":0}}},{"name":" 3.2 内存分配与释放","kind":"section_3","identStart":12918,"identEnd":12944,"extentStart":12915,"extentEnd":25248,"fullyQualifiedName":" 3.2 内存分配与释放","identUtf16":{"start":{"lineNumber":244,"utf16Col":3},"end":{"lineNumber":244,"utf16Col":15}},"extentUtf16":{"start":{"lineNumber":244,"utf16Col":0},"end":{"lineNumber":516,"utf16Col":0}}},{"name":" 1）两级分配器","kind":"section_4","identStart":13424,"identEnd":13444,"extentStart":13420,"extentEnd":14993,"fullyQualifiedName":" 1）两级分配器","identUtf16":{"start":{"lineNumber":255,"utf16Col":4},"end":{"lineNumber":255,"utf16Col":12}},"extentUtf16":{"start":{"lineNumber":255,"utf16Col":0},"end":{"lineNumber":293,"utf16Col":0}}},{"name":" 2）第一级分配器__malloc_alloc_template","kind":"section_4","identStart":14997,"identEnd":15043,"extentStart":14993,"extentEnd":18366,"fullyQualifiedName":" 2）第一级分配器__malloc_alloc_template","identUtf16":{"start":{"lineNumber":293,"utf16Col":4},"end":{"lineNumber":293,"utf16Col":36}},"extentUtf16":{"start":{"lineNumber":293,"utf16Col":0},"end":{"lineNumber":388,"utf16Col":0}}},{"name":" 3）第二级分配器__default_alloc_template","kind":"section_4","identStart":18370,"identEnd":18417,"extentStart":18366,"extentEnd":25248,"fullyQualifiedName":" 3）第二级分配器__default_alloc_template","identUtf16":{"start":{"lineNumber":388,"utf16Col":4},"end":{"lineNumber":388,"utf16Col":37}},"extentUtf16":{"start":{"lineNumber":388,"utf16Col":0},"end":{"lineNumber":516,"utf16Col":0}}},{"name":" 3.3 内存基本处理工具","kind":"section_3","identStart":25251,"identEnd":25280,"extentStart":25248,"extentEnd":26567,"fullyQualifiedName":" 3.3 内存基本处理工具","identUtf16":{"start":{"lineNumber":516,"utf16Col":3},"end":{"lineNumber":516,"utf16Col":16}},"extentUtf16":{"start":{"lineNumber":516,"utf16Col":0},"end":{"lineNumber":537,"utf16Col":0}}},{"name":" 三.迭代器与traits编程技法","kind":"section_1","identStart":26568,"identEnd":26603,"extentStart":26567,"extentEnd":35396,"fullyQualifiedName":" 三.迭代器与traits编程技法","identUtf16":{"start":{"lineNumber":537,"utf16Col":1},"end":{"lineNumber":537,"utf16Col":18}},"extentUtf16":{"start":{"lineNumber":537,"utf16Col":0},"end":{"lineNumber":715,"utf16Col":0}}},{"name":" 1.迭代器相应类型","kind":"section_2","identStart":26607,"identEnd":26631,"extentStart":26605,"extentEnd":28094,"fullyQualifiedName":" 1.迭代器相应类型","identUtf16":{"start":{"lineNumber":539,"utf16Col":2},"end":{"lineNumber":539,"utf16Col":12}},"extentUtf16":{"start":{"lineNumber":539,"utf16Col":0},"end":{"lineNumber":554,"utf16Col":0}}},{"name":" 2.traits编程技法","kind":"section_2","identStart":28096,"identEnd":28117,"extentStart":28094,"extentEnd":32991,"fullyQualifiedName":" 2.traits编程技法","identUtf16":{"start":{"lineNumber":554,"utf16Col":2},"end":{"lineNumber":554,"utf16Col":15}},"extentUtf16":{"start":{"lineNumber":554,"utf16Col":0},"end":{"lineNumber":661,"utf16Col":0}}},{"name":" 2.1 迭代器类型","kind":"section_3","identStart":31758,"identEnd":31778,"extentStart":31755,"extentEnd":32991,"fullyQualifiedName":" 2.1 迭代器类型","identUtf16":{"start":{"lineNumber":645,"utf16Col":3},"end":{"lineNumber":645,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":645,"utf16Col":0},"end":{"lineNumber":661,"utf16Col":0}}},{"name":" 3.std::iterator的保证","kind":"section_2","identStart":32993,"identEnd":33018,"extentStart":32991,"extentEnd":34100,"fullyQualifiedName":" 3.std::iterator的保证","identUtf16":{"start":{"lineNumber":661,"utf16Col":2},"end":{"lineNumber":661,"utf16Col":21}},"extentUtf16":{"start":{"lineNumber":661,"utf16Col":0},"end":{"lineNumber":689,"utf16Col":0}}},{"name":" 4.SGI STL的__type_traits","kind":"section_2","identStart":34102,"identEnd":34128,"extentStart":34100,"extentEnd":35396,"fullyQualifiedName":" 4.SGI STL的__type_traits","identUtf16":{"start":{"lineNumber":689,"utf16Col":2},"end":{"lineNumber":689,"utf16Col":26}},"extentUtf16":{"start":{"lineNumber":689,"utf16Col":0},"end":{"lineNumber":715,"utf16Col":0}}},{"name":" 四.顺序容器","kind":"section_1","identStart":35397,"identEnd":35414,"extentStart":35396,"extentEnd":59639,"fullyQualifiedName":" 四.顺序容器","identUtf16":{"start":{"lineNumber":715,"utf16Col":1},"end":{"lineNumber":715,"utf16Col":8}},"extentUtf16":{"start":{"lineNumber":715,"utf16Col":0},"end":{"lineNumber":1354,"utf16Col":0}}},{"name":" 1.vector","kind":"section_2","identStart":35724,"identEnd":35733,"extentStart":35722,"extentEnd":38054,"fullyQualifiedName":" 1.vector","identUtf16":{"start":{"lineNumber":721,"utf16Col":2},"end":{"lineNumber":721,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":721,"utf16Col":0},"end":{"lineNumber":774,"utf16Col":0}}},{"name":" 1.1 迭代器","kind":"section_3","identStart":36060,"identEnd":36074,"extentStart":36057,"extentEnd":36735,"fullyQualifiedName":" 1.1 迭代器","identUtf16":{"start":{"lineNumber":729,"utf16Col":3},"end":{"lineNumber":729,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":729,"utf16Col":0},"end":{"lineNumber":743,"utf16Col":0}}},{"name":" 1.2 分配器","kind":"section_3","identStart":36738,"identEnd":36752,"extentStart":36735,"extentEnd":37108,"fullyQualifiedName":" 1.2 分配器","identUtf16":{"start":{"lineNumber":743,"utf16Col":3},"end":{"lineNumber":743,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":743,"utf16Col":0},"end":{"lineNumber":758,"utf16Col":0}}},{"name":" 1.3 vector操作的实现","kind":"section_3","identStart":37111,"identEnd":37137,"extentStart":37108,"extentEnd":38054,"fullyQualifiedName":" 1.3 vector操作的实现","identUtf16":{"start":{"lineNumber":758,"utf16Col":3},"end":{"lineNumber":758,"utf16Col":19}},"extentUtf16":{"start":{"lineNumber":758,"utf16Col":0},"end":{"lineNumber":774,"utf16Col":0}}},{"name":" 2.list","kind":"section_2","identStart":38056,"identEnd":38063,"extentStart":38054,"extentEnd":43343,"fullyQualifiedName":" 2.list","identUtf16":{"start":{"lineNumber":774,"utf16Col":2},"end":{"lineNumber":774,"utf16Col":9}},"extentUtf16":{"start":{"lineNumber":774,"utf16Col":0},"end":{"lineNumber":922,"utf16Col":0}}},{"name":" 2.1 节点","kind":"section_3","identStart":38140,"identEnd":38151,"extentStart":38137,"extentEnd":38376,"fullyQualifiedName":" 2.1 节点","identUtf16":{"start":{"lineNumber":778,"utf16Col":3},"end":{"lineNumber":778,"utf16Col":10}},"extentUtf16":{"start":{"lineNumber":778,"utf16Col":0},"end":{"lineNumber":792,"utf16Col":0}}},{"name":" 2.2 迭代器","kind":"section_3","identStart":38379,"identEnd":38393,"extentStart":38376,"extentEnd":40665,"fullyQualifiedName":" 2.2 迭代器","identUtf16":{"start":{"lineNumber":792,"utf16Col":3},"end":{"lineNumber":792,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":792,"utf16Col":0},"end":{"lineNumber":859,"utf16Col":0}}},{"name":" 2.3 list的数据结构","kind":"section_3","identStart":40668,"identEnd":40692,"extentStart":40665,"extentEnd":41343,"fullyQualifiedName":" 2.3 list的数据结构","identUtf16":{"start":{"lineNumber":859,"utf16Col":3},"end":{"lineNumber":859,"utf16Col":17}},"extentUtf16":{"start":{"lineNumber":859,"utf16Col":0},"end":{"lineNumber":886,"utf16Col":0}}},{"name":" 2.4 分配器","kind":"section_3","identStart":41346,"identEnd":41360,"extentStart":41343,"extentEnd":41730,"fullyQualifiedName":" 2.4 分配器","identUtf16":{"start":{"lineNumber":886,"utf16Col":3},"end":{"lineNumber":886,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":886,"utf16Col":0},"end":{"lineNumber":901,"utf16Col":0}}},{"name":" 2.5 list操作的实现","kind":"section_3","identStart":41733,"identEnd":41757,"extentStart":41730,"extentEnd":43343,"fullyQualifiedName":" 2.5 list操作的实现","identUtf16":{"start":{"lineNumber":901,"utf16Col":3},"end":{"lineNumber":901,"utf16Col":17}},"extentUtf16":{"start":{"lineNumber":901,"utf16Col":0},"end":{"lineNumber":922,"utf16Col":0}}},{"name":" 3.deque","kind":"section_2","identStart":43345,"identEnd":43353,"extentStart":43343,"extentEnd":50046,"fullyQualifiedName":" 3.deque","identUtf16":{"start":{"lineNumber":922,"utf16Col":2},"end":{"lineNumber":922,"utf16Col":10}},"extentUtf16":{"start":{"lineNumber":922,"utf16Col":0},"end":{"lineNumber":1054,"utf16Col":0}}},{"name":" 3.1 迭代器","kind":"section_3","identStart":43723,"identEnd":43737,"extentStart":43720,"extentEnd":46133,"fullyQualifiedName":" 3.1 迭代器","identUtf16":{"start":{"lineNumber":931,"utf16Col":3},"end":{"lineNumber":931,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":931,"utf16Col":0},"end":{"lineNumber":977,"utf16Col":0}}},{"name":" 3.3 deque的数据结构","kind":"section_3","identStart":46136,"identEnd":46161,"extentStart":46133,"extentEnd":47783,"fullyQualifiedName":" 3.3 deque的数据结构","identUtf16":{"start":{"lineNumber":977,"utf16Col":3},"end":{"lineNumber":977,"utf16Col":18}},"extentUtf16":{"start":{"lineNumber":977,"utf16Col":0},"end":{"lineNumber":1016,"utf16Col":0}}},{"name":" 3.4 分配器","kind":"section_3","identStart":47786,"identEnd":47800,"extentStart":47783,"extentEnd":48120,"fullyQualifiedName":" 3.4 分配器","identUtf16":{"start":{"lineNumber":1016,"utf16Col":3},"end":{"lineNumber":1016,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":1016,"utf16Col":0},"end":{"lineNumber":1028,"utf16Col":0}}},{"name":" 3.5 deque操作的实现","kind":"section_3","identStart":48123,"identEnd":48148,"extentStart":48120,"extentEnd":50046,"fullyQualifiedName":" 3.5 deque操作的实现","identUtf16":{"start":{"lineNumber":1028,"utf16Col":3},"end":{"lineNumber":1028,"utf16Col":18}},"extentUtf16":{"start":{"lineNumber":1028,"utf16Col":0},"end":{"lineNumber":1054,"utf16Col":0}}},{"name":" 4.stack","kind":"section_2","identStart":50048,"identEnd":50056,"extentStart":50046,"extentEnd":51706,"fullyQualifiedName":" 4.stack","identUtf16":{"start":{"lineNumber":1054,"utf16Col":2},"end":{"lineNumber":1054,"utf16Col":10}},"extentUtf16":{"start":{"lineNumber":1054,"utf16Col":0},"end":{"lineNumber":1103,"utf16Col":0}}},{"name":" 5.queue","kind":"section_2","identStart":51708,"identEnd":51716,"extentStart":51706,"extentEnd":53395,"fullyQualifiedName":" 5.queue","identUtf16":{"start":{"lineNumber":1103,"utf16Col":2},"end":{"lineNumber":1103,"utf16Col":10}},"extentUtf16":{"start":{"lineNumber":1103,"utf16Col":0},"end":{"lineNumber":1154,"utf16Col":0}}},{"name":" 6.heap","kind":"section_2","identStart":53397,"identEnd":53404,"extentStart":53395,"extentEnd":54606,"fullyQualifiedName":" 6.heap","identUtf16":{"start":{"lineNumber":1154,"utf16Col":2},"end":{"lineNumber":1154,"utf16Col":9}},"extentUtf16":{"start":{"lineNumber":1154,"utf16Col":0},"end":{"lineNumber":1180,"utf16Col":0}}},{"name":" 7.priority_queue","kind":"section_2","identStart":54608,"identEnd":54625,"extentStart":54606,"extentEnd":56761,"fullyQualifiedName":" 7.priority_queue","identUtf16":{"start":{"lineNumber":1180,"utf16Col":2},"end":{"lineNumber":1180,"utf16Col":19}},"extentUtf16":{"start":{"lineNumber":1180,"utf16Col":0},"end":{"lineNumber":1237,"utf16Col":0}}},{"name":" 8.slist","kind":"section_2","identStart":56763,"identEnd":56771,"extentStart":56761,"extentEnd":59639,"fullyQualifiedName":" 8.slist","identUtf16":{"start":{"lineNumber":1237,"utf16Col":2},"end":{"lineNumber":1237,"utf16Col":10}},"extentUtf16":{"start":{"lineNumber":1237,"utf16Col":0},"end":{"lineNumber":1354,"utf16Col":0}}},{"name":" 8.1 slist的节点","kind":"section_3","identStart":57055,"identEnd":57074,"extentStart":57052,"extentEnd":58024,"fullyQualifiedName":" 8.1 slist的节点","identUtf16":{"start":{"lineNumber":1245,"utf16Col":3},"end":{"lineNumber":1245,"utf16Col":16}},"extentUtf16":{"start":{"lineNumber":1245,"utf16Col":0},"end":{"lineNumber":1290,"utf16Col":0}}},{"name":" 8.2 slist的迭代器","kind":"section_3","identStart":58027,"identEnd":58049,"extentStart":58024,"extentEnd":59639,"fullyQualifiedName":" 8.2 slist的迭代器","identUtf16":{"start":{"lineNumber":1290,"utf16Col":3},"end":{"lineNumber":1290,"utf16Col":17}},"extentUtf16":{"start":{"lineNumber":1290,"utf16Col":0},"end":{"lineNumber":1354,"utf16Col":0}}},{"name":" 五.关联容器","kind":"section_1","identStart":59640,"identEnd":59657,"extentStart":59639,"extentEnd":79338,"fullyQualifiedName":" 五.关联容器","identUtf16":{"start":{"lineNumber":1354,"utf16Col":1},"end":{"lineNumber":1354,"utf16Col":8}},"extentUtf16":{"start":{"lineNumber":1354,"utf16Col":0},"end":{"lineNumber":1882,"utf16Col":0}}},{"name":" 1.RB-tree","kind":"section_2","identStart":60267,"identEnd":60277,"extentStart":60265,"extentEnd":66952,"fullyQualifiedName":" 1.RB-tree","identUtf16":{"start":{"lineNumber":1362,"utf16Col":2},"end":{"lineNumber":1362,"utf16Col":12}},"extentUtf16":{"start":{"lineNumber":1362,"utf16Col":0},"end":{"lineNumber":1548,"utf16Col":0}}},{"name":" 1.1 RB-tree的节点","kind":"section_3","identStart":60282,"identEnd":60303,"extentStart":60279,"extentEnd":61379,"fullyQualifiedName":" 1.1 RB-tree的节点","identUtf16":{"start":{"lineNumber":1364,"utf16Col":3},"end":{"lineNumber":1364,"utf16Col":18}},"extentUtf16":{"start":{"lineNumber":1364,"utf16Col":0},"end":{"lineNumber":1408,"utf16Col":0}}},{"name":" 1.2 RB-tree的迭代器","kind":"section_3","identStart":61382,"identEnd":61406,"extentStart":61379,"extentEnd":64642,"fullyQualifiedName":" 1.2 RB-tree的迭代器","identUtf16":{"start":{"lineNumber":1408,"utf16Col":3},"end":{"lineNumber":1408,"utf16Col":19}},"extentUtf16":{"start":{"lineNumber":1408,"utf16Col":0},"end":{"lineNumber":1506,"utf16Col":0}}},{"name":" 1.3 RB-tree操作的实现","kind":"section_3","identStart":64645,"identEnd":64672,"extentStart":64642,"extentEnd":66952,"fullyQualifiedName":" 1.3 RB-tree操作的实现","identUtf16":{"start":{"lineNumber":1506,"utf16Col":3},"end":{"lineNumber":1506,"utf16Col":20}},"extentUtf16":{"start":{"lineNumber":1506,"utf16Col":0},"end":{"lineNumber":1548,"utf16Col":0}}},{"name":" 2.set","kind":"section_2","identStart":66954,"identEnd":66960,"extentStart":66952,"extentEnd":68197,"fullyQualifiedName":" 2.set","identUtf16":{"start":{"lineNumber":1548,"utf16Col":2},"end":{"lineNumber":1548,"utf16Col":8}},"extentUtf16":{"start":{"lineNumber":1548,"utf16Col":0},"end":{"lineNumber":1581,"utf16Col":0}}},{"name":" 3.map","kind":"section_2","identStart":68199,"identEnd":68205,"extentStart":68197,"extentEnd":69636,"fullyQualifiedName":" 3.map","identUtf16":{"start":{"lineNumber":1581,"utf16Col":2},"end":{"lineNumber":1581,"utf16Col":8}},"extentUtf16":{"start":{"lineNumber":1581,"utf16Col":0},"end":{"lineNumber":1625,"utf16Col":0}}},{"name":" 4.multiset","kind":"section_2","identStart":69638,"identEnd":69649,"extentStart":69636,"extentEnd":69900,"fullyQualifiedName":" 4.multiset","identUtf16":{"start":{"lineNumber":1625,"utf16Col":2},"end":{"lineNumber":1625,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":1625,"utf16Col":0},"end":{"lineNumber":1631,"utf16Col":0}}},{"name":" 5.multimap","kind":"section_2","identStart":69902,"identEnd":69913,"extentStart":69900,"extentEnd":70164,"fullyQualifiedName":" 5.multimap","identUtf16":{"start":{"lineNumber":1631,"utf16Col":2},"end":{"lineNumber":1631,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":1631,"utf16Col":0},"end":{"lineNumber":1637,"utf16Col":0}}},{"name":" 6.hashtable","kind":"section_2","identStart":70166,"identEnd":70178,"extentStart":70164,"extentEnd":78215,"fullyQualifiedName":" 6.hashtable","identUtf16":{"start":{"lineNumber":1637,"utf16Col":2},"end":{"lineNumber":1637,"utf16Col":14}},"extentUtf16":{"start":{"lineNumber":1637,"utf16Col":0},"end":{"lineNumber":1856,"utf16Col":0}}},{"name":" 6.1 hashtable的迭代器","kind":"section_3","identStart":70506,"identEnd":70532,"extentStart":70503,"extentEnd":72958,"fullyQualifiedName":" 6.1 hashtable的迭代器","identUtf16":{"start":{"lineNumber":1652,"utf16Col":3},"end":{"lineNumber":1652,"utf16Col":21}},"extentUtf16":{"start":{"lineNumber":1652,"utf16Col":0},"end":{"lineNumber":1719,"utf16Col":0}}},{"name":" 6.2 hashtable的实现","kind":"section_3","identStart":72961,"identEnd":72984,"extentStart":72958,"extentEnd":74842,"fullyQualifiedName":" 6.2 hashtable的实现","identUtf16":{"start":{"lineNumber":1719,"utf16Col":3},"end":{"lineNumber":1719,"utf16Col":20}},"extentUtf16":{"start":{"lineNumber":1719,"utf16Col":0},"end":{"lineNumber":1777,"utf16Col":0}}},{"name":" 6.3 hashtable操作的实现","kind":"section_3","identStart":74845,"identEnd":74874,"extentStart":74842,"extentEnd":76593,"fullyQualifiedName":" 6.3 hashtable操作的实现","identUtf16":{"start":{"lineNumber":1777,"utf16Col":3},"end":{"lineNumber":1777,"utf16Col":22}},"extentUtf16":{"start":{"lineNumber":1777,"utf16Col":0},"end":{"lineNumber":1803,"utf16Col":0}}},{"name":" 6.4 hash functions","kind":"section_3","identStart":76596,"identEnd":76615,"extentStart":76593,"extentEnd":78215,"fullyQualifiedName":" 6.4 hash functions","identUtf16":{"start":{"lineNumber":1803,"utf16Col":3},"end":{"lineNumber":1803,"utf16Col":22}},"extentUtf16":{"start":{"lineNumber":1803,"utf16Col":0},"end":{"lineNumber":1856,"utf16Col":0}}},{"name":" 7.hash_set","kind":"section_2","identStart":78217,"identEnd":78228,"extentStart":78215,"extentEnd":78503,"fullyQualifiedName":" 7.hash_set","identUtf16":{"start":{"lineNumber":1856,"utf16Col":2},"end":{"lineNumber":1856,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":1856,"utf16Col":0},"end":{"lineNumber":1862,"utf16Col":0}}},{"name":" 8.hash_map","kind":"section_2","identStart":78505,"identEnd":78516,"extentStart":78503,"extentEnd":78791,"fullyQualifiedName":" 8.hash_map","identUtf16":{"start":{"lineNumber":1862,"utf16Col":2},"end":{"lineNumber":1862,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":1862,"utf16Col":0},"end":{"lineNumber":1868,"utf16Col":0}}},{"name":" 9.hash_multiset","kind":"section_2","identStart":78793,"identEnd":78809,"extentStart":78791,"extentEnd":79061,"fullyQualifiedName":" 9.hash_multiset","identUtf16":{"start":{"lineNumber":1868,"utf16Col":2},"end":{"lineNumber":1868,"utf16Col":18}},"extentUtf16":{"start":{"lineNumber":1868,"utf16Col":0},"end":{"lineNumber":1874,"utf16Col":0}}},{"name":" 10.hash_multimap","kind":"section_2","identStart":79063,"identEnd":79080,"extentStart":79061,"extentEnd":79338,"fullyQualifiedName":" 10.hash_multimap","identUtf16":{"start":{"lineNumber":1874,"utf16Col":2},"end":{"lineNumber":1874,"utf16Col":19}},"extentUtf16":{"start":{"lineNumber":1874,"utf16Col":0},"end":{"lineNumber":1882,"utf16Col":0}}},{"name":" 六.算法","kind":"section_1","identStart":79339,"identEnd":79350,"extentStart":79338,"extentEnd":98052,"fullyQualifiedName":" 六.算法","identUtf16":{"start":{"lineNumber":1882,"utf16Col":1},"end":{"lineNumber":1882,"utf16Col":6}},"extentUtf16":{"start":{"lineNumber":1882,"utf16Col":0},"end":{"lineNumber":2160,"utf16Col":0}}},{"name":" 1.区间拷贝","kind":"section_2","identStart":79595,"identEnd":79610,"extentStart":79593,"extentEnd":82505,"fullyQualifiedName":" 1.区间拷贝","identUtf16":{"start":{"lineNumber":1889,"utf16Col":2},"end":{"lineNumber":1889,"utf16Col":9}},"extentUtf16":{"start":{"lineNumber":1889,"utf16Col":0},"end":{"lineNumber":1929,"utf16Col":0}}},{"name":" 1.1 copy","kind":"section_3","identStart":79615,"identEnd":79624,"extentStart":79612,"extentEnd":81998,"fullyQualifiedName":" 1.1 copy","identUtf16":{"start":{"lineNumber":1891,"utf16Col":3},"end":{"lineNumber":1891,"utf16Col":12}},"extentUtf16":{"start":{"lineNumber":1891,"utf16Col":0},"end":{"lineNumber":1921,"utf16Col":0}}},{"name":" 1.2 copy_backward","kind":"section_3","identStart":82001,"identEnd":82019,"extentStart":81998,"extentEnd":82505,"fullyQualifiedName":" 1.2 copy_backward","identUtf16":{"start":{"lineNumber":1921,"utf16Col":3},"end":{"lineNumber":1921,"utf16Col":21}},"extentUtf16":{"start":{"lineNumber":1921,"utf16Col":0},"end":{"lineNumber":1929,"utf16Col":0}}},{"name":" 2.set相关算法","kind":"section_2","identStart":82507,"identEnd":82525,"extentStart":82505,"extentEnd":84881,"fullyQualifiedName":" 2.set相关算法","identUtf16":{"start":{"lineNumber":1929,"utf16Col":2},"end":{"lineNumber":1929,"utf16Col":12}},"extentUtf16":{"start":{"lineNumber":1929,"utf16Col":0},"end":{"lineNumber":1969,"utf16Col":0}}},{"name":" 2.1 set_union","kind":"section_3","identStart":82886,"identEnd":82900,"extentStart":82883,"extentEnd":83371,"fullyQualifiedName":" 2.1 set_union","identUtf16":{"start":{"lineNumber":1933,"utf16Col":3},"end":{"lineNumber":1933,"utf16Col":17}},"extentUtf16":{"start":{"lineNumber":1933,"utf16Col":0},"end":{"lineNumber":1943,"utf16Col":0}}},{"name":" 2.2 set_intersection","kind":"section_3","identStart":83374,"identEnd":83395,"extentStart":83371,"extentEnd":83715,"fullyQualifiedName":" 2.2 set_intersection","identUtf16":{"start":{"lineNumber":1943,"utf16Col":3},"end":{"lineNumber":1943,"utf16Col":24}},"extentUtf16":{"start":{"lineNumber":1943,"utf16Col":0},"end":{"lineNumber":1951,"utf16Col":0}}},{"name":" 2.3 set_difference","kind":"section_3","identStart":83718,"identEnd":83737,"extentStart":83715,"extentEnd":84185,"fullyQualifiedName":" 2.3 set_difference","identUtf16":{"start":{"lineNumber":1951,"utf16Col":3},"end":{"lineNumber":1951,"utf16Col":22}},"extentUtf16":{"start":{"lineNumber":1951,"utf16Col":0},"end":{"lineNumber":1959,"utf16Col":0}}},{"name":" 2.4 set_symmetric_difference","kind":"section_3","identStart":84188,"identEnd":84217,"extentStart":84185,"extentEnd":84881,"fullyQualifiedName":" 2.4 set_symmetric_difference","identUtf16":{"start":{"lineNumber":1959,"utf16Col":3},"end":{"lineNumber":1959,"utf16Col":32}},"extentUtf16":{"start":{"lineNumber":1959,"utf16Col":0},"end":{"lineNumber":1969,"utf16Col":0}}},{"name":" 3.排序sort","kind":"section_2","identStart":84883,"identEnd":84896,"extentStart":84881,"extentEnd":86542,"fullyQualifiedName":" 3.排序sort","identUtf16":{"start":{"lineNumber":1969,"utf16Col":2},"end":{"lineNumber":1969,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":1969,"utf16Col":0},"end":{"lineNumber":1994,"utf16Col":0}}},{"name":" 4.其它算法","kind":"section_2","identStart":86544,"identEnd":86559,"extentStart":86542,"extentEnd":98052,"fullyQualifiedName":" 4.其它算法","identUtf16":{"start":{"lineNumber":1994,"utf16Col":2},"end":{"lineNumber":1994,"utf16Col":9}},"extentUtf16":{"start":{"lineNumber":1994,"utf16Col":0},"end":{"lineNumber":2160,"utf16Col":0}}},{"name":" 七.仿函数","kind":"section_1","identStart":98053,"identEnd":98067,"extentStart":98052,"extentEnd":105140,"fullyQualifiedName":" 七.仿函数","identUtf16":{"start":{"lineNumber":2160,"utf16Col":1},"end":{"lineNumber":2160,"utf16Col":7}},"extentUtf16":{"start":{"lineNumber":2160,"utf16Col":0},"end":{"lineNumber":2367,"utf16Col":0}}},{"name":" 1.仿函数的相应类型","kind":"section_2","identStart":99046,"identEnd":99073,"extentStart":99044,"extentEnd":100453,"fullyQualifiedName":" 1.仿函数的相应类型","identUtf16":{"start":{"lineNumber":2174,"utf16Col":2},"end":{"lineNumber":2174,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":2174,"utf16Col":0},"end":{"lineNumber":2207,"utf16Col":0}}},{"name":" 1.1 unary_function","kind":"section_3","identStart":99884,"identEnd":99903,"extentStart":99881,"extentEnd":100118,"fullyQualifiedName":" 1.1 unary_function","identUtf16":{"start":{"lineNumber":2182,"utf16Col":3},"end":{"lineNumber":2182,"utf16Col":22}},"extentUtf16":{"start":{"lineNumber":2182,"utf16Col":0},"end":{"lineNumber":2194,"utf16Col":0}}},{"name":" 1.2 binary_function","kind":"section_3","identStart":100121,"identEnd":100141,"extentStart":100118,"extentEnd":100453,"fullyQualifiedName":" 1.2 binary_function","identUtf16":{"start":{"lineNumber":2194,"utf16Col":3},"end":{"lineNumber":2194,"utf16Col":23}},"extentUtf16":{"start":{"lineNumber":2194,"utf16Col":0},"end":{"lineNumber":2207,"utf16Col":0}}},{"name":" 2.算术类仿函数","kind":"section_2","identStart":100455,"identEnd":100476,"extentStart":100453,"extentEnd":101562,"fullyQualifiedName":" 2.算术类仿函数","identUtf16":{"start":{"lineNumber":2207,"utf16Col":2},"end":{"lineNumber":2207,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":2207,"utf16Col":0},"end":{"lineNumber":2250,"utf16Col":0}}},{"name":" 3.关系运算类仿函数","kind":"section_2","identStart":101564,"identEnd":101591,"extentStart":101562,"extentEnd":102754,"fullyQualifiedName":" 3.关系运算类仿函数","identUtf16":{"start":{"lineNumber":2250,"utf16Col":2},"end":{"lineNumber":2250,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":2250,"utf16Col":0},"end":{"lineNumber":2293,"utf16Col":0}}},{"name":" 4.逻辑运算类仿函数","kind":"section_2","identStart":102756,"identEnd":102783,"extentStart":102754,"extentEnd":103447,"fullyQualifiedName":" 4.逻辑运算类仿函数","identUtf16":{"start":{"lineNumber":2293,"utf16Col":2},"end":{"lineNumber":2293,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":2293,"utf16Col":0},"end":{"lineNumber":2318,"utf16Col":0}}},{"name":" 5.证同，选择与投射","kind":"section_2","identStart":103449,"identEnd":103476,"extentStart":103447,"extentEnd":105140,"fullyQualifiedName":" 5.证同，选择与投射","identUtf16":{"start":{"lineNumber":2318,"utf16Col":2},"end":{"lineNumber":2318,"utf16Col":13}},"extentUtf16":{"start":{"lineNumber":2318,"utf16Col":0},"end":{"lineNumber":2367,"utf16Col":0}}},{"name":" 八.适配器","kind":"section_1","identStart":105141,"identEnd":105155,"extentStart":105140,"extentEnd":133951,"fullyQualifiedName":" 八.适配器","identUtf16":{"start":{"lineNumber":2367,"utf16Col":1},"end":{"lineNumber":2367,"utf16Col":7}},"extentUtf16":{"start":{"lineNumber":2367,"utf16Col":0},"end":{"lineNumber":3131,"utf16Col":0}}},{"name":" 1.容器适配器","kind":"section_2","identStart":105451,"identEnd":105469,"extentStart":105449,"extentEnd":105859,"fullyQualifiedName":" 1.容器适配器","identUtf16":{"start":{"lineNumber":2373,"utf16Col":2},"end":{"lineNumber":2373,"utf16Col":10}},"extentUtf16":{"start":{"lineNumber":2373,"utf16Col":0},"end":{"lineNumber":2383,"utf16Col":0}}},{"name":" 2.迭代器适配器","kind":"section_2","identStart":105861,"identEnd":105882,"extentStart":105859,"extentEnd":120191,"fullyQualifiedName":" 2.迭代器适配器","identUtf16":{"start":{"lineNumber":2383,"utf16Col":2},"end":{"lineNumber":2383,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":2383,"utf16Col":0},"end":{"lineNumber":2744,"utf16Col":0}}},{"name":" 2.1 insert iterators","kind":"section_3","identStart":107037,"identEnd":107058,"extentStart":107034,"extentEnd":111989,"fullyQualifiedName":" 2.1 insert iterators","identUtf16":{"start":{"lineNumber":2403,"utf16Col":3},"end":{"lineNumber":2403,"utf16Col":24}},"extentUtf16":{"start":{"lineNumber":2403,"utf16Col":0},"end":{"lineNumber":2522,"utf16Col":0}}},{"name":" 1）back_insert_iterator","kind":"section_4","identStart":107652,"identEnd":107677,"extentStart":107648,"extentEnd":108975,"fullyQualifiedName":" 1）back_insert_iterator","identUtf16":{"start":{"lineNumber":2409,"utf16Col":4},"end":{"lineNumber":2409,"utf16Col":27}},"extentUtf16":{"start":{"lineNumber":2409,"utf16Col":0},"end":{"lineNumber":2445,"utf16Col":0}}},{"name":" 2）front_insert_iterator","kind":"section_4","identStart":108979,"identEnd":109005,"extentStart":108975,"extentEnd":110317,"fullyQualifiedName":" 2）front_insert_iterator","identUtf16":{"start":{"lineNumber":2445,"utf16Col":4},"end":{"lineNumber":2445,"utf16Col":28}},"extentUtf16":{"start":{"lineNumber":2445,"utf16Col":0},"end":{"lineNumber":2481,"utf16Col":0}}},{"name":" 3）insert_iterator","kind":"section_4","identStart":110321,"identEnd":110341,"extentStart":110317,"extentEnd":111989,"fullyQualifiedName":" 3）insert_iterator","identUtf16":{"start":{"lineNumber":2481,"utf16Col":4},"end":{"lineNumber":2481,"utf16Col":22}},"extentUtf16":{"start":{"lineNumber":2481,"utf16Col":0},"end":{"lineNumber":2522,"utf16Col":0}}},{"name":" 2.2 reverse iterators","kind":"section_3","identStart":111992,"identEnd":112014,"extentStart":111989,"extentEnd":116142,"fullyQualifiedName":" 2.2 reverse iterators","identUtf16":{"start":{"lineNumber":2522,"utf16Col":3},"end":{"lineNumber":2522,"utf16Col":25}},"extentUtf16":{"start":{"lineNumber":2522,"utf16Col":0},"end":{"lineNumber":2647,"utf16Col":0}}},{"name":" 2.3 iostream iterators","kind":"section_3","identStart":116145,"identEnd":116168,"extentStart":116142,"extentEnd":120191,"fullyQualifiedName":" 2.3 iostream iterators","identUtf16":{"start":{"lineNumber":2647,"utf16Col":3},"end":{"lineNumber":2647,"utf16Col":26}},"extentUtf16":{"start":{"lineNumber":2647,"utf16Col":0},"end":{"lineNumber":2744,"utf16Col":0}}},{"name":" 1）istream_iterator","kind":"section_4","identStart":116174,"identEnd":116195,"extentStart":116170,"extentEnd":118488,"fullyQualifiedName":" 1）istream_iterator","identUtf16":{"start":{"lineNumber":2649,"utf16Col":4},"end":{"lineNumber":2649,"utf16Col":23}},"extentUtf16":{"start":{"lineNumber":2649,"utf16Col":0},"end":{"lineNumber":2706,"utf16Col":0}}},{"name":" 2）ostream_iterator","kind":"section_4","identStart":118492,"identEnd":118513,"extentStart":118488,"extentEnd":120191,"fullyQualifiedName":" 2）ostream_iterator","identUtf16":{"start":{"lineNumber":2706,"utf16Col":4},"end":{"lineNumber":2706,"utf16Col":23}},"extentUtf16":{"start":{"lineNumber":2706,"utf16Col":0},"end":{"lineNumber":2744,"utf16Col":0}}},{"name":" 3.函数适配器","kind":"section_2","identStart":120193,"identEnd":120211,"extentStart":120191,"extentEnd":133951,"fullyQualifiedName":" 3.函数适配器","identUtf16":{"start":{"lineNumber":2744,"utf16Col":2},"end":{"lineNumber":2744,"utf16Col":10}},"extentUtf16":{"start":{"lineNumber":2744,"utf16Col":0},"end":{"lineNumber":3131,"utf16Col":0}}},{"name":" 3.1 not1和not2","kind":"section_3","identStart":121472,"identEnd":121488,"extentStart":121469,"extentEnd":123005,"fullyQualifiedName":" 3.1 not1和not2","identUtf16":{"start":{"lineNumber":2765,"utf16Col":3},"end":{"lineNumber":2765,"utf16Col":17}},"extentUtf16":{"start":{"lineNumber":2765,"utf16Col":0},"end":{"lineNumber":2816,"utf16Col":0}}},{"name":" 1）not1","kind":"section_4","identStart":121494,"identEnd":121503,"extentStart":121490,"extentEnd":122149,"fullyQualifiedName":" 1）not1","identUtf16":{"start":{"lineNumber":2767,"utf16Col":4},"end":{"lineNumber":2767,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":2767,"utf16Col":0},"end":{"lineNumber":2790,"utf16Col":0}}},{"name":" 2）not2","kind":"section_4","identStart":122153,"identEnd":122162,"extentStart":122149,"extentEnd":123005,"fullyQualifiedName":" 2）not2","identUtf16":{"start":{"lineNumber":2790,"utf16Col":4},"end":{"lineNumber":2790,"utf16Col":11}},"extentUtf16":{"start":{"lineNumber":2790,"utf16Col":0},"end":{"lineNumber":2816,"utf16Col":0}}},{"name":" 3.2 bind1st和bind2st","kind":"section_3","identStart":123008,"identEnd":123030,"extentStart":123005,"extentEnd":125257,"fullyQualifiedName":" 3.2 bind1st和bind2st","identUtf16":{"start":{"lineNumber":2816,"utf16Col":3},"end":{"lineNumber":2816,"utf16Col":23}},"extentUtf16":{"start":{"lineNumber":2816,"utf16Col":0},"end":{"lineNumber":2878,"utf16Col":0}}},{"name":" 1）bind1st","kind":"section_4","identStart":123036,"identEnd":123048,"extentStart":123032,"extentEnd":124145,"fullyQualifiedName":" 1）bind1st","identUtf16":{"start":{"lineNumber":2818,"utf16Col":4},"end":{"lineNumber":2818,"utf16Col":14}},"extentUtf16":{"start":{"lineNumber":2818,"utf16Col":0},"end":{"lineNumber":2848,"utf16Col":0}}},{"name":" 2）bind2st","kind":"section_4","identStart":124149,"identEnd":124161,"extentStart":124145,"extentEnd":125257,"fullyQualifiedName":" 2）bind2st","identUtf16":{"start":{"lineNumber":2848,"utf16Col":4},"end":{"lineNumber":2848,"utf16Col":14}},"extentUtf16":{"start":{"lineNumber":2848,"utf16Col":0},"end":{"lineNumber":2878,"utf16Col":0}}},{"name":" 3.3 compose1和compose2","kind":"section_3","identStart":125260,"identEnd":125284,"extentStart":125257,"extentEnd":127549,"fullyQualifiedName":" 3.3 compose1和compose2","identUtf16":{"start":{"lineNumber":2878,"utf16Col":3},"end":{"lineNumber":2878,"utf16Col":25}},"extentUtf16":{"start":{"lineNumber":2878,"utf16Col":0},"end":{"lineNumber":2940,"utf16Col":0}}},{"name":" 1）compose1","kind":"section_4","identStart":125290,"identEnd":125303,"extentStart":125286,"extentEnd":126338,"fullyQualifiedName":" 1）compose1","identUtf16":{"start":{"lineNumber":2880,"utf16Col":4},"end":{"lineNumber":2880,"utf16Col":15}},"extentUtf16":{"start":{"lineNumber":2880,"utf16Col":0},"end":{"lineNumber":2909,"utf16Col":0}}},{"name":" 2）compose2","kind":"section_4","identStart":126342,"identEnd":126355,"extentStart":126338,"extentEnd":127549,"fullyQualifiedName":" 2）compose2","identUtf16":{"start":{"lineNumber":2909,"utf16Col":4},"end":{"lineNumber":2909,"utf16Col":15}},"extentUtf16":{"start":{"lineNumber":2909,"utf16Col":0},"end":{"lineNumber":2940,"utf16Col":0}}},{"name":" 3.4 用于函数指针的ptr_fun","kind":"section_3","identStart":127552,"identEnd":127585,"extentStart":127549,"extentEnd":129283,"fullyQualifiedName":" 3.4 用于函数指针的ptr_fun","identUtf16":{"start":{"lineNumber":2940,"utf16Col":3},"end":{"lineNumber":2940,"utf16Col":22}},"extentUtf16":{"start":{"lineNumber":2940,"utf16Col":0},"end":{"lineNumber":2985,"utf16Col":0}}},{"name":" 3.5 用于成员函数指针的mem_fun和mem_fun_ref","kind":"section_3","identStart":129286,"identEnd":129339,"extentStart":129283,"extentEnd":133951,"fullyQualifiedName":" 3.5 用于成员函数指针的mem_fun和mem_fun_ref","identUtf16":{"start":{"lineNumber":2985,"utf16Col":3},"end":{"lineNumber":2985,"utf16Col":36}},"extentUtf16":{"start":{"lineNumber":2985,"utf16Col":0},"end":{"lineNumber":3131,"utf16Col":0}}}]}},"copilotInfo":null,"copilotAccessAllowed":false,"csrf_tokens":{"/arkingc/note/branches":{"post":"M3f2xHMZ_um3FqFcu3hIxNoNM0MmDLTwNHoPmeqmwXEYGOqcBNZiq1Kr0B9OZpUgbD5OzFivbWiX7-Fa-Qbv9A"},"/repos/preferences":{"post":"Jq16WLWGMeR0N004LlLanaEU-IZcYOQhF3BN1Wgfsi7Wqpah0he6CCwg72fHQ9qkspNkpGcOjTsUQ9SQrYDrFA"}}},"title":"note/C++/STL源码剖析.md at master · arkingc/note"}